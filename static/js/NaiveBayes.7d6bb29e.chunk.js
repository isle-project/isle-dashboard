"use strict";(self.webpackChunkisle_dashboard=self.webpackChunkisle_dashboard||[]).push([[139],{97343:function(module,__unused_webpack_exports,__webpack_require__){var isArrayArray2=__webpack_require__(10558);module.exports=isArrayArray2},10558:function(module,__unused_webpack_exports,__webpack_require__){var arrayfun=__webpack_require__(38478),isArray=__webpack_require__(76266),isArrayArray2=arrayfun(isArray);module.exports=isArrayArray2},57416:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:function(){return main}});var react=__webpack_require__(45254),prop_types=__webpack_require__(45697),prop_types_default=__webpack_require__.n(prop_types),commonjs=__webpack_require__(81468),Alert=__webpack_require__(24032),Alert_default=__webpack_require__.n(Alert),Button=__webpack_require__(30276),Button_default=__webpack_require__.n(Button),lib=__webpack_require__(61635),lib_default=__webpack_require__.n(lib),table=__webpack_require__(63393),exp_lib=__webpack_require__(66286),exp_lib_default=__webpack_require__.n(exp_lib),tooltip=__webpack_require__(77287),array_lib=__webpack_require__(40083),array_lib_default=__webpack_require__.n(array_lib),has_own_property_lib=__webpack_require__(10813),is_array_array_lib=__webpack_require__(97343),is_array_array_lib_default=__webpack_require__.n(is_array_array_lib),is_array_like_lib=__webpack_require__(33283),is_array_like_lib_default=__webpack_require__.n(is_array_like_lib),is_matrix_like_lib=__webpack_require__(71840),is_matrix_like_lib_default=__webpack_require__.n(is_matrix_like_lib),is_number_lib=__webpack_require__(91317),uniq=__webpack_require__(38706),uniq_default=__webpack_require__.n(uniq),ln_lib=__webpack_require__(68252),ln_lib_default=__webpack_require__.n(ln_lib),pow_lib=__webpack_require__(66015),pow_lib_default=__webpack_require__.n(pow_lib),pi_lib=__webpack_require__(92663),pi_lib_default=__webpack_require__.n(pi_lib),mean=__webpack_require__(73306),stdev=__webpack_require__(43073),max=__webpack_require__(28118),subtract=__webpack_require__(93040);function GaussianFit(x,y){this.n=x.shape[0],this.p=x.shape[1],this.classes=uniq_default()(y.slice()),this.nclass=this.classes.length,this.fitGaussian(x,y)}GaussianFit.prototype.score=__webpack_require__(30969),GaussianFit.prototype.fitGaussian=function(x,y){this.prior={};const shape=[this.p,this.nclass];this.mu=array_lib_default()(new Float64Array(shape[0]*shape[1]),{shape}),this.sigma=array_lib_default()(new Float64Array(shape[0]*shape[1]),{shape});for(let i=0;i<this.nclass;i++){const ids=[],c=this.classes[i];for(let j=0;j<this.n;j++)y[j]===c&&ids.push(j);const nc=ids.length;this.prior[c]=ln_lib_default()(nc/this.n);for(let j=0;j<this.p;j++){const vals=ids.map(i2=>x.get(i2,j)),mu=(0,mean.Z)(vals),sigma=(0,stdev.Z)(vals);this.mu.set(j,i,mu),this.sigma.set(j,i,sigma)}}},GaussianFit.prototype.calcGaussianProb=function(x,i){const c=this.classes[i];let res=this.prior[c];for(let j=0;j<this.p;j++){const sigma=this.sigma.get(j,i),s2=sigma*sigma,mu=this.mu.get(j,i);res+=-.5*ln_lib_default()(2*pi_lib_default()*s2)-pow_lib_default()(x[j]-mu,2)/s2}return res},GaussianFit.prototype.predictOne=function(x){const nClasses=this.classes.length,logLik=new Array(nClasses);for(let i=0;i<nClasses;i++)logLik[i]=this.calcGaussianProb(x,i);let max2=logLik[0],argmax=this.classes[0];for(let i=0;i<nClasses;i++){const val=logLik[i];val>max2&&(max2=val,argmax=this.classes[i])}return argmax},GaussianFit.prototype.predict=function(x){const nClasses=this.classes.length;if(is_array_array_lib_default()(x)&&(x=array_lib_default()(x)),is_matrix_like_lib_default()(x)){const[nrow,ncol]=x.shape,ret=new Array(nrow);for(let i=0;i<nrow;i++){const logLik=new Array(nClasses);for(let j=0;j<nClasses;j++){const arr=new Array(ncol);for(let k=0;k<ncol;k++)arr[k]=x.get(i,k);logLik[j]=this.calcGaussianProb(arr,j)}let max2=logLik[0],argmax=this.classes[0];for(let j=0;j<nClasses;j++){const val=logLik[j];val>max2&&(max2=val,argmax=this.classes[j])}ret[i]=argmax}return ret}return this.predictOne(x)},GaussianFit.prototype.predictProbs=function(x){if(is_array_array_lib_default()(x)&&(x=array_lib_default()(x)),is_matrix_like_lib_default()(x)){const[nrow,ncol]=x.shape,ret=new Array(nrow);for(let i=0;i<nrow;i++){let logLik2=new Array(this.nclass);for(let j=0;j<this.nclass;j++){const arr=new Array(ncol);for(let k=0;k<ncol;k++)arr[k]=x.get(i,k);logLik2[j]=this.calcGaussianProb(arr,j)}const a2=(0,max.Z)(logLik2);let summand2=0;for(let j=0;j<logLik2.length;j++)summand2+=exp_lib_default()(logLik2[j]-a2);const denom2=a2+ln_lib_default()(summand2);logLik2=(0,subtract.Z)(logLik2,denom2),ret[i]=logLik2.map(x2=>exp_lib_default()(x2))}return ret}const logLik=new Array(this.nclass);for(let j=0;j<this.nclass;j++)logLik[j]=this.calcGaussianProb(x,j);const a=(0,max.Z)(logLik);let summand=0;for(let j=0;j<logLik.length;j++)summand+=exp_lib_default()(logLik[j]-a);const denom=a+ln_lib_default()(summand);return logLik=(0,subtract.Z)(logLik,denom),logLik.map(x2=>exp_lib_default()(x2))};var gaussian=GaussianFit,sum=__webpack_require__(82479);function multinomial_MultinomialFit(x,y,alpha){this.n=x.shape[0],this.p=x.shape[1],this.classes=uniq_default()(y.slice()),this.nclass=this.classes.length,this.alpha=alpha,this.fitMultinomial(x,y)}multinomial_MultinomialFit.prototype.score=__webpack_require__(30969),multinomial_MultinomialFit.prototype.fitMultinomial=function(x,y){const prior={},shape=[this.p,this.nclass],cprob=array_lib_default()(new Float64Array(shape[0]*shape[1]),{shape});for(let i=0;i<this.nclass;i++){const ids=[],counts=new Int32Array(this.p),c=this.classes[i];for(let j=0;j<this.n;j++)y[j]===c&&ids.push(j);const nc=ids.length;prior[c]=ln_lib_default()(nc/this.n);let totalCount=0;for(let j=0;j<this.p;j++){const vals=ids.map(i2=>x.get(i2,j));counts[j]=(0,sum.Z)(vals),totalCount+=counts[j]}for(let j=0;j<this.p;j++){const val=ln_lib_default()(counts[j]+this.alpha)-ln_lib_default()(totalCount+this.p*this.alpha);cprob.set(j,i,val)}}this.prior=prior,this.cprob=cprob},multinomial_MultinomialFit.prototype.calcMultinomProb=function(x,i,j){const c=this.classes[i];let res=this.prior[c];for(j=0;j<this.p;j++)res+=x[j]?x[j]*this.cprob.get(j,i):0;return res},multinomial_MultinomialFit.prototype.predictOne=function(x){const nClasses=this.classes.length,logLik=new Array(nClasses);for(let i=0;i<nClasses;i++){const c=this.classes[i];logLik[i]=this.prior[c];for(let j=0;j<this.p;j++){const val=x[j]?x[j]*this.cprob.get(j,i):0;logLik[i]+=val}}let max2=logLik[0],argmax=this.classes[0];for(let i=0;i<nClasses;i++){const val=logLik[i];val>max2&&(max2=val,argmax=this.classes[i])}return argmax},multinomial_MultinomialFit.prototype.predict=function(x){const nClasses=this.classes.length;if(is_array_array_lib_default()(x)&&(x=array_lib_default()(x)),is_matrix_like_lib_default()(x)){const ret=[],nrow=x.shape[0];for(let i=0;i<nrow;i++){const logLik=new Array(nClasses);for(let j=0;j<nClasses;j++){const c=this.classes[j];logLik[j]=this.prior[c];for(let k=0;k<this.p;k++){const val=x.get(i,k)?x.get(i,k)*this.cprob.get(k,j):0;logLik[j]+=val}}let max2=logLik[0],argmax=this.classes[0];for(let j=0;j<nClasses;j++){const val=logLik[j];val>max2&&(max2=val,argmax=this.classes[j])}ret[i]=argmax}return ret}return this.predictOne(x)},multinomial_MultinomialFit.prototype.predictProbs=function(x){if(is_array_array_lib_default()(x)&&(x=array_lib_default()(x)),is_matrix_like_lib_default()(x)){const nrow=x.shape[0],ret=new Array(nrow);for(let i=0;i<nrow;i++){let logLik2=new Array(this.nclass);for(let j=0;j<this.nclass;j++){const c=this.classes[j];logLik2[j]=this.prior[c];for(let k=0;k<this.p;k++){const val=x.get(i,k)?x.get(i,k)*this.cprob.get(k,j):0;logLik2[j]+=val}}const a2=(0,max.Z)(logLik2);let summand2=0;for(let j=0;j<logLik2.length;j++)summand2+=exp_lib_default()(logLik2[j]-a2);const denom2=a2+ln_lib_default()(summand2);logLik2=(0,subtract.Z)(logLik2,denom2),ret[i]=logLik2.map(x2=>exp_lib_default()(x2))}return ret}let logLik=new Array(this.nclass);for(let j=0;j<this.nclass;j++){const c=this.classes[j];logLik[j]=this.prior[c];for(let k=0;k<this.p;k++){const val=x[k]*this.cprob.get(k,j);logLik[j]+=val}}const a=(0,max.Z)(logLik);let summand=0;for(let j=0;j<logLik.length;j++)summand+=exp_lib_default()(logLik[j]-a);const denom=a+ln_lib_default()(summand);return logLik=(0,subtract.Z)(logLik,denom),logLik.map(x2=>exp_lib_default()(x2))};var multinomial=null;function multinomNB(x,y,opts){if(isArrayArray(x))x=ndarray(x);else if(!isMatrixLike(x)){const msg="invalid input argument. The first argument must be a matrix or an array-of-arrays. Value: `"+x+"`";throw new TypeError(msg)}if(!isArrayLike(y))throw new TypeError("invalid input argument. The second argument must be array-like. Value: `"+y+"`");if(arguments>2&&hasOwnProperty(opts,"alpha")&&!isNumber(opts.alpha))throw new TypeError("invalid option. Laplace smoothing option must be a number primitive. Option: `"+opts.alpha+"`.");const alpha=opts.alpha||1;return new MultinomialFit(x,y,alpha)}function gaussianNB(x,y){if(is_array_array_lib_default()(x))x=array_lib_default()(x);else if(!is_matrix_like_lib_default()(x)){const msg="invalid input argument. The first argument must be a matrix or an array-of-arrays. Value: `"+x+"`";throw new TypeError(msg)}if(!is_array_like_lib_default()(y))throw new TypeError("invalid input argument. The second argument must be array-like. Value: `"+y+"`");return new gaussian(x,y)}var is_array_lib=__webpack_require__(76266),is_array_lib_default=__webpack_require__.n(is_array_lib),extract_categories_from_values=__webpack_require__(99375),is_non_missing_number=__webpack_require__(35865),is_missing=__webpack_require__(45250);function designMatrix(x,y,data,quantitative){let matrix=[];const predictors=[],hash={};is_array_lib_default()(x)||(x=[x]);for(let j=0;j<x.length;j++){const values=data[x[j]];if(lib_default()(quantitative,x[j]))predictors.push(x[j]);else{const categories=(0,extract_categories_from_values.Z)(values,x[j]);for(let k=0;k<categories.length;k++)predictors.push(`${x[j]}_${categories[k]}`);hash[x[j]]=categories}}const nobs=data[x[0]].length;for(let i=0;i<nobs;i++){const row=[];for(let j=0;j<x.length;j++){const values=data[x[j]];if(lib_default()(quantitative,x[j]))row.push(values[i]);else{const categories=hash[x[j]],val=values[i];for(let k=0;k<categories.length;k++)row.push(val===categories[k]?1:0)}}matrix.push(row)}matrix=array_lib_default()(matrix);const yvalues=data[y];return{matrix,predictors,yvalues}}function designMatrixMissing(x,y,data,quantitative){let matrix=[];const predictors=[],hash={};is_array_lib_default()(x)||(x=[x]);for(let j=0;j<x.length;j++){const values=data[x[j]];if(lib_default()(quantitative,x[j]))predictors.push(x[j]);else{const categories=(0,extract_categories_from_values.Z)(values,x[j]);for(let k=0;k<categories.length;k++)predictors.push(`${x[j]}_${categories[k]}`);hash[x[j]]=categories}}const nobs=data[x[0]].length,yvalues=[];for(let i=0;i<nobs;i++){const row=[];let missing=!1;for(let j=0;j<x.length;j++){const values=data[x[j]];if(lib_default()(quantitative,x[j]))(0,is_non_missing_number.Z)(values[i])?row.push(values[i]):missing=!0;else{const categories=hash[x[j]],val=values[i];if((0,is_missing.Z)(val))missing=!0;else for(let k=0;k<categories.length;k++)row.push(val===categories[k]?1:0)}}(0,is_missing.Z)(data[y][i])&&(missing=!0),missing||(matrix.push(row),yvalues.push(data[y][i]))}return matrix=array_lib_default()(matrix),{matrix,predictors,yvalues}}var prop_check=__webpack_require__(25048),factor_variable=__webpack_require__(93199),__defProp=Object.defineProperty,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:!0,configurable:!0,writable:!0,value}):obj[key]=value,__spreadValues=(a,b)=>{for(var prop in b||(b={}))__hasOwnProp.call(b,prop)&&__defNormalProp(a,prop,b[prop]);if(__getOwnPropSymbols)for(var prop of __getOwnPropSymbols(b))__propIsEnum.call(b,prop)&&__defNormalProp(a,prop,b[prop]);return a},__publicField=(obj,key,value)=>(__defNormalProp(obj,typeof key!="symbol"?key+"":key,value),value);let COUNTER=0;const summaryTable=(predictors,result,quantitative,t)=>react.createElement("div",null,react.createElement("span",{className:"title"},t("apriori-probs"),":"),react.createElement(table.Z,{bordered:!0,size:"sm"},react.createElement("thead",null,react.createElement("tr",null,result.classes.map((x,i)=>react.createElement("th",{key:i},x)))),react.createElement("tbody",null,react.createElement("tr",null,result.classes.map((x,i)=>react.createElement("th",{key:i},exp_lib_default()(result.prior[x]).toFixed(3)))))),react.createElement("span",{className:"title"},t("conditionals"),":"),predictors.map((pred,i)=>lib_default()(quantitative,pred)?react.createElement(table.Z,{bordered:!0,size:"sm",key:i},react.createElement("thead",null,react.createElement("tr",null,react.createElement("th",null,pred),result.classes.map((x,i2)=>react.createElement("th",{key:i2},x)))),react.createElement("tbody",null,react.createElement("tr",null,react.createElement("th",null,t("mean")),result.classes.map((_,j)=>react.createElement("td",{key:`${i}-${j}`},result.mu.get(i,j).toFixed(6)))),react.createElement("tr",null,react.createElement("th",null,t("sd")),result.classes.map((_,j)=>react.createElement("td",{key:`${i}-${j}`},result.sigma.get(i,j).toFixed(6)))))):react.createElement(table.Z,{bordered:!0,size:"sm",key:i},react.createElement("thead",null,react.createElement("tr",null,react.createElement("th",null,pred),result.classes.map((x,i2)=>react.createElement("th",{key:i2},x)))),react.createElement("tbody",null,react.createElement("tr",null,react.createElement("th",null,t("yes")),result.classes.map((_,j)=>react.createElement("td",{key:`${i}-${j}`},result.mu.get(i,j).toFixed(3)))),react.createElement("tr",null,react.createElement("th",null,t("no")),result.classes.map((_,j)=>react.createElement("td",{key:`${i}-${j}`},(1-result.mu.get(i,j)).toFixed(3)))))))),fitModel=({x,y,data,quantitative,omitMissing})=>{try{const designM=omitMissing?designMatrixMissing:designMatrix,{matrix,predictors,yvalues}=designM(x,y,data,quantitative);return{result:gaussianNB(matrix,yvalues),predictors}}catch(error){return{}}};class NaiveBayes extends react.Component{constructor(props){super(props),__publicField(this,"handlePrediction",()=>{const predict=data2=>{const result=this.state.result,{matrix}=designMatrix(this.props.x,this.props.y,data2,this.props.quantitative),probs=result.predictProbs(matrix),classProbs={};for(let i=0;i<result.classes.length;i++){const name2="probs_"+result.classes[i]+"_bayes"+COUNTER;classProbs[name2]=probs.map(x2=>x2[i])}const fitted=result.predict(matrix),name="pred_bayes"+COUNTER,newCategorical=this.props.categorical.slice();return lib_default()(newCategorical,name)||newCategorical.push(name),{fitted,classProbs}};this.props.onPredict(predict,COUNTER)}),COUNTER+=1;const{x,y,data,quantitative,omitMissing}=props;this.state=__spreadValues(__spreadValues({},fitModel({x,y,data,quantitative,omitMissing})),props)}static getDerivedStateFromProps(nextProps,prevState){if(nextProps.data!==prevState.data||nextProps.quantitative!==prevState.quantitative||nextProps.x!==prevState.x||nextProps.y!==prevState.y||nextProps.omitMissing!==prevState.omitMissing){const{x,y,data,quantitative,omitMissing}=nextProps;return __spreadValues(__spreadValues({},fitModel({x,y,data,quantitative,omitMissing})),nextProps)}return null}render(){const{result,predictors}=this.state,{t}=this.props;return result?react.createElement("div",{style:{overflowX:"auto",width:"100%"}},react.createElement("span",{className:"title"},t("naive-bayes-for-response",{y:this.props.y,counter:COUNTER})),summaryTable(predictors,result,this.props.quantitative,t),this.props.onPredict?react.createElement(tooltip.Z,{tooltip:t("use-model-to-predict-tooltip")},react.createElement(Button_default(),{variant:"secondary",size:"sm",onClick:this.handlePrediction},t("use-model-to-predict"))):null):react.createElement(Alert_default(),{variant:"danger"},t("missing-attributes"))}}NaiveBayes.defaultProps={omitMissing:!1,onPredict:null},NaiveBayes.propTypes={data:prop_types_default().object.isRequired,y:prop_types_default().oneOfType([prop_types_default().string,prop_types_default().instanceOf(factor_variable.E)]).isRequired,x:prop_types_default().oneOfType([prop_types_default().arrayOf(prop_types_default().oneOfType([prop_types_default().string,prop_types_default().instanceOf(factor_variable.E)])),prop_types_default().string,prop_types_default().instanceOf(factor_variable.E)]).isRequired,quantitative:prop_types_default().arrayOf(prop_types_default().string).isRequired,omitMissing:prop_types_default().bool,onPredict:prop_types_default().func};var main=(0,commonjs.Zh)("models")((0,prop_check.W)(NaiveBayes))},30969:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);var _stdlib_assert_is_array_like__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(33283),_stdlib_assert_is_array_like__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_stdlib_assert_is_array_like__WEBPACK_IMPORTED_MODULE_0__);function score(x,y){if(!_stdlib_assert_is_array_like__WEBPACK_IMPORTED_MODULE_0___default()(x))throw new TypeError("invalid argument. First argument must be a matrix or array of test data. Value: `"+x+"`");if(!_stdlib_assert_is_array_like__WEBPACK_IMPORTED_MODULE_0___default()(y))throw new TypeError("invalid argument. Second argument must be an array of labels for the test data. Value: `"+y+"`");const yhat=this.predict(x),n=y.length;let accuracy=0;for(let i=0;i<n;i++)yhat[i]===y[i]&&(accuracy+=1);return accuracy/=n,accuracy}__webpack_exports__.default=score}}]);

//# sourceMappingURL=NaiveBayes.7d6bb29e.chunk.js.map
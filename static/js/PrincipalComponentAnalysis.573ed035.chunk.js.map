{"version":3,"sources":["../node_modules/@isle-project/components/models/principal-component-analysis/main.js","../node_modules/ml-pca/pca.js"],"names":[],"mappings":"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","file":"static/js/PrincipalComponentAnalysis.573ed035.chunk.js","sourcesContent":["// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Alert from 'react-bootstrap/Alert';\nimport { PCA } from 'ml-pca';\nimport { withTranslation } from 'react-i18next';\nimport Table from '@isle-project/components/table';\nimport incrspace from '@stdlib/array/incrspace';\nimport Plotly from '@isle-project/components/plotly';\nimport { withPropCheck } from '@isle-project/utils/prop-check';\nimport isNonMissingNumber from '@isle-project/utils/is-non-missing-number';\n\n\n// FUNCTIONS //\n\nconst summaryTable = ( stdev, variance, cumVariance, t ) => {\n\t/* eslint-disable i18next/no-literal-string */\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th></th>\n\t\t\t\t\t<th>{t('standard-deviation')}</th>\n\t\t\t\t\t<th>{t('proportion-of-variance')}</th>\n\t\t\t\t\t<th>{t('cumulative-variance')}</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{stdev.map( ( val, id ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={id}>\n\t\t\t\t\t\t\t<th> {`PC${id+1}`} </th>\n\t\t\t\t\t\t\t<td> {val.toFixed( 3 )} </td>\n\t\t\t\t\t\t\t<td> {variance[ id ].toFixed( 3 )} </td>\n\t\t\t\t\t\t\t<td> {cumVariance[ id ].toFixed( 3 )} </td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n\t/* eslint-enable i18next/no-literal-string */\n};\n\nconst fitModel = ({ data, variables, scale, center, noComponents }) => {\n\ttry {\n\t\tconst matrix = [];\n\t\tconst n = data[ variables[ 0 ] ].length;\n\t\tfor ( let i = 0; i < n; i++ ) {\n\t\t\tconst row = [];\n\t\t\tlet missing = false;\n\t\t\tfor ( let j = 0; j < variables.length; j++ ) {\n\t\t\t\tconst val = data[ variables[ j ] ][ i ];\n\t\t\t\tif ( isNonMissingNumber( val ) ) {\n\t\t\t\t\trow.push( val );\n\t\t\t\t} else {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !missing ) {\n\t\t\t\tmatrix.push( row );\n\t\t\t}\n\t\t}\n\t\tconst pca = new PCA( matrix, {\n\t\t\tcenter,\n\t\t\tscale\n\t\t});\n\t\tconst components = pca.predict( matrix, {\n\t\t\tnoComponents\n\t\t});\n\t\treturn {\n\t\t\tpca,\n\t\t\tcomponents\n\t\t};\n\t} catch ( _ ) {\n\t\treturn {};\n\t}\n};\n\n\n// MAIN //\n\n/**\n* Principal component analysis.\n*\n* @property {Object} data - object of value arrays\n* @property {Array<string>} variables - names of variables used for clustering\n* @property {boolean} scale - scale values by dividing with the standard deviation\n* @property {boolean} center - center values by subtracting the mean\n* @property {number} noComponents - number of components supplied to the `onResult` callback\n* @property {Function} onResult - callback invoked with model object and components\n*/\nclass PrincipalComponentAnalysis extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\n\t\tconst { data, variables, scale, center, noComponents } = props;\n\t\tconst { pca, components } = fitModel( { data, variables, scale, center, noComponents } );\n\t\tthis.state = {\n\t\t\tpca,\n\t\t\tcomponents,\n\t\t\t...props\n\t\t};\n\t\tif ( pca ) {\n\t\t\tprops.onResult( this.state.pca, this.state.components );\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.variables !== prevState.variables\n\t\t) {\n\t\t\tconst { data, variables, scale, center, noComponents } = nextProps;\n\t\t\tconst newState = {\n\t\t\t\t...fitModel( { data, variables, scale, center, noComponents } ),\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t\tif ( newState.pca ) {\n\t\t\t\tnextProps.onResult( newState.pca, newState.components );\n\t\t\t}\n\t\t\treturn newState;\n\t\t}\n\t\treturn null;\n\t}\n\n\trender() {\n\t\tconst { pca } = this.state;\n\t\tconst { t } = this.props;\n\t\tif ( !pca ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\tconst stdev = pca.getStandardDeviations();\n\t\tconst variance = pca.getExplainedVariance();\n\t\tconst cumVariance = pca.getCumulativeVariance();\n\t\tconst trace = {\n\t\t\tx: incrspace( 0, variance.length, 1 ),\n\t\t\ty: variance,\n\t\t\ttype: 'scatter',\n\t\t\tname: t('proportion-of-variance')\n\t\t};\n\t\treturn (<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('pca-summary')}</span>\n\t\t\t\t{summaryTable( stdev, variance, cumVariance, t )}\n\t\t\t\t<Plotly editable data={[ trace ]} layout={{\n\t\t\t\t\txaxis: {\n\t\t\t\t\t\ttitle: t('principal-component')\n\t\t\t\t\t},\n\t\t\t\t\tyaxis: {\n\t\t\t\t\t\ttitle: t('explained-proportion')\n\t\t\t\t\t}\n\t\t\t\t}} />\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nPrincipalComponentAnalysis.defaultProps = {\n\tcenter: true,\n\tscale: false,\n\tnoComponents: 0,\n\tonResult() {}\n};\n\nPrincipalComponentAnalysis.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\tvariables: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tcenter: PropTypes.bool,\n\tscale: PropTypes.bool,\n\tnoComponents: PropTypes.number,\n\tonResult: PropTypes.func\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'models' )( withPropCheck( PrincipalComponentAnalysis ) );\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar mlMatrix = require('ml-matrix');\n\n/**\r\n * Creates new PCA (Principal Component Analysis) from the dataset\r\n * @param {Matrix} dataset - dataset or covariance matrix.\r\n * @param {Object} [options]\r\n * @param {boolean} [options.isCovarianceMatrix=false] - true if the dataset is a covariance matrix.\r\n * @param {string} [options.method='SVD'] - select which method to use: SVD (default), covarianceMatrirx or NIPALS.\r\n * @param {number} [options.nCompNIPALS=2] - number of components to be computed with NIPALS.\r\n * @param {boolean} [options.center=true] - should the data be centered (subtract the mean).\r\n * @param {boolean} [options.scale=false] - should the data be scaled (divide by the standard deviation).\r\n * @param {boolean} [options.ignoreZeroVariance=false] - ignore columns with zero variance if `scale` is `true`.\r\n * */\r\nclass PCA {\r\n  constructor(dataset, options = {}) {\r\n    if (dataset === true) {\r\n      const model = options;\r\n      this.center = model.center;\r\n      this.scale = model.scale;\r\n      this.means = model.means;\r\n      this.stdevs = model.stdevs;\r\n      this.U = mlMatrix.Matrix.checkMatrix(model.U);\r\n      this.S = model.S;\r\n      this.R = model.R;\r\n      this.excludedFeatures = model.excludedFeatures || [];\r\n      return;\r\n    }\r\n\r\n    dataset = new mlMatrix.Matrix(dataset);\r\n\r\n    const {\r\n      isCovarianceMatrix = false,\r\n      method = 'SVD',\r\n      nCompNIPALS = 2,\r\n      center = true,\r\n      scale = false,\r\n      ignoreZeroVariance = false,\r\n    } = options;\r\n\r\n    this.center = center;\r\n    this.scale = scale;\r\n    this.means = null;\r\n    this.stdevs = null;\r\n    this.excludedFeatures = [];\r\n\r\n    if (isCovarianceMatrix) {\r\n      // User provided a covariance matrix instead of dataset.\r\n      this._computeFromCovarianceMatrix(dataset);\r\n      return;\r\n    }\r\n\r\n    this._adjust(dataset, ignoreZeroVariance);\r\n    switch (method) {\r\n      case 'covarianceMatrix': {\r\n        // User provided a dataset but wants us to compute and use the covariance matrix.\r\n        const covarianceMatrix = new mlMatrix.MatrixTransposeView(dataset)\r\n          .mmul(dataset)\r\n          .div(dataset.rows - 1);\r\n        this._computeFromCovarianceMatrix(covarianceMatrix);\r\n        break;\r\n      }\r\n      case 'NIPALS': {\r\n        this._computeWithNIPALS(dataset, nCompNIPALS);\r\n        break;\r\n      }\r\n      case 'SVD': {\r\n        const svd = new mlMatrix.SVD(dataset, {\r\n          computeLeftSingularVectors: false,\r\n          computeRightSingularVectors: true,\r\n          autoTranspose: true,\r\n        });\r\n\r\n        this.U = svd.rightSingularVectors;\r\n\r\n        const singularValues = svd.diagonal;\r\n        const eigenvalues = [];\r\n        for (const singularValue of singularValues) {\r\n          eigenvalues.push(\r\n            (singularValue * singularValue) / (dataset.rows - 1),\r\n          );\r\n        }\r\n        this.S = eigenvalues;\r\n        break;\r\n      }\r\n      default: {\r\n        throw new Error(`unknown method: ${method}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load a PCA model from JSON\r\n   * @param {Object} model\r\n   * @return {PCA}\r\n   */\r\n  static load(model) {\r\n    if (typeof model.name !== 'string') {\r\n      throw new TypeError('model must have a name property');\r\n    }\r\n    if (model.name !== 'PCA') {\r\n      throw new RangeError(`invalid model: ${model.name}`);\r\n    }\r\n    return new PCA(true, model);\r\n  }\r\n\r\n  /**\r\n   * Project the dataset into the PCA space\r\n   * @param {Matrix} dataset\r\n   * @param {Object} options\r\n   * @return {Matrix} dataset projected in the PCA space\r\n   */\r\n  predict(dataset, options = {}) {\r\n    const { nComponents = this.U.columns } = options;\r\n    dataset = new mlMatrix.Matrix(dataset);\r\n    if (this.center) {\r\n      dataset.subRowVector(this.means);\r\n      if (this.scale) {\r\n        for (let i of this.excludedFeatures) {\r\n          dataset.removeColumn(i);\r\n        }\r\n        dataset.divRowVector(this.stdevs);\r\n      }\r\n    }\r\n    let predictions = dataset.mmul(this.U);\r\n    return predictions.subMatrix(0, predictions.rows - 1, 0, nComponents - 1);\r\n  }\r\n\r\n  /**\r\n   * Calculates the inverse PCA transform\r\n   * @param {Matrix} dataset\r\n   * @return {Matrix} dataset projected in the PCA space\r\n   */\r\n  invert(dataset) {\r\n    dataset = mlMatrix.Matrix.checkMatrix(dataset);\r\n\r\n    let inverse = dataset.mmul(this.U.transpose());\r\n\r\n    if (this.center) {\r\n      if (this.scale) {\r\n        inverse.mulRowVector(this.stdevs);\r\n      }\r\n      inverse.addRowVector(this.means);\r\n    }\r\n\r\n    return inverse;\r\n  }\r\n\r\n  /**\r\n   * Returns the proportion of variance for each component\r\n   * @return {[number]}\r\n   */\r\n  getExplainedVariance() {\r\n    let sum = 0;\r\n    for (const s of this.S) {\r\n      sum += s;\r\n    }\r\n    return this.S.map((value) => value / sum);\r\n  }\r\n\r\n  /**\r\n   * Returns the cumulative proportion of variance\r\n   * @return {[number]}\r\n   */\r\n  getCumulativeVariance() {\r\n    let explained = this.getExplainedVariance();\r\n    for (let i = 1; i < explained.length; i++) {\r\n      explained[i] += explained[i - 1];\r\n    }\r\n    return explained;\r\n  }\r\n\r\n  /**\r\n   * Returns the Eigenvectors of the covariance matrix\r\n   * @returns {Matrix}\r\n   */\r\n  getEigenvectors() {\r\n    return this.U;\r\n  }\r\n\r\n  /**\r\n   * Returns the Eigenvalues (on the diagonal)\r\n   * @returns {[number]}\r\n   */\r\n  getEigenvalues() {\r\n    return this.S;\r\n  }\r\n\r\n  /**\r\n   * Returns the standard deviations of the principal components\r\n   * @returns {[number]}\r\n   */\r\n  getStandardDeviations() {\r\n    return this.S.map((x) => Math.sqrt(x));\r\n  }\r\n\r\n  /**\r\n   * Returns the loadings matrix\r\n   * @return {Matrix}\r\n   */\r\n  getLoadings() {\r\n    return this.U.transpose();\r\n  }\r\n\r\n  /**\r\n   * Export the current model to a JSON object\r\n   * @return {Object} model\r\n   */\r\n  toJSON() {\r\n    return {\r\n      name: 'PCA',\r\n      center: this.center,\r\n      scale: this.scale,\r\n      means: this.means,\r\n      stdevs: this.stdevs,\r\n      U: this.U,\r\n      S: this.S,\r\n      excludedFeatures: this.excludedFeatures,\r\n    };\r\n  }\r\n\r\n  _adjust(dataset, ignoreZeroVariance) {\r\n    if (this.center) {\r\n      const mean = dataset.mean('column');\r\n      const stdevs = this.scale\r\n        ? dataset.standardDeviation('column', { mean })\r\n        : null;\r\n      this.means = mean;\r\n      dataset.subRowVector(mean);\r\n      if (this.scale) {\r\n        for (let i = 0; i < stdevs.length; i++) {\r\n          if (stdevs[i] === 0) {\r\n            if (ignoreZeroVariance) {\r\n              dataset.removeColumn(i);\r\n              stdevs.splice(i, 1);\r\n              this.excludedFeatures.push(i);\r\n              i--;\r\n            } else {\r\n              throw new RangeError(\r\n                `Cannot scale the dataset (standard deviation is zero at index ${i}`,\r\n              );\r\n            }\r\n          }\r\n        }\r\n        this.stdevs = stdevs;\r\n        dataset.divRowVector(stdevs);\r\n      }\r\n    }\r\n  }\r\n\r\n  _computeFromCovarianceMatrix(dataset) {\r\n    const evd = new mlMatrix.EVD(dataset, { assumeSymmetric: true });\r\n    this.U = evd.eigenvectorMatrix;\r\n    this.U.flipRows();\r\n    this.S = evd.realEigenvalues;\r\n    this.S.reverse();\r\n  }\r\n\r\n  _computeWithNIPALS(dataset, nCompNIPALS) {\r\n    this.U = new mlMatrix.Matrix(nCompNIPALS, dataset.columns);\r\n    this.S = [];\r\n\r\n    let x = dataset;\r\n    for (let i = 0; i < nCompNIPALS; i++) {\r\n      let dc = new mlMatrix.NIPALS(x);\r\n\r\n      this.U.setRow(i, dc.w.transpose());\r\n      this.S.push(Math.pow(dc.s.get(0, 0), 2));\r\n\r\n      x = dc.xResidual;\r\n    }\r\n    this.U = this.U.transpose(); // to be compatible with API\r\n  }\r\n}\n\nexports.PCA = PCA;\n"],"sourceRoot":""}
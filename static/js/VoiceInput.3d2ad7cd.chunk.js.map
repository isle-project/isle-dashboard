{"version":3,"sources":["../node_modules/@isle-project/components/input/voice/microphone.js","../node_modules/@isle-project/components/input/voice/main.js"],"names":[],"mappings":"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","file":"static/js/VoiceInput.3d2ad7cd.chunk.js","sourcesContent":["// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Microphone from '-!svg-react-loader!./img/microphone.svg';\n\n\n// MAIN //\n\nclass Shim extends Component {\n\trender() {\n\t\treturn <button onClick={this.props.onClick} ></button>;\n\t}\n}\n\n\nShim.propTypes = {\n\tonClick: PropTypes.func\n};\n\nShim.defaultProps = {\n\tonClick() {}\n};\n\n\n// EXPORTS //\n\nexport default Microphone || Shim;\n","// MODULES //\n\nimport React, { Fragment, useCallback, useContext, useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport logger from 'debug';\nimport { useTranslation } from 'react-i18next';\nimport Tooltip from 'react-bootstrap/Tooltip';\nimport OverlayTrigger from '@isle-project/components/overlay-trigger';\nimport SessionContext from '@isle-project/session/context.js';\nimport { i18n } from '@isle-project/locales';\nimport Microphone from './microphone.js';\nimport './voice.css';\n\n\n// VARIABLES //\n\nconst debug = logger( 'isle:voice-input' );\n\n\n// FUNCTIONS //\n\nfunction getSpeechRecognition() {\n\ttry {\n\t\tconst SpeechRecognition = global.SpeechRecognition || global.webkitSpeechRecognition; //eslint-disable-line\n\t\tif ( SpeechRecognition ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} catch ( error) {\n\t\treturn false;\n\t}\n}\n\nfunction createGrammarList( grammars ) {\n\tconst SpeechGrammarList = global.SpeechGrammarList || global.webkitSpeechGrammarList; //eslint-disable-line\n\tconst grammarList = new SpeechGrammarList();\n\tfor ( let i = 0; i < grammars.length; i++ ) {\n\t\tconst { src, weight } = grammars[ i ];\n\t\tgrammarList.addFromString( src, weight );\n\t}\n\treturn grammarList;\n}\n\n\n// MAIN //\n\n/**\n* A voice input component.\n*\n* @property {boolean} autorecord - controls whether to automatically start recording\n* @property {string} defaultValue - default text value\n* @property {Array} grammars - speech grammar list (unsupported)\n* @property {string} legend - legend displayed in front of input field\n* @property {string} mode - set to `full` to display a text input field alongside the microphone, `status` to only display a statusbar with the transcribed texts, `microphone` to show just a button to toggle recording, or `none` when the voice input should be invisible and purely controlled via hotkeys / voice commands\n* @property {number} maxAlternatives - maximum number of alternatives provided per speech recognition result\n* @property {Function} onChange - callback function invoked when text input value is updated\n* @property {Function} onClick - callback function invoked when clicking on the microphone button\n* @property {Function} onFinalText - callback function invoked once final text is received\n* @property {Function} onSegment - callback function invoked with text segments\n* @property {Function} onRecordingStart - callback function invoked when recording is started\n* @property {Function} onRecordingStop - callback function invoked once recording is stopped\n* @property {Function} onSubmit - callback function when submitting text input value by hitting \"Enter\"\n* @property {string} placeholder - text input placeholder\n* @property {Object} remote - object with `start`, `stop`, and `toggle` and associated hotkeys\n* @property {Function} timeout - number of milliseconds after which to timeout the recording\n* @property {Function} stopTooltip - tooltip message displayed while recording\n* @property {Function} startTooltip - tooltip message displayed while not recording\n* @property {string} tooltipPlacement - direction of the tooltip\n* @property {number} width - voice input width (in px)\n* @property {number} height - voice input height (in px)\n* @property {string} className - class name\n* @property {Object} style - CSS inline styles\n*/\nconst VoiceInput = ( props ) => {\n\tconst { autorecord, bind, defaultValue, grammars, id,\n\t\tmaxAlternatives, remote, startTooltip, stopTooltip, speechInterface,\n\t\tonChange, onClick, onFinalText, onRecordingStart, onRecordingStop, onSegment, onSubmit, timeout } = props;\n\tconst [ isRecording, setIsRecording ] = useState( autorecord );\n\tconst session = useContext( SessionContext );\n\tconst { t } = useTranslation( 'input' );\n\tconst [ value, setValue ] = useState(\n\t\tbind && session.state ? session.state[ bind ]: defaultValue,\n\t);\n\tconst recognizerRef = useRef();\n\tconst timerRef = useRef();\n\n\tconst handleChange = useCallback( ( event ) => {\n\t\tconst newValue = event.target.value;\n\t\tsetValue( newValue );\n\t\tonChange( newValue );\n\t\tif ( bind ) {\n\t\t\tglobal.lesson.setState({\n\t\t\t\t[ bind ]: newValue\n\t\t\t});\n\t\t}\n\t}, [ bind, onChange ] );\n\n\tconst handleKeyDown = useCallback( ( event ) => {\n\t\tswitch ( event.keyCode ) {\n\t\tcase 13:\n\t\t\tonSubmit( value );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}, [ value, onSubmit ] );\n\n\tconst stop = useCallback( () => {\n\t\tdebug( 'Set `isRecording` to false...' );\n\t\tsetIsRecording( false );\n\t\tif ( recognizerRef.current ) {\n\t\t\trecognizerRef.current.stop();\n\t\t}\n\t\tonRecordingStop();\n\t}, [ onRecordingStop ] );\n\n\tconst start = useCallback( () => {\n\t\trecognizerRef.current = null;\n\t\tconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; //eslint-disable-line\n\t\tif ( SpeechRecognition ) {\n\t\t\tconst recognizer = new SpeechRecognition();\n\t\t\trecognizer.lang = i18n.language;\n\t\t\trecognizer.continuous = true;\n\t\t\trecognizer.interimResults = true;\n\t\t\trecognizer.maxAlternatives = maxAlternatives;\n\t\t\trecognizer.grammars = createGrammarList( grammars );\n\n\t\t\trecognizer.onerror = ( event ) => {\n\t\t\t\tdebug( 'Encountered an error...' );\n\t\t\t\tif (\n\t\t\t\t\tevent.error === 'not-allowed' ||\n\t\t\t\t\tevent.error === 'service-not-allowed'\n\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\tsetIsRecording( false );\n\t\t\t\t\t\treturn session.addNotification({\n\t\t\t\t\t\t\ttitle: 'Not allowed',\n\t\t\t\t\t\t\tmessage: 'No permission to use the speech recognition service',\n\t\t\t\t\t\t\tlevel: 'error',\n\t\t\t\t\t\t\tposition: 'tr'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\trecognizer.start();\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\tdebug( err );\n\t\t\t\t}\n\t\t\t};\n\t\t\trecognizer.onend = () => {\n\t\t\t\tdebug('onend: %s', id );\n\t\t\t\tif ( isRecording ) {\n\t\t\t\t\t// Restart recording after it stopped due to no voice input for a few seconds:\n\t\t\t\t\trecognizer.start();\n\t\t\t\t}\n\t\t\t};\n\t\t\trecognizer.onstart = () => {\n\t\t\t\tdebug('onstart: %s', id );\n\t\t\t\tonRecordingStart();\n\t\t\t};\n\t\t\trecognizer.onresult = ( event ) => {\n\t\t\t\tdebug( 'Processing result...' );\n\t\t\t\tif ( typeof ( event.results ) === 'undefined' ) {\n\t\t\t\t\tdebug( 'Something went wrong...' );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor ( let i = event.resultIndex; i < event.results.length; ++i ) {\n\t\t\t\t\tconst results = event.results[ i ];\n\t\t\t\t\tif ( event.results[ i ].isFinal ) {\n\t\t\t\t\t\tif ( timeout ) {\n\t\t\t\t\t\t\ttimerRef.current = setTimeout( stop, timeout );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdebug( 'Received final text' );\n\t\t\t\t\t\tlet text;\n\t\t\t\t\t\tif ( maxAlternatives > 1 ) {\n\t\t\t\t\t\t\ttext = new Array( results.length );\n\t\t\t\t\t\t\tfor ( let i = 0; i < results.length; i++ ) {\n\t\t\t\t\t\t\t\ttext[ i ] = results[ i ].transcript;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext = results[ 0 ].transcript;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetValue( text );\n\t\t\t\t\t\tonFinalText( text );\n\t\t\t\t\t\tif ( speechInterface ) {\n\t\t\t\t\t\t\tspeechInterface.check( text, {\n\t\t\t\t\t\t\t\tonStart: () => {\n\t\t\t\t\t\t\t\t\tstop();\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tonEnd: () => {\n\t\t\t\t\t\t\t\t\tstart();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ( timerRef.current ) {\n\t\t\t\t\t\t\tclearTimeout( timerRef.current );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet text;\n\t\t\t\t\t\tif ( maxAlternatives > 1 ) {\n\t\t\t\t\t\t\ttext = new Array( results.length );\n\t\t\t\t\t\t\tfor ( let i = 0; i < results.length; i++ ) {\n\t\t\t\t\t\t\t\ttext[ i ] = results[ i ].transcript;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext = results[ 0 ].transcript;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetValue( text );\n\t\t\t\t\t\tonSegment( text );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\trecognizer.start();\n\t\t\trecognizerRef.current = recognizer;\n\t\t}\n\t\tdebug( 'Set `isRecording` to true...' );\n\t\tsetIsRecording( true );\n\t}, [ grammars, id, isRecording, maxAlternatives, onRecordingStart, session, speechInterface, stop, timeout, onFinalText, onSegment ] );\n\n\tconst tooltipMessage = useCallback( ( recognizable ) => {\n\t\tlet text = '';\n\t\tif ( !recognizable ) {\n\t\t\ttext = 'Your browser does not support voice recognition. You may use the Chrome Browser instead';\n\t\t}\n\t\telse if ( isRecording === true ) {\n\t\t\ttext = stopTooltip || t('click-to-stop-recording');\n\t\t}\n\t\telse {\n\t\t\ttext = startTooltip || t('click-to-start-recording');\n\t\t}\n\t\treturn text;\n\t}, [ isRecording, startTooltip, stopTooltip, t ] );\n\n\tuseEffect( () => {\n\t\tif ( remote ) {\n\t\t\twindow.onkeydown = ( event ) => {\n\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\t\tcase remote.stop:\n\t\t\t\t\t\tstop();\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase remote.start:\n\t\t\t\t\t\tif ( !isRecording ) {\n\t\t\t\t\t\t\tstart();\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase remote.toggle:\n\t\t\t\t\t\tif ( !isRecording ) {\n\t\t\t\t\t\t\tstart();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstop();\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif ( autorecord ) {\n\t\t\tdebug( 'Should record voice...' );\n\t\t\tstart();\n\t\t}\n\t}, [ autorecord, remote, isRecording, start, stop ] );\n\n\tconst handleClick = useCallback( ( event ) => {\n\t\tonClick( event );\n\t\tif ( isRecording ){\n\t\t\tstop();\n\t\t}\n\t\telse {\n\t\t\tstart();\n\t\t}\n\t}, [ isRecording, start, stop, onClick ] );\n\n\tlet mike = 'voice-microphone';\n\tif ( isRecording === true ) {\n\t\tmike = 'voice-microphone voice-recording';\n\t}\n\tconst x = getSpeechRecognition();\n\tconst text = tooltipMessage( x );\n\tconst tooltip = <Tooltip id={`${props.id}-voice-input-tooltip`} >\n\t\t{text}\n\t</Tooltip>;\n\tswitch ( props.mode ) {\n\t\tcase 'full':\n\t\t\treturn (\n\t\t\t\t<Fragment>\n\t\t\t\t\t{ props.legend ? <label>{props.legend}</label> : null }\n\t\t\t\t\t<div className={`input voice-input ${props.className}`} style={{ height: props.height, width: props.width, ...props.style }} >\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tclassName=\"voice-input-text\"\n\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\t\t\t\tonChange={handleChange}\n\t\t\t\t\t\t\tplaceholder={props.placeholder !== null ? props.placeholder : t('enter-text')}\n\t\t\t\t\t\t\tvalue={value}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<OverlayTrigger placement={props.tooltipPlacement} overlay={tooltip}>\n\t\t\t\t\t\t\t<Microphone onClick={handleClick} className={mike} />\n\t\t\t\t\t\t</OverlayTrigger>\n\t\t\t\t\t</div>\n\t\t\t\t</Fragment>\n\t\t\t);\n\t\tcase 'status':\n\t\t\treturn (\n\t\t\t\t<Fragment>\n\t\t\t\t\t{ props.legend ? <label>{props.legend}</label> : null }\n\t\t\t\t\t<div className={`voice-input-status-text ${props.className}`} style={{ height: props.height, width: props.width, ...props.style }} >\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName=\"voice-input-status\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{value}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<OverlayTrigger placement=\"bottom\" overlay={tooltip}>\n\t\t\t\t\t\t\t<Microphone onClick={handleClick} className={mike} />\n\t\t\t\t\t\t</OverlayTrigger>\n\t\t\t\t\t</div>\n\t\t\t\t</Fragment>\n\t\t\t);\n\t\tcase 'microphone':\n\t\t\treturn (\n\t\t\t\t<Fragment>\n\t\t\t\t\t{ props.legend ? <label>{props.legend}</label> : null }\n\t\t\t\t\t<div className={`voice-solo-microphone ${props.className}`} style={{ height: props.height, width: props.width, ...props.style }}>\n\t\t\t\t\t\t<OverlayTrigger placement=\"bottom\" overlay={tooltip}>\n\t\t\t\t\t\t\t<Microphone onClick={handleClick} className={mike} />\n\t\t\t\t\t\t</OverlayTrigger>\n\t\t\t\t\t</div>\n\t\t\t\t</Fragment>\n\t\t\t);\n\t\tcase 'none':\n\t\t\treturn null;\n\t}\n};\n\n\n// PROPERTIES //\n\nVoiceInput.defaultProps = {\n\tautorecord: false,\n\tdefaultValue: '',\n\tgrammars: [],\n\tlegend: '',\n\tmode: 'full',\n\tmaxAlternatives: 1,\n\tonChange() {},\n\tonClick() {},\n\tonFinalText() {},\n\tonSegment() {},\n\tonRecordingStart() {},\n\tonRecordingStop() {},\n\tonSubmit() {},\n\tplaceholder: null,\n\tremote: null,\n\tclassName: '',\n\tstyle: {},\n\ttimeout: null,\n\tstopTooltip: null,\n\tstartTooltip: null,\n\ttooltipPlacement: 'left',\n\twidth: 500,\n\theight: 36\n};\n\nVoiceInput.propTypes = {\n\tautorecord: PropTypes.bool,\n\tdefaultValue: PropTypes.string,\n\tgrammars: PropTypes.array,\n\tlegend: PropTypes.oneOfType([\n\t\tPropTypes.string,\n\t\tPropTypes.node\n\t]),\n\tmode: PropTypes.string,\n\tmaxAlternatives: PropTypes.number,\n\tonChange: PropTypes.func,\n\tonClick: PropTypes.func,\n\tonFinalText: PropTypes.func,\n\tonRecordingStart: PropTypes.func,\n\tonRecordingStop: PropTypes.func,\n\tonSegment: PropTypes.func,\n\tonSubmit: PropTypes.func,\n\tplaceholder: PropTypes.string,\n\tremote: PropTypes.object,\n\tclassName: PropTypes.string,\n\tstyle: PropTypes.object,\n\ttimeout: PropTypes.number,\n\tstopTooltip: PropTypes.string,\n\tstartTooltip: PropTypes.string,\n\ttooltipPlacement: PropTypes.oneOf([ 'top', 'right', 'bottom', 'left' ]),\n\twidth: PropTypes.number,\n\theight: PropTypes.number\n};\n\n\n// EXPORTS //\n\nexport default VoiceInput;\n"],"sourceRoot":""}
{"version":3,"file":"static/js/KMeans.7425b857.chunk.js","mappings":"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","sources":["../node_modules/ml-distance-euclidean/lib-es6/euclidean.js","../node_modules/ml-nearest-vector/lib-es6/index.js","../node_modules/ml-kmeans/src/utils.js","../node_modules/ml-xsadd/lib-es6/xsadd.js","../node_modules/ml-random/lib-es6/choice.js","../node_modules/ml-random/lib-es6/index.js","../node_modules/ml-kmeans/src/initialization.js","../node_modules/ml-kmeans/src/KMeansResult.js","../node_modules/ml-kmeans/src/kmeans.js","../node_modules/@isle-project/components/models/kmeans/main.js"],"sourcesContent":["export function squaredEuclidean(p, q) {\n  let d = 0;\n\n  for (let i = 0; i < p.length; i++) {\n    d += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n\n  return d;\n}\nexport function euclidean(p, q) {\n  return Math.sqrt(squaredEuclidean(p, q));\n}","'use strict';\n\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nconst defaultOptions = {\n  distanceFunction: squaredEuclidean\n};\nexport default function nearestVector(listVectors, vector, options = defaultOptions) {\n  const distanceFunction = options.distanceFunction || defaultOptions.distanceFunction;\n  const similarityFunction = options.similarityFunction || defaultOptions.similarityFunction;\n  let vectorIndex = -1;\n\n  if (typeof similarityFunction === 'function') {\n    // maximum similarity\n    let maxSim = Number.MIN_VALUE;\n\n    for (let j = 0; j < listVectors.length; j++) {\n      const sim = similarityFunction(vector, listVectors[j]);\n\n      if (sim > maxSim) {\n        maxSim = sim;\n        vectorIndex = j;\n      }\n    }\n  } else if (typeof distanceFunction === 'function') {\n    // minimum distance\n    let minDist = Number.MAX_VALUE;\n\n    for (let i = 0; i < listVectors.length; i++) {\n      const dist = distanceFunction(vector, listVectors[i]);\n\n      if (dist < minDist) {\n        minDist = dist;\n        vectorIndex = i;\n      }\n    }\n  } else {\n    throw new Error(\"A similarity or distance function it's required\");\n  }\n\n  return vectorIndex;\n}\nexport function findNearestVector(vectorList, vector, options = defaultOptions) {\n  const index = nearestVector(vectorList, vector, options);\n  return vectorList[index];\n}","import nearestVector from 'ml-nearest-vector';\n/**\n * Calculates the distance matrix for a given array of points\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {function} distance - Distance function to use between the points\n * @return {Array<Array<number>>} - matrix with the distance values\n */\n\nexport function calculateDistanceMatrix(data, distance) {\n  var distanceMatrix = new Array(data.length);\n\n  for (var i = 0; i < data.length; ++i) {\n    for (var j = i; j < data.length; ++j) {\n      if (!distanceMatrix[i]) {\n        distanceMatrix[i] = new Array(data.length);\n      }\n\n      if (!distanceMatrix[j]) {\n        distanceMatrix[j] = new Array(data.length);\n      }\n\n      const dist = distance(data[i], data[j]);\n      distanceMatrix[i][j] = dist;\n      distanceMatrix[j][i] = dist;\n    }\n  }\n\n  return distanceMatrix;\n}\n/**\n * Updates the cluster identifier based in the new data\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {function} distance - Distance function to use between the points\n * @return {Array} the cluster identifier for each data dot\n */\n\nexport function updateClusterID(data, centers, clusterID, distance) {\n  for (var i = 0; i < data.length; i++) {\n    clusterID[i] = nearestVector(centers, data[i], {\n      distanceFunction: distance\n    });\n  }\n\n  return clusterID;\n}\n/**\n * Update the center values based in the new configurations of the clusters\n * @ignore\n * @param {Array<Array<number>>} prevCenters - Centroids from the previous iteration\n * @param {Array <Array <number>>} data - the [x,y,z,...] points to cluster\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @return {Array} he K centers in format [x,y,z,...]\n */\n\nexport function updateCenters(prevCenters, data, clusterID, K) {\n  const nDim = data[0].length; // copy previous centers\n\n  var centers = new Array(K);\n  var centersLen = new Array(K);\n\n  for (var i = 0; i < K; i++) {\n    centers[i] = new Array(nDim);\n    centersLen[i] = 0;\n\n    for (var j = 0; j < nDim; j++) {\n      centers[i][j] = 0;\n    }\n  } // add the value for all dimensions of the point\n\n\n  for (var l = 0; l < data.length; l++) {\n    centersLen[clusterID[l]]++;\n\n    for (var dim = 0; dim < nDim; dim++) {\n      centers[clusterID[l]][dim] += data[l][dim];\n    }\n  } // divides by length\n\n\n  for (var id = 0; id < K; id++) {\n    for (var d = 0; d < nDim; d++) {\n      if (centersLen[id]) {\n        centers[id][d] /= centersLen[id];\n      } else {\n        centers[id][d] = prevCenters[id][d];\n      }\n    }\n  }\n\n  return centers;\n}\n/**\n * The centers have moved more than the tolerance value?\n * @ignore\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} oldCenters - the K old centers in format [x,y,z,...]\n * @param {function} distanceFunction - Distance function to use between the points\n * @param {number} tolerance - Allowed distance for the centroids to move\n * @return {boolean}\n */\n\nexport function hasConverged(centers, oldCenters, distanceFunction, tolerance) {\n  for (var i = 0; i < centers.length; i++) {\n    if (distanceFunction(centers[i], oldCenters[i]) > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}","const LOOP = 8;\nconst FLOAT_MUL = 1 / 16777216;\nconst sh1 = 15;\nconst sh2 = 18;\nconst sh3 = 11;\n\nfunction multiply_uint32(n, m) {\n  n >>>= 0;\n  m >>>= 0;\n  const nlo = n & 0xffff;\n  const nhi = n - nlo;\n  return (nhi * m >>> 0) + nlo * m >>> 0;\n}\n\nexport default class XSadd {\n  constructor(seed = Date.now()) {\n    this.state = new Uint32Array(4);\n    this.init(seed);\n    this.random = this.getFloat.bind(this);\n  }\n  /**\n   * Returns a 32-bit integer r (0 <= r < 2^32)\n   */\n\n\n  getUint32() {\n    this.nextState();\n    return this.state[3] + this.state[2] >>> 0;\n  }\n  /**\n   * Returns a floating point number r (0.0 <= r < 1.0)\n   */\n\n\n  getFloat() {\n    return (this.getUint32() >>> 8) * FLOAT_MUL;\n  }\n\n  init(seed) {\n    if (!Number.isInteger(seed)) {\n      throw new TypeError('seed must be an integer');\n    }\n\n    this.state[0] = seed;\n    this.state[1] = 0;\n    this.state[2] = 0;\n    this.state[3] = 0;\n\n    for (let i = 1; i < LOOP; i++) {\n      this.state[i & 3] ^= i + multiply_uint32(1812433253, this.state[i - 1 & 3] ^ this.state[i - 1 & 3] >>> 30 >>> 0) >>> 0;\n    }\n\n    this.periodCertification();\n\n    for (let i = 0; i < LOOP; i++) {\n      this.nextState();\n    }\n  }\n\n  periodCertification() {\n    if (this.state[0] === 0 && this.state[1] === 0 && this.state[2] === 0 && this.state[3] === 0) {\n      this.state[0] = 88; // X\n\n      this.state[1] = 83; // S\n\n      this.state[2] = 65; // A\n\n      this.state[3] = 68; // D\n    }\n  }\n\n  nextState() {\n    let t = this.state[0];\n    t ^= t << sh1;\n    t ^= t >>> sh2;\n    t ^= this.state[3] << sh3;\n    this.state[0] = this.state[1];\n    this.state[1] = this.state[2];\n    this.state[2] = this.state[3];\n    this.state[3] = t;\n  }\n\n}","const PROB_TOLERANCE = 0.00000001;\n\nfunction randomChoice(values, options = {}, random = Math.random) {\n  const {\n    size = 1,\n    replace = false,\n    probabilities\n  } = options;\n  let valuesArr;\n  let cumSum;\n\n  if (typeof values === 'number') {\n    valuesArr = getArray(values);\n  } else {\n    valuesArr = values.slice();\n  }\n\n  if (probabilities) {\n    if (!replace) {\n      throw new Error('choice with probabilities and no replacement is not implemented');\n    } // check input is sane\n\n\n    if (probabilities.length !== valuesArr.length) {\n      throw new Error('the length of probabilities option should be equal to the number of choices');\n    }\n\n    cumSum = [probabilities[0]];\n\n    for (let i = 1; i < probabilities.length; i++) {\n      cumSum[i] = cumSum[i - 1] + probabilities[i];\n    }\n\n    if (Math.abs(1 - cumSum[cumSum.length - 1]) > PROB_TOLERANCE) {\n      throw new Error(`probabilities should sum to 1, but instead sums to ${cumSum[cumSum.length - 1]}`);\n    }\n  }\n\n  if (replace === false && size > valuesArr.length) {\n    throw new Error('size option is too large');\n  }\n\n  const result = [];\n\n  for (let i = 0; i < size; i++) {\n    const index = randomIndex(valuesArr.length, random, cumSum);\n    result.push(valuesArr[index]);\n\n    if (!replace) {\n      valuesArr.splice(index, 1);\n    }\n  }\n\n  return result;\n}\n\nfunction getArray(n) {\n  const arr = [];\n\n  for (let i = 0; i < n; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction randomIndex(n, random, cumSum) {\n  const rand = random();\n\n  if (!cumSum) {\n    return Math.floor(rand * n);\n  } else {\n    let idx = 0;\n\n    while (rand > cumSum[idx]) {\n      idx++;\n    }\n\n    return idx;\n  }\n}\n\nexport default randomChoice;","// tslint:disable-next-line\nimport XSAdd from 'ml-xsadd';\nimport choice from './choice';\n/**\n * @classdesc Random class\n */\n\nexport default class Random {\n  /**\n   * @param [seedOrRandom=Math.random] - Control the random number generator used by the Random class instance. Pass a random number generator function with a uniform distribution over the half-open interval [0, 1[. If seed will pass it to ml-xsadd to create a seeded random number generator. If undefined will use Math.random.\n   */\n  constructor(seedOrRandom = Math.random) {\n    if (typeof seedOrRandom === 'number') {\n      const xsadd = new XSAdd(seedOrRandom);\n      this.randomGenerator = xsadd.random;\n    } else {\n      this.randomGenerator = seedOrRandom;\n    }\n  }\n\n  choice(values, options) {\n    if (typeof values === 'number') {\n      return choice(values, options, this.randomGenerator);\n    }\n\n    return choice(values, options, this.randomGenerator);\n  }\n  /**\n   * Draw a random number from a uniform distribution on [0,1)\n   * @return The random number\n   */\n\n\n  random() {\n    return this.randomGenerator();\n  }\n  /**\n   * Draw a random integer from a uniform distribution on [low, high). If only low is specified, the number is drawn on [0, low)\n   * @param low - The lower bound of the uniform distribution interval.\n   * @param high - The higher bound of the uniform distribution interval.\n   */\n\n\n  randInt(low, high) {\n    if (high === undefined) {\n      high = low;\n      low = 0;\n    }\n\n    return low + Math.floor(this.randomGenerator() * (high - low));\n  }\n  /**\n   * Draw several random number from a uniform distribution on [0, 1)\n   * @param size - The number of number to draw\n   * @return - The list of drawn numbers.\n   */\n\n\n  randomSample(size) {\n    const result = [];\n\n    for (let i = 0; i < size; i++) {\n      result.push(this.random());\n    }\n\n    return result;\n  }\n\n}","import Random from 'ml-random';\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nimport { Matrix } from 'ml-matrix';\n/**\n * Choose K different random points from the original data\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\n\nexport function random(data, K, seed) {\n  const random = new Random(seed);\n  return random.choice(data, {\n    size: K\n  });\n}\n/**\n * Chooses the most distant points to a first random pick\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {Array<Array<number>>} distanceMatrix - matrix with the distance values\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\n\nexport function mostDistant(data, K, distanceMatrix, seed) {\n  const random = new Random(seed);\n  var ans = new Array(K); // chooses a random point as initial cluster\n\n  ans[0] = Math.floor(random.random() * data.length);\n\n  if (K > 1) {\n    // chooses the more distant point\n    var maxDist = {\n      dist: -1,\n      index: -1\n    };\n\n    for (var l = 0; l < data.length; ++l) {\n      if (distanceMatrix[ans[0]][l] > maxDist.dist) {\n        maxDist.dist = distanceMatrix[ans[0]][l];\n        maxDist.index = l;\n      }\n    }\n\n    ans[1] = maxDist.index;\n\n    if (K > 2) {\n      // chooses the set of points that maximises the min distance\n      for (var k = 2; k < K; ++k) {\n        var center = {\n          dist: -1,\n          index: -1\n        };\n\n        for (var m = 0; m < data.length; ++m) {\n          // minimum distance to centers\n          var minDistCent = {\n            dist: Number.MAX_VALUE,\n            index: -1\n          };\n\n          for (var n = 0; n < k; ++n) {\n            if (distanceMatrix[n][m] < minDistCent.dist && ans.indexOf(m) === -1) {\n              minDistCent = {\n                dist: distanceMatrix[n][m],\n                index: m\n              };\n            }\n          }\n\n          if (minDistCent.dist !== Number.MAX_VALUE && minDistCent.dist > center.dist) {\n            center = Object.assign({}, minDistCent);\n          }\n        }\n\n        ans[k] = center.index;\n      }\n    }\n  }\n\n  return ans.map(index => data[index]);\n} // Implementation inspired from scikit\n\nexport function kmeanspp(X, K, options = {}) {\n  X = new Matrix(X);\n  const nSamples = X.rows;\n  const random = new Random(options.seed); // Set the number of trials\n\n  const centers = [];\n  const localTrials = options.localTrials || 2 + Math.floor(Math.log(K)); // Pick the first center at random from the dataset\n\n  const firstCenterIdx = random.randInt(nSamples);\n  centers.push(X.getRow(firstCenterIdx)); // Init closest distances\n\n  let closestDistSquared = new Matrix(1, X.rows);\n\n  for (let i = 0; i < X.rows; i++) {\n    closestDistSquared.set(0, i, squaredEuclidean(X.getRow(i), centers[0]));\n  }\n\n  let cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n  const factor = 1 / cumSumClosestDistSquared[0][nSamples - 1];\n  let probabilities = Matrix.mul(closestDistSquared, factor); // Iterate over the remaining centers\n\n  for (let i = 1; i < K; i++) {\n    const candidateIdx = random.choice(nSamples, {\n      replace: true,\n      size: localTrials,\n      probabilities: probabilities[0]\n    });\n    const candidates = X.selection(candidateIdx, range(X.columns));\n    const distanceToCandidates = euclideanDistances(candidates, X);\n    let bestCandidate;\n    let bestPot;\n    let bestDistSquared;\n\n    for (let j = 0; j < localTrials; j++) {\n      const newDistSquared = Matrix.min(closestDistSquared, [distanceToCandidates.getRow(j)]);\n      const newPot = newDistSquared.sum();\n\n      if (bestCandidate === undefined || newPot < bestPot) {\n        bestCandidate = candidateIdx[j];\n        bestPot = newPot;\n        bestDistSquared = newDistSquared;\n      }\n    }\n\n    centers[i] = X.getRow(bestCandidate);\n    closestDistSquared = bestDistSquared;\n    cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n    probabilities = Matrix.mul(closestDistSquared, 1 / cumSumClosestDistSquared[0][nSamples - 1]);\n  }\n\n  return centers;\n}\n\nfunction euclideanDistances(A, B) {\n  const result = new Matrix(A.rows, B.rows);\n\n  for (let i = 0; i < A.rows; i++) {\n    for (let j = 0; j < B.rows; j++) {\n      result.set(i, j, squaredEuclidean(A.getRow(i), B.getRow(j)));\n    }\n  }\n\n  return result;\n}\n\nfunction range(l) {\n  let r = [];\n\n  for (let i = 0; i < l; i++) {\n    r.push(i);\n  }\n\n  return r;\n}\n\nfunction cumSum(arr) {\n  let cumSum = [arr[0]];\n\n  for (let i = 1; i < arr.length; i++) {\n    cumSum[i] = cumSum[i - 1] + arr[i];\n  }\n\n  return cumSum;\n}","import { updateClusterID } from './utils';\nconst distanceSymbol = Symbol('distance');\nexport default class KMeansResult {\n  /**\n   * Result of the kmeans algorithm\n   * @param {Array<number>} clusters - the cluster identifier for each data dot\n   * @param {Array<Array<object>>} centroids - the K centers in format [x,y,z,...], the error and size of the cluster\n   * @param {boolean} converged - Converge criteria satisfied\n   * @param {number} iterations - Current number of iterations\n   * @param {function} distance - (*Private*) Distance function to use between the points\n   * @constructor\n   */\n  constructor(clusters, centroids, converged, iterations, distance) {\n    this.clusters = clusters;\n    this.centroids = centroids;\n    this.converged = converged;\n    this.iterations = iterations;\n    this[distanceSymbol] = distance;\n  }\n  /**\n   * Allows to compute for a new array of points their cluster id\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {Array<number>} - cluster id for each point\n   */\n\n\n  nearest(data) {\n    const clusterID = new Array(data.length);\n    const centroids = this.centroids.map(function (centroid) {\n      return centroid.centroid;\n    });\n    return updateClusterID(data, centroids, clusterID, this[distanceSymbol]);\n  }\n  /**\n   * Returns a KMeansResult with the error and size of the cluster\n   * @ignore\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {KMeansResult}\n   */\n\n\n  computeInformation(data) {\n    var enrichedCentroids = this.centroids.map(function (centroid) {\n      return {\n        centroid: centroid,\n        error: 0,\n        size: 0\n      };\n    });\n\n    for (var i = 0; i < data.length; i++) {\n      enrichedCentroids[this.clusters[i]].error += this[distanceSymbol](data[i], this.centroids[this.clusters[i]]);\n      enrichedCentroids[this.clusters[i]].size++;\n    }\n\n    for (var j = 0; j < this.centroids.length; j++) {\n      if (enrichedCentroids[j].size) {\n        enrichedCentroids[j].error /= enrichedCentroids[j].size;\n      } else {\n        enrichedCentroids[j].error = null;\n      }\n    }\n\n    return new KMeansResult(this.clusters, enrichedCentroids, this.converged, this.iterations, this[distanceSymbol]);\n  }\n\n}","import { squaredEuclidean } from 'ml-distance-euclidean';\nimport { updateClusterID, updateCenters, hasConverged, calculateDistanceMatrix } from './utils';\nimport { mostDistant, random, kmeanspp } from './initialization';\nimport KMeansResult from './KMeansResult';\nconst defaultOptions = {\n  maxIterations: 100,\n  tolerance: 1e-6,\n  withIterations: false,\n  initialization: 'kmeans++',\n  distanceFunction: squaredEuclidean\n};\n/**\n * Each step operation for kmeans\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} iterations - Current number of iterations\n * @return {KMeansResult}\n */\n\nfunction step(centers, data, clusterID, K, options, iterations) {\n  clusterID = updateClusterID(data, centers, clusterID, options.distanceFunction);\n  var newCenters = updateCenters(centers, data, clusterID, K);\n  var converged = hasConverged(newCenters, centers, options.distanceFunction, options.tolerance);\n  return new KMeansResult(clusterID, newCenters, converged, iterations, options.distanceFunction);\n}\n/**\n * Generator version for the algorithm\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n */\n\n\nfunction* kmeansGenerator(centers, data, clusterID, K, options) {\n  var converged = false;\n  var stepNumber = 0;\n  var stepResult;\n\n  while (!converged && stepNumber < options.maxIterations) {\n    stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n    yield stepResult.computeInformation(data);\n    converged = stepResult.converged;\n    centers = stepResult.centroids;\n  }\n}\n/**\n * K-means algorithm\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} [options.maxIterations = 100] - Maximum of iterations allowed\n * @param {number} [options.tolerance = 1e-6] - Error tolerance\n * @param {boolean} [options.withIterations = false] - Store clusters and centroids for each iteration\n * @param {function} [options.distanceFunction = squaredDistance] - Distance function to use between the points\n * @param {number} [options.seed] - Seed for random initialization.\n * @param {string|Array<Array<number>>} [options.initialization = 'kmeans++'] - K centers in format [x,y,z,...] or a method for initialize the data:\n *  * You can either specify your custom start centroids, or select one of the following initialization method:\n *  * `'kmeans++'` will use the kmeans++ method as described by http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf\n *  * `'random'` will choose K random different values.\n *  * `'mostDistant'` will choose the more distant points to a first random pick\n * @return {KMeansResult} - Cluster identifier for each data dot and centroids with the following fields:\n *  * `'clusters'`: Array of indexes for the clusters.\n *  * `'centroids'`: Array with the resulting centroids.\n *  * `'iterations'`: Number of iterations that took to converge\n */\n\n\nexport default function kmeans(data, K, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  if (K <= 0 || K > data.length || !Number.isInteger(K)) {\n    throw new Error('K should be a positive integer smaller than the number of points');\n  }\n\n  var centers;\n\n  if (Array.isArray(options.initialization)) {\n    if (options.initialization.length !== K) {\n      throw new Error('The initial centers should have the same length as K');\n    } else {\n      centers = options.initialization;\n    }\n  } else {\n    switch (options.initialization) {\n      case 'kmeans++':\n        centers = kmeanspp(data, K, options);\n        break;\n\n      case 'random':\n        centers = random(data, K, options.seed);\n        break;\n\n      case 'mostDistant':\n        centers = mostDistant(data, K, calculateDistanceMatrix(data, options.distanceFunction), options.seed);\n        break;\n\n      default:\n        throw new Error(`Unknown initialization method: \"${options.initialization}\"`);\n    }\n  } // infinite loop until convergence\n\n\n  if (options.maxIterations === 0) {\n    options.maxIterations = Number.MAX_VALUE;\n  }\n\n  var clusterID = new Array(data.length);\n\n  if (options.withIterations) {\n    return kmeansGenerator(centers, data, clusterID, K, options);\n  } else {\n    var converged = false;\n    var stepNumber = 0;\n    var stepResult;\n\n    while (!converged && stepNumber < options.maxIterations) {\n      stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n      converged = stepResult.converged;\n      centers = stepResult.centroids;\n    }\n\n    return stepResult.computeInformation(data);\n  }\n}","// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport kmeans from 'ml-kmeans';\nimport Alert from 'react-bootstrap/Alert';\nimport hasOwnProp from '@stdlib/assert/has-own-property';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport isnan from '@stdlib/assert/is-nan';\nimport Table from '@isle-project/components/table';\nimport { withPropCheck } from '@isle-project/utils/prop-check';\n\n\n// FUNCTIONS //\n\nfunction isNonMissingNumber( x ) {\n\treturn isNumber( x ) && !isnan( x );\n}\n\nconst summaryTable = ( variables, centroids, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('cluster')}</th>\n\t\t\t\t\t{centroids.map( ( _, i ) => <th key={i} >{i+1}</th>)}\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{variables.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t{centroids.map( ( x, i ) => <td key={i} >{x.centroid[ idx ].toFixed( 4 )}</td>)}\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('size')}</th>\n\t\t\t\t\t{centroids.map( ( x, i ) => <th key={i} >{x.size}</th>)}\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nconst fitModel = ({ K, variables, data, initialization }) => {\n\tif ( !data || !variables || !K || !initialization ) {\n\t\treturn null;\n\t}\n\tconst matrix = [];\n\tif ( !hasOwnProp( data, variables[ 0 ] ) ) {\n\t\treturn null;\n\t}\n\tconst n = data[ variables[ 0 ] ].length;\n\tconst missingIds = [];\n\tfor ( let i = 0; i < n; i++ ) {\n\t\tconst row = [];\n\t\tlet missing = false;\n\t\tfor ( let j = 0; j < variables.length; j++ ) {\n\t\t\tif ( !hasOwnProp( data, variables[ j ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst val = data[ variables[ j ] ][ i ];\n\t\t\tif ( isNonMissingNumber( val ) ) {\n\t\t\t\trow.push( val );\n\t\t\t} else {\n\t\t\t\tmissing = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( !missing ) {\n\t\t\tmatrix.push( row );\n\t\t} else {\n\t\t\tmissingIds.push( i );\n\t\t}\n\t}\n\ttry {\n\t\tconst result = kmeans( matrix, K, {\n\t\t\tinitialization\n\t\t});\n\t\tfor ( let i = 0; i < missingIds.length; i++ ) {\n\t\t\tresult.clusters.splice( missingIds[ i ], 0, null );\n\t\t}\n\t\tresult.clusters = result.clusters.map( x => {\n\t\t\tif ( x === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn `Cluster ${x+1}`; // eslint-disable-line i18next/no-literal-string\n\t\t});\n\t\treturn result;\n\t} catch ( _ ) {\n\t\treturn null;\n\t}\n};\n\n\n// MAIN //\n\n/**\n* K-means clustering.\n*\n* @property {Object} data - object of value arrays\n* @property {Array<string>} variables - names of variables used for clustering\n* @property {string} initialization - initialization method (`kmeans++`, `random`, or `mostDistant`)\n* @property {number} K - number of clusters\n* @property {Function} onResult - callback invoked with model object\n*/\nclass KMeans extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\t\tconst { K, variables, data, initialization } = props;\n\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\tthis.state = {\n\t\t\tresult,\n\t\t\t...props\n\t\t};\n\t\tif ( result ) {\n\t\t\tprops.onResult( result );\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.variables !== prevState.variables ||\n\t\t\tnextProps.K !== prevState.K ||\n\t\t\tnextProps.initialization !== prevState.initialization\n\t\t) {\n\t\t\tconst { K, variables, data, initialization } = nextProps;\n\t\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\t\tnextProps.onResult( result );\n\t\t\tconst newState = {\n\t\t\t\tresult,\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t\treturn newState;\n\t\t}\n\t\treturn null;\n\t}\n\n\trender() {\n\t\tconst { result } = this.state;\n\t\tconst { t, variables } = this.props;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('kmeans-summary')}</span>\n\t\t\t\t<p>{result.converged ? t('algorithm-converged', { n: result.iterations }) : t('algorithm-not-converged', { n: result.iterations })}</p>\n\t\t\t\t{summaryTable( variables, result.centroids, t )}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nKMeans.defaultProps = {\n\tK: 3,\n\tinitialization: 'kmeans++',\n\tonResult() {}\n};\n\nKMeans.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\tvariables: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tK: PropTypes.number,\n\tinitialization: PropTypes.oneOf([ 'kmeans++', 'random', 'mostDistant' ]),\n\tonResult: PropTypes.func\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'models' )( withPropCheck( KMeans ) );\n"],"names":["squaredEuclidean","p","q","d","i","length","defaultOptions","distanceFunction","nearestVector","listVectors","vector","options","similarityFunction","vectorIndex","maxSim","Number","MIN_VALUE","j","sim","Error","minDist","MAX_VALUE","dist","updateClusterID","data","centers","clusterID","distance","multiply_uint32","n","m","nlo","XSadd","constructor","seed","Date","now","this","state","Uint32Array","init","random","getFloat","bind","getUint32","nextState","isInteger","TypeError","periodCertification","t","randomIndex","cumSum","rand","idx","Math","floor","values","size","replace","probabilities","valuesArr","arr","push","getArray","slice","abs","result","index","splice","Random","seedOrRandom","xsadd","randomGenerator","choice","randInt","low","high","undefined","randomSample","euclideanDistances","A","B","rows","set","getRow","range","l","r","distanceSymbol","Symbol","KMeansResult","clusters","centroids","converged","iterations","nearest","Array","map","centroid","computeInformation","enrichedCentroids","error","maxIterations","tolerance","withIterations","initialization","step","K","newCenters","prevCenters","nDim","centersLen","dim","id","updateCenters","oldCenters","hasConverged","kmeans","Object","assign","isArray","X","nSamples","localTrials","log","firstCenterIdx","closestDistSquared","cumSumClosestDistSquared","factor","candidateIdx","distanceToCandidates","selection","columns","bestCandidate","bestPot","bestDistSquared","newDistSquared","newPot","sum","kmeanspp","distanceMatrix","ans","maxDist","k","center","minDistCent","indexOf","mostDistant","calculateDistanceMatrix","stepResult","stepNumber","kmeansGenerator","fitModel","variables","matrix","hasOwnProp","missingIds","row","missing","val","x","isNumber","isnan","_","KMeans","Component","props","super","onResult","nextProps","prevState","render","style","overflowX","width","className","bordered","key","name","toFixed","summaryTable","Alert","variant","defaultProps","propTypes","PropTypes","isRequired","withTranslation","withPropCheck"],"sourceRoot":""}
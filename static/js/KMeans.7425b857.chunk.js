"use strict";(self.webpackChunkisle_dashboard=self.webpackChunkisle_dashboard||[]).push([[4093],{19930:function(t,e,n){n.r(e),n.d(e,{default:function(){return C}});var r=n(38603),i=n(91532),s=n.n(i),o=n(58651);function a(t,e){let n=0;for(let r=0;r<t.length;r++)n+=(t[r]-e[r])*(t[r]-e[r]);return n}const l={distanceFunction:a};function c(t,e,n=l){const r=n.distanceFunction||l.distanceFunction,i=n.similarityFunction||l.similarityFunction;let s=-1;if("function"===typeof i){let n=Number.MIN_VALUE;for(let r=0;r<t.length;r++){const o=i(e,t[r]);o>n&&(n=o,s=r)}}else{if("function"!==typeof r)throw new Error("A similarity or distance function it's required");{let n=Number.MAX_VALUE;for(let i=0;i<t.length;i++){const o=r(e,t[i]);o<n&&(n=o,s=i)}}}return s}function u(t,e,n,r){for(var i=0;i<t.length;i++)n[i]=c(e,t[i],{distanceFunction:r});return n}function h(t,e){const n=65535&(t>>>=0);return((t-n)*(e>>>=0)>>>0)+n*e>>>0}class d{constructor(t=Date.now()){this.state=new Uint32Array(4),this.init(t),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return 5.960464477539063e-8*(this.getUint32()>>>8)}init(t){if(!Number.isInteger(t))throw new TypeError("seed must be an integer");this.state[0]=t,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let e=1;e<8;e++)this.state[3&e]^=e+h(1812433253,this.state[e-1&3]^this.state[e-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let e=0;e<8;e++)this.nextState()}periodCertification(){0===this.state[0]&&0===this.state[1]&&0===this.state[2]&&0===this.state[3]&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let t=this.state[0];t^=t<<15,t^=t>>>18,t^=this.state[3]<<11,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=t}}function f(t,e,n){const r=e();if(n){let t=0;for(;r>n[t];)t++;return t}return Math.floor(r*t)}var m=function(t,e={},n=Math.random){const{size:r=1,replace:i=!1,probabilities:s}=e;let o,a;if(o="number"===typeof t?function(t){const e=[];for(let n=0;n<t;n++)e.push(n);return e}(t):t.slice(),s){if(!i)throw new Error("choice with probabilities and no replacement is not implemented");if(s.length!==o.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[s[0]];for(let t=1;t<s.length;t++)a[t]=a[t-1]+s[t];if(Math.abs(1-a[a.length-1])>1e-8)throw new Error(`probabilities should sum to 1, but instead sums to ${a[a.length-1]}`)}if(!1===i&&r>o.length)throw new Error("size option is too large");const l=[];for(let c=0;c<r;c++){const t=f(o.length,n,a);l.push(o[t]),i||o.splice(t,1)}return l};class g{constructor(t=Math.random){if("number"===typeof t){const e=new d(t);this.randomGenerator=e.random}else this.randomGenerator=t}choice(t,e){return m(t,e,this.randomGenerator)}random(){return this.randomGenerator()}randInt(t,e){return void 0===e&&(e=t,t=0),t+Math.floor(this.randomGenerator()*(e-t))}randomSample(t){const e=[];for(let n=0;n<t;n++)e.push(this.random());return e}}var w=n(11695);function p(t,e){const n=new w.Z(t.rows,e.rows);for(let r=0;r<t.rows;r++)for(let i=0;i<e.rows;i++)n.set(r,i,a(t.getRow(r),e.getRow(i)));return n}function b(t){let e=[];for(let n=0;n<t;n++)e.push(n);return e}function v(t){let e=[t[0]];for(let n=1;n<t.length;n++)e[n]=e[n-1]+t[n];return e}const y=Symbol("distance");class E{constructor(t,e,n,r,i){this.clusters=t,this.centroids=e,this.converged=n,this.iterations=r,this[y]=i}nearest(t){const e=new Array(t.length);return u(t,this.centroids.map((function(t){return t.centroid})),e,this[y])}computeInformation(t){for(var e=this.centroids.map((function(t){return{centroid:t,error:0,size:0}})),n=0;n<t.length;n++)e[this.clusters[n]].error+=this[y](t[n],this.centroids[this.clusters[n]]),e[this.clusters[n]].size++;for(var r=0;r<this.centroids.length;r++)e[r].size?e[r].error/=e[r].size:e[r].error=null;return new E(this.clusters,e,this.converged,this.iterations,this[y])}}const z={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:a};function A(t,e,n,r,i,s){var o=function(t,e,n,r){const i=e[0].length;for(var s=new Array(r),o=new Array(r),a=0;a<r;a++){s[a]=new Array(i),o[a]=0;for(var l=0;l<i;l++)s[a][l]=0}for(var c=0;c<e.length;c++){o[n[c]]++;for(var u=0;u<i;u++)s[n[c]][u]+=e[c][u]}for(var h=0;h<r;h++)for(var d=0;d<i;d++)o[h]?s[h][d]/=o[h]:s[h][d]=t[h][d];return s}(t,e,n=u(e,t,n,i.distanceFunction),r),a=function(t,e,n,r){for(var i=0;i<t.length;i++)if(n(t[i],e[i])>r)return!1;return!0}(o,t,i.distanceFunction,i.tolerance);return new E(n,o,a,s,i.distanceFunction)}function k(t,e,n){if(n=Object.assign({},z,n),e<=0||e>t.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var r;if(Array.isArray(n.initialization)){if(n.initialization.length!==e)throw new Error("The initial centers should have the same length as K");r=n.initialization}else switch(n.initialization){case"kmeans++":r=function(t,e,n={}){const r=(t=new w.Z(t)).rows,i=new g(n.seed),s=[],o=n.localTrials||2+Math.floor(Math.log(e)),l=i.randInt(r);s.push(t.getRow(l));let c=new w.Z(1,t.rows);for(let f=0;f<t.rows;f++)c.set(0,f,a(t.getRow(f),s[0]));let u=[v(c.getRow(0))];const h=1/u[0][r-1];let d=w.Z.mul(c,h);for(let a=1;a<e;a++){const e=i.choice(r,{replace:!0,size:o,probabilities:d[0]}),n=p(t.selection(e,b(t.columns)),t);let l,h,f;for(let t=0;t<o;t++){const r=w.Z.min(c,[n.getRow(t)]),i=r.sum();(void 0===l||i<h)&&(l=e[t],h=i,f=r)}s[a]=t.getRow(l),c=f,u=[v(c.getRow(0))],d=w.Z.mul(c,1/u[0][r-1])}return s}(t,e,n);break;case"random":r=function(t,e,n){return new g(n).choice(t,{size:e})}(t,e,n.seed);break;case"mostDistant":r=function(t,e,n,r){const i=new g(r);var s=new Array(e);if(s[0]=Math.floor(i.random()*t.length),e>1){for(var o={dist:-1,index:-1},a=0;a<t.length;++a)n[s[0]][a]>o.dist&&(o.dist=n[s[0]][a],o.index=a);if(s[1]=o.index,e>2)for(var l=2;l<e;++l){for(var c={dist:-1,index:-1},u=0;u<t.length;++u){for(var h={dist:Number.MAX_VALUE,index:-1},d=0;d<l;++d)n[d][u]<h.dist&&-1===s.indexOf(u)&&(h={dist:n[d][u],index:u});h.dist!==Number.MAX_VALUE&&h.dist>c.dist&&(c=Object.assign({},h))}s[l]=c.index}}return s.map((e=>t[e]))}(t,e,function(t,e){for(var n=new Array(t.length),r=0;r<t.length;++r)for(var i=r;i<t.length;++i){n[r]||(n[r]=new Array(t.length)),n[i]||(n[i]=new Array(t.length));const s=e(t[r],t[i]);n[r][i]=s,n[i][r]=s}return n}(t,n.distanceFunction),n.seed);break;default:throw new Error(`Unknown initialization method: "${n.initialization}"`)}0===n.maxIterations&&(n.maxIterations=Number.MAX_VALUE);var i=new Array(t.length);if(n.withIterations)return function*(t,e,n,r,i){for(var s,o=!1,a=0;!o&&a<i.maxIterations;)s=A(t,e,n,r,i,++a),yield s.computeInformation(e),o=s.converged,t=s.centroids}(r,t,i,e,n);for(var s,o=!1,l=0;!o&&l<n.maxIterations;)o=(s=A(r,t,i,e,n,++l)).converged,r=s.centroids;return s.computeInformation(t)}var x=n(79174),F=n(74802),I=n.n(F),R=n(42415),M=n(34064),K=n.n(M),N=n(5883),U=n(76798);const Z=({K:t,variables:e,data:n,initialization:r})=>{if(!n||!e||!t||!r)return null;const i=[];if(!I()(n,e[0]))return null;const s=n[e[0]].length,o=[];for(let c=0;c<s;c++){const t=[];let r=!1;for(let i=0;i<e.length;i++){if(!I()(n,e[i]))return null;const s=n[e[i]][c];if(a=s,!(0,R.isPrimitive)(a)||K()(a)){r=!0;break}t.push(s)}r?o.push(c):i.push(t)}var a;try{const e=k(i,t,{initialization:r});for(let t=0;t<o.length;t++)e.clusters.splice(o[t],0,null);return e.clusters=e.clusters.map((t=>null===t?null:`Cluster ${t+1}`)),e}catch(l){return null}};class _ extends r.Component{constructor(t){super(t);const{K:e,variables:n,data:r,initialization:i}=t,s=Z({K:e,variables:n,data:r,initialization:i});this.state={result:s,...t},s&&t.onResult(s)}static getDerivedStateFromProps(t,e){if(t.data!==e.data||t.variables!==e.variables||t.K!==e.K||t.initialization!==e.initialization){const{K:e,variables:n,data:r,initialization:i}=t,s=Z({K:e,variables:n,data:r,initialization:i});t.onResult(s);return{result:s,...t}}return null}render(){const{result:t}=this.state,{t:e,variables:n}=this.props;return t?r.createElement("div",{style:{overflowX:"auto",width:"100%"}},r.createElement("span",{className:"title"},e("kmeans-summary")),r.createElement("p",null,t.converged?e("algorithm-converged",{n:t.iterations}):e("algorithm-not-converged",{n:t.iterations})),((t,e,n)=>r.createElement(N.Z,{bordered:!0,size:"sm"},r.createElement("thead",null,r.createElement("tr",null,r.createElement("th",null,n("cluster")),e.map(((t,e)=>r.createElement("th",{key:e},e+1))))),r.createElement("tbody",null,t.map(((t,n)=>r.createElement("tr",{key:n},r.createElement("th",null,t),e.map(((t,e)=>r.createElement("td",{key:e},t.centroid[n].toFixed(4)))))))),r.createElement("tbody",null,r.createElement("tr",null,r.createElement("th",null,n("size")),e.map(((t,e)=>r.createElement("th",{key:e},t.size)))))))(n,t.centroids,e)):r.createElement(x.Z,{variant:"danger"},e("missing-attributes"))}}_.defaultProps={K:3,initialization:"kmeans++",onResult(){}},_.propTypes={data:s().object.isRequired,variables:s().arrayOf(s().string).isRequired,K:s().number,initialization:s().oneOf(["kmeans++","random","mostDistant"]),onResult:s().func};var C=(0,o.Z)("models")((0,U.W)(_))}}]);
//# sourceMappingURL=KMeans.7425b857.chunk.js.map
"use strict";(self.webpackChunkisle_dashboard=self.webpackChunkisle_dashboard||[]).push([[8406],{62932:function(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.isAnyArray=void 0;const toString=Object.prototype.toString;function isAnyArray(value){return toString.call(value).endsWith("Array]")}exports.isAnyArray=isAnyArray},41112:function(module,__unused_webpack_exports,__webpack_require__){var isAnyArray=__webpack_require__(62932);function max(input,options={}){if(!isAnyArray.isAnyArray(input))throw new TypeError("input must be an array");if(input.length===0)throw new TypeError("input must not be empty");const{fromIndex=0,toIndex=input.length}=options;if(fromIndex<0||fromIndex>=input.length||!Number.isInteger(fromIndex))throw new Error("fromIndex must be a positive integer smaller than length");if(toIndex<=fromIndex||toIndex>input.length||!Number.isInteger(toIndex))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");let maxValue=input[fromIndex];for(let i=fromIndex+1;i<toIndex;i++)input[i]>maxValue&&(maxValue=input[i]);return maxValue}module.exports=max},3272:function(module,__unused_webpack_exports,__webpack_require__){var isAnyArray=__webpack_require__(62932);function min(input,options={}){if(!isAnyArray.isAnyArray(input))throw new TypeError("input must be an array");if(input.length===0)throw new TypeError("input must not be empty");const{fromIndex=0,toIndex=input.length}=options;if(fromIndex<0||fromIndex>=input.length||!Number.isInteger(fromIndex))throw new Error("fromIndex must be a positive integer smaller than length");if(toIndex<=fromIndex||toIndex>input.length||!Number.isInteger(toIndex))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");let minValue=input[fromIndex];for(let i=fromIndex+1;i<toIndex;i++)input[i]<minValue&&(minValue=input[i]);return minValue}module.exports=min},74159:function(module,__unused_webpack_exports,__webpack_require__){var isAnyArray=__webpack_require__(62932),max=__webpack_require__(41112),min=__webpack_require__(3272);function _interopDefaultLegacy(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var max__default=_interopDefaultLegacy(max),min__default=_interopDefaultLegacy(min);function rescale(input,options={}){if(isAnyArray.isAnyArray(input)){if(input.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");let output;if(options.output!==void 0){if(!isAnyArray.isAnyArray(options.output))throw new TypeError("output option must be an array if specified");output=options.output}else output=new Array(input.length);const currentMin=min__default.default(input),currentMax=max__default.default(input);if(currentMin===currentMax)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");const{min:minValue=options.autoMinMax?currentMin:0,max:maxValue=options.autoMinMax?currentMax:1}=options;if(minValue>=maxValue)throw new RangeError("min option must be smaller than max option");const factor=(maxValue-minValue)/(currentMax-currentMin);for(let i=0;i<input.length;i++)output[i]=(input[i]-currentMin)*factor+minValue;return output}module.exports=rescale},78406:function(__unused_webpack_module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:!0});var rescale=__webpack_require__(74159);function _interopDefaultLegacy(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var rescale__default=_interopDefaultLegacy(rescale);const indent=" ".repeat(2),indentData=" ".repeat(4);function inspectMatrix(){return inspectMatrixWithOptions(this)}function inspectMatrixWithOptions(matrix,options={}){const{maxRows=15,maxColumns=10,maxNumSize=8}=options;return`${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix,maxRows,maxColumns,maxNumSize)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`}function inspectData(matrix,maxRows,maxColumns,maxNumSize){const{rows,columns}=matrix,maxI=Math.min(rows,maxRows),maxJ=Math.min(columns,maxColumns),result=[];for(let i=0;i<maxI;i++){let line=[];for(let j=0;j<maxJ;j++)line.push(formatNumber(matrix.get(i,j),maxNumSize));result.push(`${line.join(" ")}`)}return maxJ!==columns&&(result[result.length-1]+=` ... ${columns-maxColumns} more columns`),maxI!==rows&&result.push(`... ${rows-maxRows} more rows`),result.join(`
${indentData}`)}function formatNumber(num,maxNumSize){const numStr=String(num);if(numStr.length<=maxNumSize)return numStr.padEnd(maxNumSize," ");const precise=num.toPrecision(maxNumSize-2);if(precise.length<=maxNumSize)return precise;const exponential=num.toExponential(maxNumSize-2),eIndex=exponential.indexOf("e"),e=exponential.slice(eIndex);return exponential.slice(0,maxNumSize-e.length)+e}function installMathOperations(AbstractMatrix2,Matrix2){AbstractMatrix2.prototype.add=function(value){return typeof value=="number"?this.addS(value):this.addM(value)},AbstractMatrix2.prototype.addS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+value);return this},AbstractMatrix2.prototype.addM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+matrix.get(i,j));return this},AbstractMatrix2.add=function(matrix,value){return new Matrix2(matrix).add(value)},AbstractMatrix2.prototype.sub=function(value){return typeof value=="number"?this.subS(value):this.subM(value)},AbstractMatrix2.prototype.subS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-value);return this},AbstractMatrix2.prototype.subM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-matrix.get(i,j));return this},AbstractMatrix2.sub=function(matrix,value){return new Matrix2(matrix).sub(value)},AbstractMatrix2.prototype.subtract=AbstractMatrix2.prototype.sub,AbstractMatrix2.prototype.subtractS=AbstractMatrix2.prototype.subS,AbstractMatrix2.prototype.subtractM=AbstractMatrix2.prototype.subM,AbstractMatrix2.subtract=AbstractMatrix2.sub,AbstractMatrix2.prototype.mul=function(value){return typeof value=="number"?this.mulS(value):this.mulM(value)},AbstractMatrix2.prototype.mulS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*value);return this},AbstractMatrix2.prototype.mulM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*matrix.get(i,j));return this},AbstractMatrix2.mul=function(matrix,value){return new Matrix2(matrix).mul(value)},AbstractMatrix2.prototype.multiply=AbstractMatrix2.prototype.mul,AbstractMatrix2.prototype.multiplyS=AbstractMatrix2.prototype.mulS,AbstractMatrix2.prototype.multiplyM=AbstractMatrix2.prototype.mulM,AbstractMatrix2.multiply=AbstractMatrix2.mul,AbstractMatrix2.prototype.div=function(value){return typeof value=="number"?this.divS(value):this.divM(value)},AbstractMatrix2.prototype.divS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/value);return this},AbstractMatrix2.prototype.divM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/matrix.get(i,j));return this},AbstractMatrix2.div=function(matrix,value){return new Matrix2(matrix).div(value)},AbstractMatrix2.prototype.divide=AbstractMatrix2.prototype.div,AbstractMatrix2.prototype.divideS=AbstractMatrix2.prototype.divS,AbstractMatrix2.prototype.divideM=AbstractMatrix2.prototype.divM,AbstractMatrix2.divide=AbstractMatrix2.div,AbstractMatrix2.prototype.mod=function(value){return typeof value=="number"?this.modS(value):this.modM(value)},AbstractMatrix2.prototype.modS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)%value);return this},AbstractMatrix2.prototype.modM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)%matrix.get(i,j));return this},AbstractMatrix2.mod=function(matrix,value){return new Matrix2(matrix).mod(value)},AbstractMatrix2.prototype.modulus=AbstractMatrix2.prototype.mod,AbstractMatrix2.prototype.modulusS=AbstractMatrix2.prototype.modS,AbstractMatrix2.prototype.modulusM=AbstractMatrix2.prototype.modM,AbstractMatrix2.modulus=AbstractMatrix2.mod,AbstractMatrix2.prototype.and=function(value){return typeof value=="number"?this.andS(value):this.andM(value)},AbstractMatrix2.prototype.andS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)&value);return this},AbstractMatrix2.prototype.andM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)&matrix.get(i,j));return this},AbstractMatrix2.and=function(matrix,value){return new Matrix2(matrix).and(value)},AbstractMatrix2.prototype.or=function(value){return typeof value=="number"?this.orS(value):this.orM(value)},AbstractMatrix2.prototype.orS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)|value);return this},AbstractMatrix2.prototype.orM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)|matrix.get(i,j));return this},AbstractMatrix2.or=function(matrix,value){return new Matrix2(matrix).or(value)},AbstractMatrix2.prototype.xor=function(value){return typeof value=="number"?this.xorS(value):this.xorM(value)},AbstractMatrix2.prototype.xorS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)^value);return this},AbstractMatrix2.prototype.xorM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)^matrix.get(i,j));return this},AbstractMatrix2.xor=function(matrix,value){return new Matrix2(matrix).xor(value)},AbstractMatrix2.prototype.leftShift=function(value){return typeof value=="number"?this.leftShiftS(value):this.leftShiftM(value)},AbstractMatrix2.prototype.leftShiftS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)<<value);return this},AbstractMatrix2.prototype.leftShiftM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)<<matrix.get(i,j));return this},AbstractMatrix2.leftShift=function(matrix,value){return new Matrix2(matrix).leftShift(value)},AbstractMatrix2.prototype.signPropagatingRightShift=function(value){return typeof value=="number"?this.signPropagatingRightShiftS(value):this.signPropagatingRightShiftM(value)},AbstractMatrix2.prototype.signPropagatingRightShiftS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>value);return this},AbstractMatrix2.prototype.signPropagatingRightShiftM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>matrix.get(i,j));return this},AbstractMatrix2.signPropagatingRightShift=function(matrix,value){return new Matrix2(matrix).signPropagatingRightShift(value)},AbstractMatrix2.prototype.rightShift=function(value){return typeof value=="number"?this.rightShiftS(value):this.rightShiftM(value)},AbstractMatrix2.prototype.rightShiftS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>>value);return this},AbstractMatrix2.prototype.rightShiftM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>>matrix.get(i,j));return this},AbstractMatrix2.rightShift=function(matrix,value){return new Matrix2(matrix).rightShift(value)},AbstractMatrix2.prototype.zeroFillRightShift=AbstractMatrix2.prototype.rightShift,AbstractMatrix2.prototype.zeroFillRightShiftS=AbstractMatrix2.prototype.rightShiftS,AbstractMatrix2.prototype.zeroFillRightShiftM=AbstractMatrix2.prototype.rightShiftM,AbstractMatrix2.zeroFillRightShift=AbstractMatrix2.rightShift,AbstractMatrix2.prototype.not=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,~this.get(i,j));return this},AbstractMatrix2.not=function(matrix){return new Matrix2(matrix).not()},AbstractMatrix2.prototype.abs=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.abs(this.get(i,j)));return this},AbstractMatrix2.abs=function(matrix){return new Matrix2(matrix).abs()},AbstractMatrix2.prototype.acos=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.acos(this.get(i,j)));return this},AbstractMatrix2.acos=function(matrix){return new Matrix2(matrix).acos()},AbstractMatrix2.prototype.acosh=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.acosh(this.get(i,j)));return this},AbstractMatrix2.acosh=function(matrix){return new Matrix2(matrix).acosh()},AbstractMatrix2.prototype.asin=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.asin(this.get(i,j)));return this},AbstractMatrix2.asin=function(matrix){return new Matrix2(matrix).asin()},AbstractMatrix2.prototype.asinh=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.asinh(this.get(i,j)));return this},AbstractMatrix2.asinh=function(matrix){return new Matrix2(matrix).asinh()},AbstractMatrix2.prototype.atan=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.atan(this.get(i,j)));return this},AbstractMatrix2.atan=function(matrix){return new Matrix2(matrix).atan()},AbstractMatrix2.prototype.atanh=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.atanh(this.get(i,j)));return this},AbstractMatrix2.atanh=function(matrix){return new Matrix2(matrix).atanh()},AbstractMatrix2.prototype.cbrt=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.cbrt(this.get(i,j)));return this},AbstractMatrix2.cbrt=function(matrix){return new Matrix2(matrix).cbrt()},AbstractMatrix2.prototype.ceil=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.ceil(this.get(i,j)));return this},AbstractMatrix2.ceil=function(matrix){return new Matrix2(matrix).ceil()},AbstractMatrix2.prototype.clz32=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.clz32(this.get(i,j)));return this},AbstractMatrix2.clz32=function(matrix){return new Matrix2(matrix).clz32()},AbstractMatrix2.prototype.cos=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.cos(this.get(i,j)));return this},AbstractMatrix2.cos=function(matrix){return new Matrix2(matrix).cos()},AbstractMatrix2.prototype.cosh=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.cosh(this.get(i,j)));return this},AbstractMatrix2.cosh=function(matrix){return new Matrix2(matrix).cosh()},AbstractMatrix2.prototype.exp=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.exp(this.get(i,j)));return this},AbstractMatrix2.exp=function(matrix){return new Matrix2(matrix).exp()},AbstractMatrix2.prototype.expm1=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.expm1(this.get(i,j)));return this},AbstractMatrix2.expm1=function(matrix){return new Matrix2(matrix).expm1()},AbstractMatrix2.prototype.floor=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.floor(this.get(i,j)));return this},AbstractMatrix2.floor=function(matrix){return new Matrix2(matrix).floor()},AbstractMatrix2.prototype.fround=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.fround(this.get(i,j)));return this},AbstractMatrix2.fround=function(matrix){return new Matrix2(matrix).fround()},AbstractMatrix2.prototype.log=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log(this.get(i,j)));return this},AbstractMatrix2.log=function(matrix){return new Matrix2(matrix).log()},AbstractMatrix2.prototype.log1p=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log1p(this.get(i,j)));return this},AbstractMatrix2.log1p=function(matrix){return new Matrix2(matrix).log1p()},AbstractMatrix2.prototype.log10=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log10(this.get(i,j)));return this},AbstractMatrix2.log10=function(matrix){return new Matrix2(matrix).log10()},AbstractMatrix2.prototype.log2=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log2(this.get(i,j)));return this},AbstractMatrix2.log2=function(matrix){return new Matrix2(matrix).log2()},AbstractMatrix2.prototype.round=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.round(this.get(i,j)));return this},AbstractMatrix2.round=function(matrix){return new Matrix2(matrix).round()},AbstractMatrix2.prototype.sign=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sign(this.get(i,j)));return this},AbstractMatrix2.sign=function(matrix){return new Matrix2(matrix).sign()},AbstractMatrix2.prototype.sin=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sin(this.get(i,j)));return this},AbstractMatrix2.sin=function(matrix){return new Matrix2(matrix).sin()},AbstractMatrix2.prototype.sinh=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sinh(this.get(i,j)));return this},AbstractMatrix2.sinh=function(matrix){return new Matrix2(matrix).sinh()},AbstractMatrix2.prototype.sqrt=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sqrt(this.get(i,j)));return this},AbstractMatrix2.sqrt=function(matrix){return new Matrix2(matrix).sqrt()},AbstractMatrix2.prototype.tan=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.tan(this.get(i,j)));return this},AbstractMatrix2.tan=function(matrix){return new Matrix2(matrix).tan()},AbstractMatrix2.prototype.tanh=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.tanh(this.get(i,j)));return this},AbstractMatrix2.tanh=function(matrix){return new Matrix2(matrix).tanh()},AbstractMatrix2.prototype.trunc=function(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.trunc(this.get(i,j)));return this},AbstractMatrix2.trunc=function(matrix){return new Matrix2(matrix).trunc()},AbstractMatrix2.pow=function(matrix,arg0){return new Matrix2(matrix).pow(arg0)},AbstractMatrix2.prototype.pow=function(value){return typeof value=="number"?this.powS(value):this.powM(value)},AbstractMatrix2.prototype.powS=function(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.pow(this.get(i,j),value));return this},AbstractMatrix2.prototype.powM=function(matrix){if(matrix=Matrix2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.pow(this.get(i,j),matrix.get(i,j)));return this}}function checkRowIndex(matrix,index,outer){let max=outer?matrix.rows:matrix.rows-1;if(index<0||index>max)throw new RangeError("Row index out of range")}function checkColumnIndex(matrix,index,outer){let max=outer?matrix.columns:matrix.columns-1;if(index<0||index>max)throw new RangeError("Column index out of range")}function checkRowVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.columns)throw new RangeError("vector size must be the same as the number of columns");return vector}function checkColumnVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.rows)throw new RangeError("vector size must be the same as the number of rows");return vector}function checkIndices(matrix,rowIndices,columnIndices){return{row:checkRowIndices(matrix,rowIndices),column:checkColumnIndices(matrix,columnIndices)}}function checkRowIndices(matrix,rowIndices){if(typeof rowIndices!="object")throw new TypeError("unexpected type for row indices");if(rowIndices.some(r=>r<0||r>=matrix.rows))throw new RangeError("row indices are out of range");return Array.isArray(rowIndices)||(rowIndices=Array.from(rowIndices)),rowIndices}function checkColumnIndices(matrix,columnIndices){if(typeof columnIndices!="object")throw new TypeError("unexpected type for column indices");if(columnIndices.some(c=>c<0||c>=matrix.columns))throw new RangeError("column indices are out of range");return Array.isArray(columnIndices)||(columnIndices=Array.from(columnIndices)),columnIndices}function checkRange(matrix,startRow,endRow,startColumn,endColumn){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",startRow),checkNumber("endRow",endRow),checkNumber("startColumn",startColumn),checkNumber("endColumn",endColumn),startRow>endRow||startColumn>endColumn||startRow<0||startRow>=matrix.rows||endRow<0||endRow>=matrix.rows||startColumn<0||startColumn>=matrix.columns||endColumn<0||endColumn>=matrix.columns)throw new RangeError("Submatrix indices are out of range")}function newArray(length,value=0){let array=[];for(let i=0;i<length;i++)array.push(value);return array}function checkNumber(name,value){if(typeof value!="number")throw new TypeError(`${name} must be a number`)}function checkNonEmpty(matrix){if(matrix.isEmpty())throw new Error("Empty matrix has no elements to index")}function sumByRow(matrix){let sum=newArray(matrix.rows);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[i]+=matrix.get(i,j);return sum}function sumByColumn(matrix){let sum=newArray(matrix.columns);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[j]+=matrix.get(i,j);return sum}function sumAll(matrix){let v=0;for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)v+=matrix.get(i,j);return v}function productByRow(matrix){let sum=newArray(matrix.rows,1);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[i]*=matrix.get(i,j);return sum}function productByColumn(matrix){let sum=newArray(matrix.columns,1);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[j]*=matrix.get(i,j);return sum}function productAll(matrix){let v=1;for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)v*=matrix.get(i,j);return v}function varianceByRow(matrix,unbiased,mean){const rows=matrix.rows,cols=matrix.columns,variance=[];for(let i=0;i<rows;i++){let sum1=0,sum2=0,x=0;for(let j=0;j<cols;j++)x=matrix.get(i,j)-mean[i],sum1+=x,sum2+=x*x;unbiased?variance.push((sum2-sum1*sum1/cols)/(cols-1)):variance.push((sum2-sum1*sum1/cols)/cols)}return variance}function varianceByColumn(matrix,unbiased,mean){const rows=matrix.rows,cols=matrix.columns,variance=[];for(let j=0;j<cols;j++){let sum1=0,sum2=0,x=0;for(let i=0;i<rows;i++)x=matrix.get(i,j)-mean[j],sum1+=x,sum2+=x*x;unbiased?variance.push((sum2-sum1*sum1/rows)/(rows-1)):variance.push((sum2-sum1*sum1/rows)/rows)}return variance}function varianceAll(matrix,unbiased,mean){const rows=matrix.rows,cols=matrix.columns,size=rows*cols;let sum1=0,sum2=0,x=0;for(let i=0;i<rows;i++)for(let j=0;j<cols;j++)x=matrix.get(i,j)-mean,sum1+=x,sum2+=x*x;return unbiased?(sum2-sum1*sum1/size)/(size-1):(sum2-sum1*sum1/size)/size}function centerByRow(matrix,mean){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)-mean[i])}function centerByColumn(matrix,mean){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)-mean[j])}function centerAll(matrix,mean){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)-mean)}function getScaleByRow(matrix){const scale=[];for(let i=0;i<matrix.rows;i++){let sum=0;for(let j=0;j<matrix.columns;j++)sum+=Math.pow(matrix.get(i,j),2)/(matrix.columns-1);scale.push(Math.sqrt(sum))}return scale}function scaleByRow(matrix,scale){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)/scale[i])}function getScaleByColumn(matrix){const scale=[];for(let j=0;j<matrix.columns;j++){let sum=0;for(let i=0;i<matrix.rows;i++)sum+=Math.pow(matrix.get(i,j),2)/(matrix.rows-1);scale.push(Math.sqrt(sum))}return scale}function scaleByColumn(matrix,scale){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)/scale[j])}function getScaleAll(matrix){const divider=matrix.size-1;let sum=0;for(let j=0;j<matrix.columns;j++)for(let i=0;i<matrix.rows;i++)sum+=Math.pow(matrix.get(i,j),2)/divider;return Math.sqrt(sum)}function scaleAll(matrix,scale){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)/scale)}class AbstractMatrix{static from1DArray(newRows,newColumns,newData){if(newRows*newColumns!==newData.length)throw new RangeError("data length does not match given dimensions");let newMatrix=new Matrix(newRows,newColumns);for(let row=0;row<newRows;row++)for(let column=0;column<newColumns;column++)newMatrix.set(row,column,newData[row*newColumns+column]);return newMatrix}static rowVector(newData){let vector=new Matrix(1,newData.length);for(let i=0;i<newData.length;i++)vector.set(0,i,newData[i]);return vector}static columnVector(newData){let vector=new Matrix(newData.length,1);for(let i=0;i<newData.length;i++)vector.set(i,0,newData[i]);return vector}static zeros(rows,columns){return new Matrix(rows,columns)}static ones(rows,columns){return new Matrix(rows,columns).fill(1)}static rand(rows,columns,options={}){if(typeof options!="object")throw new TypeError("options must be an object");const{random=Math.random}=options;let matrix=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)matrix.set(i,j,random());return matrix}static randInt(rows,columns,options={}){if(typeof options!="object")throw new TypeError("options must be an object");const{min=0,max=1e3,random=Math.random}=options;if(!Number.isInteger(min))throw new TypeError("min must be an integer");if(!Number.isInteger(max))throw new TypeError("max must be an integer");if(min>=max)throw new RangeError("min must be smaller than max");let interval=max-min,matrix=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++){let value=min+Math.round(random()*interval);matrix.set(i,j,value)}return matrix}static eye(rows,columns,value){columns===void 0&&(columns=rows),value===void 0&&(value=1);let min=Math.min(rows,columns),matrix=this.zeros(rows,columns);for(let i=0;i<min;i++)matrix.set(i,i,value);return matrix}static diag(data,rows,columns){let l=data.length;rows===void 0&&(rows=l),columns===void 0&&(columns=rows);let min=Math.min(l,rows,columns),matrix=this.zeros(rows,columns);for(let i=0;i<min;i++)matrix.set(i,i,data[i]);return matrix}static min(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);let rows=matrix1.rows,columns=matrix1.columns,result=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)result.set(i,j,Math.min(matrix1.get(i,j),matrix2.get(i,j)));return result}static max(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);let rows=matrix1.rows,columns=matrix1.columns,result=new this(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)result.set(i,j,Math.max(matrix1.get(i,j),matrix2.get(i,j)));return result}static checkMatrix(value){return AbstractMatrix.isMatrix(value)?value:new Matrix(value)}static isMatrix(value){return value!=null&&value.klass==="Matrix"}get size(){return this.rows*this.columns}apply(callback){if(typeof callback!="function")throw new TypeError("callback must be a function");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)callback.call(this,i,j);return this}to1DArray(){let array=[];for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)array.push(this.get(i,j));return array}to2DArray(){let copy=[];for(let i=0;i<this.rows;i++){copy.push([]);for(let j=0;j<this.columns;j++)copy[i].push(this.get(i,j))}return copy}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let i=0;i<this.rows;i++)for(let j=0;j<=i;j++)if(this.get(i,j)!==this.get(j,i))return!1;return!0}return!1}isEchelonForm(){let i=0,j=0,previousColumn=-1,isEchelonForm=!0,checked=!1;for(;i<this.rows&&isEchelonForm;){for(j=0,checked=!1;j<this.columns&&checked===!1;)this.get(i,j)===0?j++:this.get(i,j)===1&&j>previousColumn?(checked=!0,previousColumn=j):(isEchelonForm=!1,checked=!0);i++}return isEchelonForm}isReducedEchelonForm(){let i=0,j=0,previousColumn=-1,isReducedEchelonForm=!0,checked=!1;for(;i<this.rows&&isReducedEchelonForm;){for(j=0,checked=!1;j<this.columns&&checked===!1;)this.get(i,j)===0?j++:this.get(i,j)===1&&j>previousColumn?(checked=!0,previousColumn=j):(isReducedEchelonForm=!1,checked=!0);for(let k=j+1;k<this.rows;k++)this.get(i,k)!==0&&(isReducedEchelonForm=!1);i++}return isReducedEchelonForm}echelonForm(){let result=this.clone(),h=0,k=0;for(;h<result.rows&&k<result.columns;){let iMax=h;for(let i=h;i<result.rows;i++)result.get(i,k)>result.get(iMax,k)&&(iMax=i);if(result.get(iMax,k)===0)k++;else{result.swapRows(h,iMax);let tmp=result.get(h,k);for(let j=k;j<result.columns;j++)result.set(h,j,result.get(h,j)/tmp);for(let i=h+1;i<result.rows;i++){let factor=result.get(i,k)/result.get(h,k);result.set(i,k,0);for(let j=k+1;j<result.columns;j++)result.set(i,j,result.get(i,j)-result.get(h,j)*factor)}h++,k++}}return result}reducedEchelonForm(){let result=this.echelonForm(),m=result.columns,n=result.rows,h=n-1;for(;h>=0;)if(result.maxRow(h)===0)h--;else{let p=0,pivot=!1;for(;p<n&&pivot===!1;)result.get(h,p)===1?pivot=!0:p++;for(let i=0;i<h;i++){let factor=result.get(i,p);for(let j=p;j<m;j++){let tmp=result.get(i,j)-factor*result.get(h,j);result.set(i,j,tmp)}}h--}return result}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(options={}){if(typeof options!="object")throw new TypeError("options must be an object");const{rows=1,columns=1}=options;if(!Number.isInteger(rows)||rows<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(columns)||columns<=0)throw new TypeError("columns must be a positive integer");let matrix=new Matrix(this.rows*rows,this.columns*columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)matrix.setSubMatrix(this,this.rows*i,this.columns*j);return matrix}fill(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,value);return this}neg(){return this.mulS(-1)}getRow(index){checkRowIndex(this,index);let row=[];for(let i=0;i<this.columns;i++)row.push(this.get(index,i));return row}getRowVector(index){return Matrix.rowVector(this.getRow(index))}setRow(index,array){checkRowIndex(this,index),array=checkRowVector(this,array);for(let i=0;i<this.columns;i++)this.set(index,i,array[i]);return this}swapRows(row1,row2){checkRowIndex(this,row1),checkRowIndex(this,row2);for(let i=0;i<this.columns;i++){let temp=this.get(row1,i);this.set(row1,i,this.get(row2,i)),this.set(row2,i,temp)}return this}getColumn(index){checkColumnIndex(this,index);let column=[];for(let i=0;i<this.rows;i++)column.push(this.get(i,index));return column}getColumnVector(index){return Matrix.columnVector(this.getColumn(index))}setColumn(index,array){checkColumnIndex(this,index),array=checkColumnVector(this,array);for(let i=0;i<this.rows;i++)this.set(i,index,array[i]);return this}swapColumns(column1,column2){checkColumnIndex(this,column1),checkColumnIndex(this,column2);for(let i=0;i<this.rows;i++){let temp=this.get(i,column1);this.set(i,column1,this.get(i,column2)),this.set(i,column2,temp)}return this}addRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+vector[j]);return this}subRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-vector[j]);return this}mulRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*vector[j]);return this}divRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/vector[j]);return this}addColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+vector[i]);return this}subColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-vector[i]);return this}mulColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*vector[i]);return this}divColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/vector[i]);return this}mulRow(index,value){checkRowIndex(this,index);for(let i=0;i<this.columns;i++)this.set(index,i,this.get(index,i)*value);return this}mulColumn(index,value){checkColumnIndex(this,index);for(let i=0;i<this.rows;i++)this.set(i,index,this.get(i,index)*value);return this}max(){if(this.isEmpty())return NaN;let v=this.get(0,0);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.get(i,j)>v&&(v=this.get(i,j));return v}maxIndex(){checkNonEmpty(this);let v=this.get(0,0),idx=[0,0];for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.get(i,j)>v&&(v=this.get(i,j),idx[0]=i,idx[1]=j);return idx}min(){if(this.isEmpty())return NaN;let v=this.get(0,0);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.get(i,j)<v&&(v=this.get(i,j));return v}minIndex(){checkNonEmpty(this);let v=this.get(0,0),idx=[0,0];for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.get(i,j)<v&&(v=this.get(i,j),idx[0]=i,idx[1]=j);return idx}maxRow(row){if(checkRowIndex(this,row),this.isEmpty())return NaN;let v=this.get(row,0);for(let i=1;i<this.columns;i++)this.get(row,i)>v&&(v=this.get(row,i));return v}maxRowIndex(row){checkRowIndex(this,row),checkNonEmpty(this);let v=this.get(row,0),idx=[row,0];for(let i=1;i<this.columns;i++)this.get(row,i)>v&&(v=this.get(row,i),idx[1]=i);return idx}minRow(row){if(checkRowIndex(this,row),this.isEmpty())return NaN;let v=this.get(row,0);for(let i=1;i<this.columns;i++)this.get(row,i)<v&&(v=this.get(row,i));return v}minRowIndex(row){checkRowIndex(this,row),checkNonEmpty(this);let v=this.get(row,0),idx=[row,0];for(let i=1;i<this.columns;i++)this.get(row,i)<v&&(v=this.get(row,i),idx[1]=i);return idx}maxColumn(column){if(checkColumnIndex(this,column),this.isEmpty())return NaN;let v=this.get(0,column);for(let i=1;i<this.rows;i++)this.get(i,column)>v&&(v=this.get(i,column));return v}maxColumnIndex(column){checkColumnIndex(this,column),checkNonEmpty(this);let v=this.get(0,column),idx=[0,column];for(let i=1;i<this.rows;i++)this.get(i,column)>v&&(v=this.get(i,column),idx[0]=i);return idx}minColumn(column){if(checkColumnIndex(this,column),this.isEmpty())return NaN;let v=this.get(0,column);for(let i=1;i<this.rows;i++)this.get(i,column)<v&&(v=this.get(i,column));return v}minColumnIndex(column){checkColumnIndex(this,column),checkNonEmpty(this);let v=this.get(0,column),idx=[0,column];for(let i=1;i<this.rows;i++)this.get(i,column)<v&&(v=this.get(i,column),idx[0]=i);return idx}diag(){let min=Math.min(this.rows,this.columns),diag=[];for(let i=0;i<min;i++)diag.push(this.get(i,i));return diag}norm(type="frobenius"){let result=0;if(type==="max")return this.max();if(type==="frobenius"){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)result=result+this.get(i,j)*this.get(i,j);return Math.sqrt(result)}else throw new RangeError(`unknown norm type: ${type}`)}cumulativeSum(){let sum=0;for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)sum+=this.get(i,j),this.set(i,j,sum);return this}dot(vector2){AbstractMatrix.isMatrix(vector2)&&(vector2=vector2.to1DArray());let vector1=this.to1DArray();if(vector1.length!==vector2.length)throw new RangeError("vectors do not have the same size");let dot=0;for(let i=0;i<vector1.length;i++)dot+=vector1[i]*vector2[i];return dot}mmul(other){other=Matrix.checkMatrix(other);let m=this.rows,n=this.columns,p=other.columns,result=new Matrix(m,p),Bcolj=new Float64Array(n);for(let j=0;j<p;j++){for(let k=0;k<n;k++)Bcolj[k]=other.get(k,j);for(let i=0;i<m;i++){let s=0;for(let k=0;k<n;k++)s+=this.get(i,k)*Bcolj[k];result.set(i,j,s)}}return result}strassen2x2(other){other=Matrix.checkMatrix(other);let result=new Matrix(2,2);const a11=this.get(0,0),b11=other.get(0,0),a12=this.get(0,1),b12=other.get(0,1),a21=this.get(1,0),b21=other.get(1,0),a22=this.get(1,1),b22=other.get(1,1),m1=(a11+a22)*(b11+b22),m2=(a21+a22)*b11,m3=a11*(b12-b22),m4=a22*(b21-b11),m5=(a11+a12)*b22,m6=(a21-a11)*(b11+b12),m7=(a12-a22)*(b21+b22),c00=m1+m4-m5+m7,c01=m3+m5,c10=m2+m4,c11=m1-m2+m3+m6;return result.set(0,0,c00),result.set(0,1,c01),result.set(1,0,c10),result.set(1,1,c11),result}strassen3x3(other){other=Matrix.checkMatrix(other);let result=new Matrix(3,3);const a00=this.get(0,0),a01=this.get(0,1),a02=this.get(0,2),a10=this.get(1,0),a11=this.get(1,1),a12=this.get(1,2),a20=this.get(2,0),a21=this.get(2,1),a22=this.get(2,2),b00=other.get(0,0),b01=other.get(0,1),b02=other.get(0,2),b10=other.get(1,0),b11=other.get(1,1),b12=other.get(1,2),b20=other.get(2,0),b21=other.get(2,1),b22=other.get(2,2),m1=(a00+a01+a02-a10-a11-a21-a22)*b11,m2=(a00-a10)*(-b01+b11),m3=a11*(-b00+b01+b10-b11-b12-b20+b22),m4=(-a00+a10+a11)*(b00-b01+b11),m5=(a10+a11)*(-b00+b01),m6=a00*b00,m7=(-a00+a20+a21)*(b00-b02+b12),m8=(-a00+a20)*(b02-b12),m9=(a20+a21)*(-b00+b02),m10=(a00+a01+a02-a11-a12-a20-a21)*b12,m11=a21*(-b00+b02+b10-b11-b12-b20+b21),m12=(-a02+a21+a22)*(b11+b20-b21),m13=(a02-a22)*(b11-b21),m14=a02*b20,m15=(a21+a22)*(-b20+b21),m16=(-a02+a11+a12)*(b12+b20-b22),m17=(a02-a12)*(b12-b22),m18=(a11+a12)*(-b20+b22),m19=a01*b10,m20=a12*b21,m21=a10*b02,m22=a20*b01,m23=a22*b22,c00=m6+m14+m19,c01=m1+m4+m5+m6+m12+m14+m15,c02=m6+m7+m9+m10+m14+m16+m18,c10=m2+m3+m4+m6+m14+m16+m17,c11=m2+m4+m5+m6+m20,c12=m14+m16+m17+m18+m21,c20=m6+m7+m8+m11+m12+m13+m14,c21=m12+m13+m14+m15+m22,c22=m6+m7+m8+m9+m23;return result.set(0,0,c00),result.set(0,1,c01),result.set(0,2,c02),result.set(1,0,c10),result.set(1,1,c11),result.set(1,2,c12),result.set(2,0,c20),result.set(2,1,c21),result.set(2,2,c22),result}mmulStrassen(y){y=Matrix.checkMatrix(y);let x=this.clone(),r1=x.rows,c1=x.columns,r2=y.rows,c2=y.columns;c1!==r2&&console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);function embed(mat,rows,cols){let r3=mat.rows,c3=mat.columns;if(r3===rows&&c3===cols)return mat;{let resultat=AbstractMatrix.zeros(rows,cols);return resultat=resultat.setSubMatrix(mat,0,0),resultat}}let r=Math.max(r1,r2),c=Math.max(c1,c2);x=embed(x,r,c),y=embed(y,r,c);function blockMult(a,b,rows,cols){if(rows<=512||cols<=512)return a.mmul(b);rows%2===1&&cols%2===1?(a=embed(a,rows+1,cols+1),b=embed(b,rows+1,cols+1)):rows%2===1?(a=embed(a,rows+1,cols),b=embed(b,rows+1,cols)):cols%2===1&&(a=embed(a,rows,cols+1),b=embed(b,rows,cols+1));let halfRows=parseInt(a.rows/2,10),halfCols=parseInt(a.columns/2,10),a11=a.subMatrix(0,halfRows-1,0,halfCols-1),b11=b.subMatrix(0,halfRows-1,0,halfCols-1),a12=a.subMatrix(0,halfRows-1,halfCols,a.columns-1),b12=b.subMatrix(0,halfRows-1,halfCols,b.columns-1),a21=a.subMatrix(halfRows,a.rows-1,0,halfCols-1),b21=b.subMatrix(halfRows,b.rows-1,0,halfCols-1),a22=a.subMatrix(halfRows,a.rows-1,halfCols,a.columns-1),b22=b.subMatrix(halfRows,b.rows-1,halfCols,b.columns-1),m1=blockMult(AbstractMatrix.add(a11,a22),AbstractMatrix.add(b11,b22),halfRows,halfCols),m2=blockMult(AbstractMatrix.add(a21,a22),b11,halfRows,halfCols),m3=blockMult(a11,AbstractMatrix.sub(b12,b22),halfRows,halfCols),m4=blockMult(a22,AbstractMatrix.sub(b21,b11),halfRows,halfCols),m5=blockMult(AbstractMatrix.add(a11,a12),b22,halfRows,halfCols),m6=blockMult(AbstractMatrix.sub(a21,a11),AbstractMatrix.add(b11,b12),halfRows,halfCols),m7=blockMult(AbstractMatrix.sub(a12,a22),AbstractMatrix.add(b21,b22),halfRows,halfCols),c11=AbstractMatrix.add(m1,m4);c11.sub(m5),c11.add(m7);let c12=AbstractMatrix.add(m3,m5),c21=AbstractMatrix.add(m2,m4),c22=AbstractMatrix.sub(m1,m2);c22.add(m3),c22.add(m6);let resultat=AbstractMatrix.zeros(2*c11.rows,2*c11.columns);return resultat=resultat.setSubMatrix(c11,0,0),resultat=resultat.setSubMatrix(c12,c11.rows,0),resultat=resultat.setSubMatrix(c21,0,c11.columns),resultat=resultat.setSubMatrix(c22,c11.rows,c11.columns),resultat.subMatrix(0,rows-1,0,cols-1)}return blockMult(x,y,r,c)}scaleRows(options={}){if(typeof options!="object")throw new TypeError("options must be an object");const{min=0,max=1}=options;if(!Number.isFinite(min))throw new TypeError("min must be a number");if(!Number.isFinite(max))throw new TypeError("max must be a number");if(min>=max)throw new RangeError("min must be smaller than max");let newMatrix=new Matrix(this.rows,this.columns);for(let i=0;i<this.rows;i++){const row=this.getRow(i);row.length>0&&rescale__default.default(row,{min,max,output:row}),newMatrix.setRow(i,row)}return newMatrix}scaleColumns(options={}){if(typeof options!="object")throw new TypeError("options must be an object");const{min=0,max=1}=options;if(!Number.isFinite(min))throw new TypeError("min must be a number");if(!Number.isFinite(max))throw new TypeError("max must be a number");if(min>=max)throw new RangeError("min must be smaller than max");let newMatrix=new Matrix(this.rows,this.columns);for(let i=0;i<this.columns;i++){const column=this.getColumn(i);column.length&&rescale__default.default(column,{min,max,output:column}),newMatrix.setColumn(i,column)}return newMatrix}flipRows(){const middle=Math.ceil(this.columns/2);for(let i=0;i<this.rows;i++)for(let j=0;j<middle;j++){let first=this.get(i,j),last=this.get(i,this.columns-1-j);this.set(i,j,last),this.set(i,this.columns-1-j,first)}return this}flipColumns(){const middle=Math.ceil(this.rows/2);for(let j=0;j<this.columns;j++)for(let i=0;i<middle;i++){let first=this.get(i,j),last=this.get(this.rows-1-i,j);this.set(i,j,last),this.set(this.rows-1-i,j,first)}return this}kroneckerProduct(other){other=Matrix.checkMatrix(other);let m=this.rows,n=this.columns,p=other.rows,q=other.columns,result=new Matrix(m*p,n*q);for(let i=0;i<m;i++)for(let j=0;j<n;j++)for(let k=0;k<p;k++)for(let l=0;l<q;l++)result.set(p*i+k,q*j+l,this.get(i,j)*other.get(k,l));return result}kroneckerSum(other){if(other=Matrix.checkMatrix(other),!this.isSquare()||!other.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let m=this.rows,n=other.rows,AxI=this.kroneckerProduct(Matrix.eye(n,n)),IxB=Matrix.eye(m,m).kroneckerProduct(other);return AxI.add(IxB)}transpose(){let result=new Matrix(this.columns,this.rows);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)result.set(j,i,this.get(i,j));return result}sortRows(compareFunction=compareNumbers){for(let i=0;i<this.rows;i++)this.setRow(i,this.getRow(i).sort(compareFunction));return this}sortColumns(compareFunction=compareNumbers){for(let i=0;i<this.columns;i++)this.setColumn(i,this.getColumn(i).sort(compareFunction));return this}subMatrix(startRow,endRow,startColumn,endColumn){checkRange(this,startRow,endRow,startColumn,endColumn);let newMatrix=new Matrix(endRow-startRow+1,endColumn-startColumn+1);for(let i=startRow;i<=endRow;i++)for(let j=startColumn;j<=endColumn;j++)newMatrix.set(i-startRow,j-startColumn,this.get(i,j));return newMatrix}subMatrixRow(indices,startColumn,endColumn){if(startColumn===void 0&&(startColumn=0),endColumn===void 0&&(endColumn=this.columns-1),startColumn>endColumn||startColumn<0||startColumn>=this.columns||endColumn<0||endColumn>=this.columns)throw new RangeError("Argument out of range");let newMatrix=new Matrix(indices.length,endColumn-startColumn+1);for(let i=0;i<indices.length;i++)for(let j=startColumn;j<=endColumn;j++){if(indices[i]<0||indices[i]>=this.rows)throw new RangeError(`Row index out of range: ${indices[i]}`);newMatrix.set(i,j-startColumn,this.get(indices[i],j))}return newMatrix}subMatrixColumn(indices,startRow,endRow){if(startRow===void 0&&(startRow=0),endRow===void 0&&(endRow=this.rows-1),startRow>endRow||startRow<0||startRow>=this.rows||endRow<0||endRow>=this.rows)throw new RangeError("Argument out of range");let newMatrix=new Matrix(endRow-startRow+1,indices.length);for(let i=0;i<indices.length;i++)for(let j=startRow;j<=endRow;j++){if(indices[i]<0||indices[i]>=this.columns)throw new RangeError(`Column index out of range: ${indices[i]}`);newMatrix.set(j-startRow,i,this.get(j,indices[i]))}return newMatrix}setSubMatrix(matrix,startRow,startColumn){if(matrix=Matrix.checkMatrix(matrix),matrix.isEmpty())return this;let endRow=startRow+matrix.rows-1,endColumn=startColumn+matrix.columns-1;checkRange(this,startRow,endRow,startColumn,endColumn);for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)this.set(startRow+i,startColumn+j,matrix.get(i,j));return this}selection(rowIndices,columnIndices){let indices=checkIndices(this,rowIndices,columnIndices),newMatrix=new Matrix(rowIndices.length,columnIndices.length);for(let i=0;i<indices.row.length;i++){let rowIndex=indices.row[i];for(let j=0;j<indices.column.length;j++){let columnIndex=indices.column[j];newMatrix.set(i,j,this.get(rowIndex,columnIndex))}}return newMatrix}trace(){let min=Math.min(this.rows,this.columns),trace=0;for(let i=0;i<min;i++)trace+=this.get(i,i);return trace}clone(){let newMatrix=new Matrix(this.rows,this.columns);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)newMatrix.set(row,column,this.get(row,column));return newMatrix}sum(by){switch(by){case"row":return sumByRow(this);case"column":return sumByColumn(this);case void 0:return sumAll(this);default:throw new Error(`invalid option: ${by}`)}}product(by){switch(by){case"row":return productByRow(this);case"column":return productByColumn(this);case void 0:return productAll(this);default:throw new Error(`invalid option: ${by}`)}}mean(by){const sum=this.sum(by);switch(by){case"row":{for(let i=0;i<this.rows;i++)sum[i]/=this.columns;return sum}case"column":{for(let i=0;i<this.columns;i++)sum[i]/=this.rows;return sum}case void 0:return sum/this.size;default:throw new Error(`invalid option: ${by}`)}}variance(by,options={}){if(typeof by=="object"&&(options=by,by=void 0),typeof options!="object")throw new TypeError("options must be an object");const{unbiased=!0,mean=this.mean(by)}=options;if(typeof unbiased!="boolean")throw new TypeError("unbiased must be a boolean");switch(by){case"row":{if(!Array.isArray(mean))throw new TypeError("mean must be an array");return varianceByRow(this,unbiased,mean)}case"column":{if(!Array.isArray(mean))throw new TypeError("mean must be an array");return varianceByColumn(this,unbiased,mean)}case void 0:{if(typeof mean!="number")throw new TypeError("mean must be a number");return varianceAll(this,unbiased,mean)}default:throw new Error(`invalid option: ${by}`)}}standardDeviation(by,options){typeof by=="object"&&(options=by,by=void 0);const variance=this.variance(by,options);if(by===void 0)return Math.sqrt(variance);for(let i=0;i<variance.length;i++)variance[i]=Math.sqrt(variance[i]);return variance}center(by,options={}){if(typeof by=="object"&&(options=by,by=void 0),typeof options!="object")throw new TypeError("options must be an object");const{center=this.mean(by)}=options;switch(by){case"row":{if(!Array.isArray(center))throw new TypeError("center must be an array");return centerByRow(this,center),this}case"column":{if(!Array.isArray(center))throw new TypeError("center must be an array");return centerByColumn(this,center),this}case void 0:{if(typeof center!="number")throw new TypeError("center must be a number");return centerAll(this,center),this}default:throw new Error(`invalid option: ${by}`)}}scale(by,options={}){if(typeof by=="object"&&(options=by,by=void 0),typeof options!="object")throw new TypeError("options must be an object");let scale=options.scale;switch(by){case"row":{if(scale===void 0)scale=getScaleByRow(this);else if(!Array.isArray(scale))throw new TypeError("scale must be an array");return scaleByRow(this,scale),this}case"column":{if(scale===void 0)scale=getScaleByColumn(this);else if(!Array.isArray(scale))throw new TypeError("scale must be an array");return scaleByColumn(this,scale),this}case void 0:{if(scale===void 0)scale=getScaleAll(this);else if(typeof scale!="number")throw new TypeError("scale must be a number");return scaleAll(this,scale),this}default:throw new Error(`invalid option: ${by}`)}}toString(options){return inspectMatrixWithOptions(this,options)}}AbstractMatrix.prototype.klass="Matrix",typeof Symbol!="undefined"&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=inspectMatrix);function compareNumbers(a,b){return a-b}AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;class Matrix extends AbstractMatrix{constructor(nRows,nColumns){super();if(Matrix.isMatrix(nRows))return nRows.clone();if(Number.isInteger(nRows)&&nRows>=0)if(this.data=[],Number.isInteger(nColumns)&&nColumns>=0)for(let i=0;i<nRows;i++)this.data.push(new Float64Array(nColumns));else throw new TypeError("nColumns must be a positive integer");else if(Array.isArray(nRows)){const arrayData=nRows;if(nRows=arrayData.length,nColumns=nRows?arrayData[0].length:0,typeof nColumns!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let i=0;i<nRows;i++){if(arrayData[i].length!==nColumns)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(arrayData[i]))}}else throw new TypeError("First argument must be a positive number or an array");this.rows=nRows,this.columns=nColumns}set(rowIndex,columnIndex,value){return this.data[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this.data[rowIndex][columnIndex]}removeRow(index){return checkRowIndex(this,index),this.data.splice(index,1),this.rows-=1,this}addRow(index,array){return array===void 0&&(array=index,index=this.rows),checkRowIndex(this,index,!0),array=Float64Array.from(checkRowVector(this,array)),this.data.splice(index,0,array),this.rows+=1,this}removeColumn(index){checkColumnIndex(this,index);for(let i=0;i<this.rows;i++){const newRow=new Float64Array(this.columns-1);for(let j=0;j<index;j++)newRow[j]=this.data[i][j];for(let j=index+1;j<this.columns;j++)newRow[j-1]=this.data[i][j];this.data[i]=newRow}return this.columns-=1,this}addColumn(index,array){typeof array=="undefined"&&(array=index,index=this.columns),checkColumnIndex(this,index,!0),array=checkColumnVector(this,array);for(let i=0;i<this.rows;i++){const newRow=new Float64Array(this.columns+1);let j=0;for(;j<index;j++)newRow[j]=this.data[i][j];for(newRow[j++]=array[i];j<this.columns+1;j++)newRow[j]=this.data[i][j-1];this.data[i]=newRow}return this.columns+=1,this}}installMathOperations(AbstractMatrix,Matrix);class BaseView extends AbstractMatrix{constructor(matrix,rows,columns){super();this.matrix=matrix,this.rows=rows,this.columns=columns}}class MatrixColumnView extends BaseView{constructor(matrix,column){checkColumnIndex(matrix,column);super(matrix,matrix.rows,1);this.column=column}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.column,value),this}get(rowIndex){return this.matrix.get(rowIndex,this.column)}}class MatrixColumnSelectionView extends BaseView{constructor(matrix,columnIndices){columnIndices=checkColumnIndices(matrix,columnIndices);super(matrix,matrix.rows,columnIndices.length);this.columnIndices=columnIndices}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columnIndices[columnIndex])}}class MatrixFlipColumnView extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columns-columnIndex-1,value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columns-columnIndex-1)}}class MatrixFlipRowView extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(this.rows-rowIndex-1,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rows-rowIndex-1,columnIndex)}}class MatrixRowView extends BaseView{constructor(matrix,row){checkRowIndex(matrix,row);super(matrix,1,matrix.columns);this.row=row}set(rowIndex,columnIndex,value){return this.matrix.set(this.row,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.row,columnIndex)}}class MatrixRowSelectionView extends BaseView{constructor(matrix,rowIndices){rowIndices=checkRowIndices(matrix,rowIndices);super(matrix,rowIndices.length,matrix.columns);this.rowIndices=rowIndices}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],columnIndex)}}class MatrixSelectionView extends BaseView{constructor(matrix,rowIndices,columnIndices){let indices=checkIndices(matrix,rowIndices,columnIndices);super(matrix,indices.row.length,indices.column.length);this.rowIndices=indices.row,this.columnIndices=indices.column}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],this.columnIndices[columnIndex])}}class MatrixSubView extends BaseView{constructor(matrix,startRow,endRow,startColumn,endColumn){checkRange(matrix,startRow,endRow,startColumn,endColumn);super(matrix,endRow-startRow+1,endColumn-startColumn+1);this.startRow=startRow,this.startColumn=startColumn}set(rowIndex,columnIndex,value){return this.matrix.set(this.startRow+rowIndex,this.startColumn+columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.startRow+rowIndex,this.startColumn+columnIndex)}}class MatrixTransposeView extends BaseView{constructor(matrix){super(matrix,matrix.columns,matrix.rows)}set(rowIndex,columnIndex,value){return this.matrix.set(columnIndex,rowIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(columnIndex,rowIndex)}}class WrapperMatrix1D extends AbstractMatrix{constructor(data,options={}){const{rows=1}=options;if(data.length%rows!==0)throw new Error("the data length is not divisible by the number of rows");super();this.rows=rows,this.columns=data.length/rows,this.data=data}set(rowIndex,columnIndex,value){let index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]=value,this}get(rowIndex,columnIndex){let index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]}_calculateIndex(row,column){return row*this.columns+column}}class WrapperMatrix2D extends AbstractMatrix{constructor(data){super();this.data=data,this.rows=data.length,this.columns=data[0].length}set(rowIndex,columnIndex,value){return this.data[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this.data[rowIndex][columnIndex]}}function wrap(array,options){if(Array.isArray(array))return array[0]&&Array.isArray(array[0])?new WrapperMatrix2D(array):new WrapperMatrix1D(array,options);throw new Error("the argument is not an array")}class LuDecomposition{constructor(matrix){matrix=WrapperMatrix2D.checkMatrix(matrix);let lu=matrix.clone(),rows=lu.rows,columns=lu.columns,pivotVector=new Float64Array(rows),pivotSign=1,i,j,k,p,s,t,v,LUcolj,kmax;for(i=0;i<rows;i++)pivotVector[i]=i;for(LUcolj=new Float64Array(rows),j=0;j<columns;j++){for(i=0;i<rows;i++)LUcolj[i]=lu.get(i,j);for(i=0;i<rows;i++){for(kmax=Math.min(i,j),s=0,k=0;k<kmax;k++)s+=lu.get(i,k)*LUcolj[k];LUcolj[i]-=s,lu.set(i,j,LUcolj[i])}for(p=j,i=j+1;i<rows;i++)Math.abs(LUcolj[i])>Math.abs(LUcolj[p])&&(p=i);if(p!==j){for(k=0;k<columns;k++)t=lu.get(p,k),lu.set(p,k,lu.get(j,k)),lu.set(j,k,t);v=pivotVector[p],pivotVector[p]=pivotVector[j],pivotVector[j]=v,pivotSign=-pivotSign}if(j<rows&&lu.get(j,j)!==0)for(i=j+1;i<rows;i++)lu.set(i,j,lu.get(i,j)/lu.get(j,j))}this.LU=lu,this.pivotVector=pivotVector,this.pivotSign=pivotSign}isSingular(){let data=this.LU,col=data.columns;for(let j=0;j<col;j++)if(data.get(j,j)===0)return!0;return!1}solve(value){value=Matrix.checkMatrix(value);let lu=this.LU;if(lu.rows!==value.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let count=value.columns,X=value.subMatrixRow(this.pivotVector,0,count-1),columns=lu.columns,i,j,k;for(k=0;k<columns;k++)for(i=k+1;i<columns;i++)for(j=0;j<count;j++)X.set(i,j,X.get(i,j)-X.get(k,j)*lu.get(i,k));for(k=columns-1;k>=0;k--){for(j=0;j<count;j++)X.set(k,j,X.get(k,j)/lu.get(k,k));for(i=0;i<k;i++)for(j=0;j<count;j++)X.set(i,j,X.get(i,j)-X.get(k,j)*lu.get(i,k))}return X}get determinant(){let data=this.LU;if(!data.isSquare())throw new Error("Matrix must be square");let determinant2=this.pivotSign,col=data.columns;for(let j=0;j<col;j++)determinant2*=data.get(j,j);return determinant2}get lowerTriangularMatrix(){let data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)i>j?X.set(i,j,data.get(i,j)):i===j?X.set(i,j,1):X.set(i,j,0);return X}get upperTriangularMatrix(){let data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)i<=j?X.set(i,j,data.get(i,j)):X.set(i,j,0);return X}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse(a,b){let r=0;return Math.abs(a)>Math.abs(b)?(r=b/a,Math.abs(a)*Math.sqrt(1+r*r)):b!==0?(r=a/b,Math.abs(b)*Math.sqrt(1+r*r)):0}class QrDecomposition{constructor(value){value=WrapperMatrix2D.checkMatrix(value);let qr=value.clone(),m=value.rows,n=value.columns,rdiag=new Float64Array(n),i,j,k,s;for(k=0;k<n;k++){let nrm=0;for(i=k;i<m;i++)nrm=hypotenuse(nrm,qr.get(i,k));if(nrm!==0){for(qr.get(k,k)<0&&(nrm=-nrm),i=k;i<m;i++)qr.set(i,k,qr.get(i,k)/nrm);for(qr.set(k,k,qr.get(k,k)+1),j=k+1;j<n;j++){for(s=0,i=k;i<m;i++)s+=qr.get(i,k)*qr.get(i,j);for(s=-s/qr.get(k,k),i=k;i<m;i++)qr.set(i,j,qr.get(i,j)+s*qr.get(i,k))}}rdiag[k]=-nrm}this.QR=qr,this.Rdiag=rdiag}solve(value){value=Matrix.checkMatrix(value);let qr=this.QR,m=qr.rows;if(value.rows!==m)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let count=value.columns,X=value.clone(),n=qr.columns,i,j,k,s;for(k=0;k<n;k++)for(j=0;j<count;j++){for(s=0,i=k;i<m;i++)s+=qr.get(i,k)*X.get(i,j);for(s=-s/qr.get(k,k),i=k;i<m;i++)X.set(i,j,X.get(i,j)+s*qr.get(i,k))}for(k=n-1;k>=0;k--){for(j=0;j<count;j++)X.set(k,j,X.get(k,j)/this.Rdiag[k]);for(i=0;i<k;i++)for(j=0;j<count;j++)X.set(i,j,X.get(i,j)-X.get(k,j)*qr.get(i,k))}return X.subMatrix(0,n-1,0,count-1)}isFullRank(){let columns=this.QR.columns;for(let i=0;i<columns;i++)if(this.Rdiag[i]===0)return!1;return!0}get upperTriangularMatrix(){let qr=this.QR,n=qr.columns,X=new Matrix(n,n),i,j;for(i=0;i<n;i++)for(j=0;j<n;j++)i<j?X.set(i,j,qr.get(i,j)):i===j?X.set(i,j,this.Rdiag[i]):X.set(i,j,0);return X}get orthogonalMatrix(){let qr=this.QR,rows=qr.rows,columns=qr.columns,X=new Matrix(rows,columns),i,j,k,s;for(k=columns-1;k>=0;k--){for(i=0;i<rows;i++)X.set(i,k,0);for(X.set(k,k,1),j=k;j<columns;j++)if(qr.get(k,k)!==0){for(s=0,i=k;i<rows;i++)s+=qr.get(i,k)*X.get(i,j);for(s=-s/qr.get(k,k),i=k;i<rows;i++)X.set(i,j,X.get(i,j)+s*qr.get(i,k))}}return X}}class SingularValueDecomposition{constructor(value,options={}){if(value=WrapperMatrix2D.checkMatrix(value),value.isEmpty())throw new Error("Matrix must be non-empty");let m=value.rows,n=value.columns;const{computeLeftSingularVectors=!0,computeRightSingularVectors=!0,autoTranspose=!1}=options;let wantu=Boolean(computeLeftSingularVectors),wantv=Boolean(computeRightSingularVectors),swapped=!1,a;if(m<n)if(!autoTranspose)a=value.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{a=value.transpose(),m=a.rows,n=a.columns,swapped=!0;let aux=wantu;wantu=wantv,wantv=aux}else a=value.clone();let nu=Math.min(m,n),ni=Math.min(m+1,n),s=new Float64Array(ni),U=new Matrix(m,nu),V=new Matrix(n,n),e=new Float64Array(n),work=new Float64Array(m),si=new Float64Array(ni);for(let i=0;i<ni;i++)si[i]=i;let nct=Math.min(m-1,n),nrt=Math.max(0,Math.min(n-2,m)),mrc=Math.max(nct,nrt);for(let k=0;k<mrc;k++){if(k<nct){s[k]=0;for(let i=k;i<m;i++)s[k]=hypotenuse(s[k],a.get(i,k));if(s[k]!==0){a.get(k,k)<0&&(s[k]=-s[k]);for(let i=k;i<m;i++)a.set(i,k,a.get(i,k)/s[k]);a.set(k,k,a.get(k,k)+1)}s[k]=-s[k]}for(let j=k+1;j<n;j++){if(k<nct&&s[k]!==0){let t=0;for(let i=k;i<m;i++)t+=a.get(i,k)*a.get(i,j);t=-t/a.get(k,k);for(let i=k;i<m;i++)a.set(i,j,a.get(i,j)+t*a.get(i,k))}e[j]=a.get(k,j)}if(wantu&&k<nct)for(let i=k;i<m;i++)U.set(i,k,a.get(i,k));if(k<nrt){e[k]=0;for(let i=k+1;i<n;i++)e[k]=hypotenuse(e[k],e[i]);if(e[k]!==0){e[k+1]<0&&(e[k]=0-e[k]);for(let i=k+1;i<n;i++)e[i]/=e[k];e[k+1]+=1}if(e[k]=-e[k],k+1<m&&e[k]!==0){for(let i=k+1;i<m;i++)work[i]=0;for(let i=k+1;i<m;i++)for(let j=k+1;j<n;j++)work[i]+=e[j]*a.get(i,j);for(let j=k+1;j<n;j++){let t=-e[j]/e[k+1];for(let i=k+1;i<m;i++)a.set(i,j,a.get(i,j)+t*work[i])}}if(wantv)for(let i=k+1;i<n;i++)V.set(i,k,e[i])}}let p=Math.min(n,m+1);if(nct<n&&(s[nct]=a.get(nct,nct)),m<p&&(s[p-1]=0),nrt+1<p&&(e[nrt]=a.get(nrt,p-1)),e[p-1]=0,wantu){for(let j=nct;j<nu;j++){for(let i=0;i<m;i++)U.set(i,j,0);U.set(j,j,1)}for(let k=nct-1;k>=0;k--)if(s[k]!==0){for(let j=k+1;j<nu;j++){let t=0;for(let i=k;i<m;i++)t+=U.get(i,k)*U.get(i,j);t=-t/U.get(k,k);for(let i=k;i<m;i++)U.set(i,j,U.get(i,j)+t*U.get(i,k))}for(let i=k;i<m;i++)U.set(i,k,-U.get(i,k));U.set(k,k,1+U.get(k,k));for(let i=0;i<k-1;i++)U.set(i,k,0)}else{for(let i=0;i<m;i++)U.set(i,k,0);U.set(k,k,1)}}if(wantv)for(let k=n-1;k>=0;k--){if(k<nrt&&e[k]!==0)for(let j=k+1;j<n;j++){let t=0;for(let i=k+1;i<n;i++)t+=V.get(i,k)*V.get(i,j);t=-t/V.get(k+1,k);for(let i=k+1;i<n;i++)V.set(i,j,V.get(i,j)+t*V.get(i,k))}for(let i=0;i<n;i++)V.set(i,k,0);V.set(k,k,1)}let pp=p-1,eps=Number.EPSILON;for(;p>0;){let k,kase;for(k=p-2;k>=-1&&k!==-1;k--){const alpha=Number.MIN_VALUE+eps*Math.abs(s[k]+Math.abs(s[k+1]));if(Math.abs(e[k])<=alpha||Number.isNaN(e[k])){e[k]=0;break}}if(k===p-2)kase=4;else{let ks;for(ks=p-1;ks>=k&&ks!==k;ks--){let t=(ks!==p?Math.abs(e[ks]):0)+(ks!==k+1?Math.abs(e[ks-1]):0);if(Math.abs(s[ks])<=eps*t){s[ks]=0;break}}ks===k?kase=3:ks===p-1?kase=1:(kase=2,k=ks)}switch(k++,kase){case 1:{let f=e[p-2];e[p-2]=0;for(let j=p-2;j>=k;j--){let t=hypotenuse(s[j],f),cs=s[j]/t,sn=f/t;if(s[j]=t,j!==k&&(f=-sn*e[j-1],e[j-1]=cs*e[j-1]),wantv)for(let i=0;i<n;i++)t=cs*V.get(i,j)+sn*V.get(i,p-1),V.set(i,p-1,-sn*V.get(i,j)+cs*V.get(i,p-1)),V.set(i,j,t)}break}case 2:{let f=e[k-1];e[k-1]=0;for(let j=k;j<p;j++){let t=hypotenuse(s[j],f),cs=s[j]/t,sn=f/t;if(s[j]=t,f=-sn*e[j],e[j]=cs*e[j],wantu)for(let i=0;i<m;i++)t=cs*U.get(i,j)+sn*U.get(i,k-1),U.set(i,k-1,-sn*U.get(i,j)+cs*U.get(i,k-1)),U.set(i,j,t)}break}case 3:{const scale=Math.max(Math.abs(s[p-1]),Math.abs(s[p-2]),Math.abs(e[p-2]),Math.abs(s[k]),Math.abs(e[k])),sp=s[p-1]/scale,spm1=s[p-2]/scale,epm1=e[p-2]/scale,sk=s[k]/scale,ek=e[k]/scale,b=((spm1+sp)*(spm1-sp)+epm1*epm1)/2,c=sp*epm1*(sp*epm1);let shift=0;(b!==0||c!==0)&&(b<0?shift=0-Math.sqrt(b*b+c):shift=Math.sqrt(b*b+c),shift=c/(b+shift));let f=(sk+sp)*(sk-sp)+shift,g=sk*ek;for(let j=k;j<p-1;j++){let t=hypotenuse(f,g);t===0&&(t=Number.MIN_VALUE);let cs=f/t,sn=g/t;if(j!==k&&(e[j-1]=t),f=cs*s[j]+sn*e[j],e[j]=cs*e[j]-sn*s[j],g=sn*s[j+1],s[j+1]=cs*s[j+1],wantv)for(let i=0;i<n;i++)t=cs*V.get(i,j)+sn*V.get(i,j+1),V.set(i,j+1,-sn*V.get(i,j)+cs*V.get(i,j+1)),V.set(i,j,t);if(t=hypotenuse(f,g),t===0&&(t=Number.MIN_VALUE),cs=f/t,sn=g/t,s[j]=t,f=cs*e[j]+sn*s[j+1],s[j+1]=-sn*e[j]+cs*s[j+1],g=sn*e[j+1],e[j+1]=cs*e[j+1],wantu&&j<m-1)for(let i=0;i<m;i++)t=cs*U.get(i,j)+sn*U.get(i,j+1),U.set(i,j+1,-sn*U.get(i,j)+cs*U.get(i,j+1)),U.set(i,j,t)}e[p-2]=f;break}case 4:{if(s[k]<=0&&(s[k]=s[k]<0?-s[k]:0,wantv))for(let i=0;i<=pp;i++)V.set(i,k,-V.get(i,k));for(;k<pp&&!(s[k]>=s[k+1]);){let t=s[k];if(s[k]=s[k+1],s[k+1]=t,wantv&&k<n-1)for(let i=0;i<n;i++)t=V.get(i,k+1),V.set(i,k+1,V.get(i,k)),V.set(i,k,t);if(wantu&&k<m-1)for(let i=0;i<m;i++)t=U.get(i,k+1),U.set(i,k+1,U.get(i,k)),U.set(i,k,t);k++}p--;break}}}if(swapped){let tmp=V;V=U,U=tmp}this.m=m,this.n=n,this.s=s,this.U=U,this.V=V}solve(value){let Y=value,e=this.threshold,scols=this.s.length,Ls=Matrix.zeros(scols,scols);for(let i=0;i<scols;i++)Math.abs(this.s[i])<=e?Ls.set(i,i,0):Ls.set(i,i,1/this.s[i]);let U=this.U,V=this.rightSingularVectors,VL=V.mmul(Ls),vrows=V.rows,urows=U.rows,VLU=Matrix.zeros(vrows,urows);for(let i=0;i<vrows;i++)for(let j=0;j<urows;j++){let sum=0;for(let k=0;k<scols;k++)sum+=VL.get(i,k)*U.get(j,k);VLU.set(i,j,sum)}return VLU.mmul(Y)}solveForDiagonal(value){return this.solve(Matrix.diag(value))}inverse(){let V=this.V,e=this.threshold,vrows=V.rows,vcols=V.columns,X=new Matrix(vrows,this.s.length);for(let i=0;i<vrows;i++)for(let j=0;j<vcols;j++)Math.abs(this.s[j])>e&&X.set(i,j,V.get(i,j)/this.s[j]);let U=this.U,urows=U.rows,ucols=U.columns,Y=new Matrix(vrows,urows);for(let i=0;i<vrows;i++)for(let j=0;j<urows;j++){let sum=0;for(let k=0;k<ucols;k++)sum+=X.get(i,k)*U.get(j,k);Y.set(i,j,sum)}return Y}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let tol=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,r=0,s=this.s;for(let i=0,ii=s.length;i<ii;i++)s[i]>tol&&r++;return r}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix.diag(this.s)}}function inverse(matrix,useSVD=!1){return matrix=WrapperMatrix2D.checkMatrix(matrix),useSVD?new SingularValueDecomposition(matrix).inverse():solve(matrix,Matrix.eye(matrix.rows))}function solve(leftHandSide,rightHandSide,useSVD=!1){return leftHandSide=WrapperMatrix2D.checkMatrix(leftHandSide),rightHandSide=WrapperMatrix2D.checkMatrix(rightHandSide),useSVD?new SingularValueDecomposition(leftHandSide).solve(rightHandSide):leftHandSide.isSquare()?new LuDecomposition(leftHandSide).solve(rightHandSide):new QrDecomposition(leftHandSide).solve(rightHandSide)}function determinant(matrix){if(matrix=Matrix.checkMatrix(matrix),matrix.isSquare()){if(matrix.columns===0)return 1;let a,b,c,d;if(matrix.columns===2)return a=matrix.get(0,0),b=matrix.get(0,1),c=matrix.get(1,0),d=matrix.get(1,1),a*d-b*c;if(matrix.columns===3){let subMatrix0,subMatrix1,subMatrix2;return subMatrix0=new MatrixSelectionView(matrix,[1,2],[1,2]),subMatrix1=new MatrixSelectionView(matrix,[1,2],[0,2]),subMatrix2=new MatrixSelectionView(matrix,[1,2],[0,1]),a=matrix.get(0,0),b=matrix.get(0,1),c=matrix.get(0,2),a*determinant(subMatrix0)-b*determinant(subMatrix1)+c*determinant(subMatrix2)}else return new LuDecomposition(matrix).determinant}else throw Error("determinant can only be calculated for a square matrix")}function xrange(n,exception){let range=[];for(let i=0;i<n;i++)i!==exception&&range.push(i);return range}function dependenciesOneRow(error,matrix,index,thresholdValue=1e-9,thresholdError=1e-9){if(error>thresholdError)return new Array(matrix.rows+1).fill(0);{let returnArray=matrix.addRow(index,[0]);for(let i=0;i<returnArray.rows;i++)Math.abs(returnArray.get(i,0))<thresholdValue&&returnArray.set(i,0,0);return returnArray.to1DArray()}}function linearDependencies(matrix,options={}){const{thresholdValue=1e-9,thresholdError=1e-9}=options;matrix=Matrix.checkMatrix(matrix);let n=matrix.rows,results=new Matrix(n,n);for(let i=0;i<n;i++){let b=Matrix.columnVector(matrix.getRow(i)),Abis=matrix.subMatrixRow(xrange(n,i)).transpose(),x=new SingularValueDecomposition(Abis).solve(b),error=Matrix.sub(b,Abis.mmul(x)).abs().max();results.setRow(i,dependenciesOneRow(error,x,i,thresholdValue,thresholdError))}return results}function pseudoInverse(matrix,threshold=Number.EPSILON){if(matrix=Matrix.checkMatrix(matrix),matrix.isEmpty())return matrix.transpose();let svdSolution=new SingularValueDecomposition(matrix,{autoTranspose:!0}),U=svdSolution.leftSingularVectors,V=svdSolution.rightSingularVectors,s=svdSolution.diagonal;for(let i=0;i<s.length;i++)Math.abs(s[i])>threshold?s[i]=1/s[i]:s[i]=0;return V.mmul(Matrix.diag(s).mmul(U.transpose()))}function covariance(xMatrix,yMatrix=xMatrix,options={}){xMatrix=new Matrix(xMatrix);let yIsSame=!1;if(typeof yMatrix=="object"&&!Matrix.isMatrix(yMatrix)&&!Array.isArray(yMatrix)?(options=yMatrix,yMatrix=xMatrix,yIsSame=!0):yMatrix=new Matrix(yMatrix),xMatrix.rows!==yMatrix.rows)throw new TypeError("Both matrices must have the same number of rows");const{center=!0}=options;center&&(xMatrix=xMatrix.center("column"),yIsSame||(yMatrix=yMatrix.center("column")));const cov=xMatrix.transpose().mmul(yMatrix);for(let i=0;i<cov.rows;i++)for(let j=0;j<cov.columns;j++)cov.set(i,j,cov.get(i,j)*(1/(xMatrix.rows-1)));return cov}function correlation(xMatrix,yMatrix=xMatrix,options={}){xMatrix=new Matrix(xMatrix);let yIsSame=!1;if(typeof yMatrix=="object"&&!Matrix.isMatrix(yMatrix)&&!Array.isArray(yMatrix)?(options=yMatrix,yMatrix=xMatrix,yIsSame=!0):yMatrix=new Matrix(yMatrix),xMatrix.rows!==yMatrix.rows)throw new TypeError("Both matrices must have the same number of rows");const{center=!0,scale=!0}=options;center&&(xMatrix.center("column"),yIsSame||yMatrix.center("column")),scale&&(xMatrix.scale("column"),yIsSame||yMatrix.scale("column"));const sdx=xMatrix.standardDeviation("column",{unbiased:!0}),sdy=yIsSame?sdx:yMatrix.standardDeviation("column",{unbiased:!0}),corr=xMatrix.transpose().mmul(yMatrix);for(let i=0;i<corr.rows;i++)for(let j=0;j<corr.columns;j++)corr.set(i,j,corr.get(i,j)*(1/(sdx[i]*sdy[j]))*(1/(xMatrix.rows-1)));return corr}class EigenvalueDecomposition{constructor(matrix,options={}){const{assumeSymmetric=!1}=options;if(matrix=WrapperMatrix2D.checkMatrix(matrix),!matrix.isSquare())throw new Error("Matrix is not a square matrix");if(matrix.isEmpty())throw new Error("Matrix must be non-empty");let n=matrix.columns,V=new Matrix(n,n),d=new Float64Array(n),e=new Float64Array(n),value=matrix,i,j,isSymmetric=!1;if(assumeSymmetric?isSymmetric=!0:isSymmetric=matrix.isSymmetric(),isSymmetric){for(i=0;i<n;i++)for(j=0;j<n;j++)V.set(i,j,value.get(i,j));tred2(n,e,d,V),tql2(n,e,d,V)}else{let H=new Matrix(n,n),ort=new Float64Array(n);for(j=0;j<n;j++)for(i=0;i<n;i++)H.set(i,j,value.get(i,j));orthes(n,H,ort,V),hqr2(n,e,d,V,H)}this.n=n,this.e=e,this.d=d,this.V=V}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let n=this.n,e=this.e,d=this.d,X=new Matrix(n,n),i,j;for(i=0;i<n;i++){for(j=0;j<n;j++)X.set(i,j,0);X.set(i,i,d[i]),e[i]>0?X.set(i,i+1,e[i]):e[i]<0&&X.set(i,i-1,e[i])}return X}}function tred2(n,e,d,V){let f,g,h,i,j,k,hh,scale;for(j=0;j<n;j++)d[j]=V.get(n-1,j);for(i=n-1;i>0;i--){for(scale=0,h=0,k=0;k<i;k++)scale=scale+Math.abs(d[k]);if(scale===0)for(e[i]=d[i-1],j=0;j<i;j++)d[j]=V.get(i-1,j),V.set(i,j,0),V.set(j,i,0);else{for(k=0;k<i;k++)d[k]/=scale,h+=d[k]*d[k];for(f=d[i-1],g=Math.sqrt(h),f>0&&(g=-g),e[i]=scale*g,h=h-f*g,d[i-1]=f-g,j=0;j<i;j++)e[j]=0;for(j=0;j<i;j++){for(f=d[j],V.set(j,i,f),g=e[j]+V.get(j,j)*f,k=j+1;k<=i-1;k++)g+=V.get(k,j)*d[k],e[k]+=V.get(k,j)*f;e[j]=g}for(f=0,j=0;j<i;j++)e[j]/=h,f+=e[j]*d[j];for(hh=f/(h+h),j=0;j<i;j++)e[j]-=hh*d[j];for(j=0;j<i;j++){for(f=d[j],g=e[j],k=j;k<=i-1;k++)V.set(k,j,V.get(k,j)-(f*e[k]+g*d[k]));d[j]=V.get(i-1,j),V.set(i,j,0)}}d[i]=h}for(i=0;i<n-1;i++){if(V.set(n-1,i,V.get(i,i)),V.set(i,i,1),h=d[i+1],h!==0){for(k=0;k<=i;k++)d[k]=V.get(k,i+1)/h;for(j=0;j<=i;j++){for(g=0,k=0;k<=i;k++)g+=V.get(k,i+1)*V.get(k,j);for(k=0;k<=i;k++)V.set(k,j,V.get(k,j)-g*d[k])}}for(k=0;k<=i;k++)V.set(k,i+1,0)}for(j=0;j<n;j++)d[j]=V.get(n-1,j),V.set(n-1,j,0);V.set(n-1,n-1,1),e[0]=0}function tql2(n,e,d,V){let g,h,i,j,k,l,m,p,r,dl1,c,c2,c3,el1,s,s2;for(i=1;i<n;i++)e[i-1]=e[i];e[n-1]=0;let f=0,tst1=0,eps=Number.EPSILON;for(l=0;l<n;l++){for(tst1=Math.max(tst1,Math.abs(d[l])+Math.abs(e[l])),m=l;m<n&&!(Math.abs(e[m])<=eps*tst1);)m++;if(m>l)do{for(g=d[l],p=(d[l+1]-g)/(2*e[l]),r=hypotenuse(p,1),p<0&&(r=-r),d[l]=e[l]/(p+r),d[l+1]=e[l]*(p+r),dl1=d[l+1],h=g-d[l],i=l+2;i<n;i++)d[i]-=h;for(f=f+h,p=d[m],c=1,c2=c,c3=c,el1=e[l+1],s=0,s2=0,i=m-1;i>=l;i--)for(c3=c2,c2=c,s2=s,g=c*e[i],h=c*p,r=hypotenuse(p,e[i]),e[i+1]=s*r,s=e[i]/r,c=p/r,p=c*d[i]-s*g,d[i+1]=h+s*(c*g+s*d[i]),k=0;k<n;k++)h=V.get(k,i+1),V.set(k,i+1,s*V.get(k,i)+c*h),V.set(k,i,c*V.get(k,i)-s*h);p=-s*s2*c3*el1*e[l]/dl1,e[l]=s*p,d[l]=c*p}while(Math.abs(e[l])>eps*tst1);d[l]=d[l]+f,e[l]=0}for(i=0;i<n-1;i++){for(k=i,p=d[i],j=i+1;j<n;j++)d[j]<p&&(k=j,p=d[j]);if(k!==i)for(d[k]=d[i],d[i]=p,j=0;j<n;j++)p=V.get(j,i),V.set(j,i,V.get(j,k)),V.set(j,k,p)}}function orthes(n,H,ort,V){let low=0,high=n-1,f,g,h,i,j,m,scale;for(m=low+1;m<=high-1;m++){for(scale=0,i=m;i<=high;i++)scale=scale+Math.abs(H.get(i,m-1));if(scale!==0){for(h=0,i=high;i>=m;i--)ort[i]=H.get(i,m-1)/scale,h+=ort[i]*ort[i];for(g=Math.sqrt(h),ort[m]>0&&(g=-g),h=h-ort[m]*g,ort[m]=ort[m]-g,j=m;j<n;j++){for(f=0,i=high;i>=m;i--)f+=ort[i]*H.get(i,j);for(f=f/h,i=m;i<=high;i++)H.set(i,j,H.get(i,j)-f*ort[i])}for(i=0;i<=high;i++){for(f=0,j=high;j>=m;j--)f+=ort[j]*H.get(i,j);for(f=f/h,j=m;j<=high;j++)H.set(i,j,H.get(i,j)-f*ort[j])}ort[m]=scale*ort[m],H.set(m,m-1,scale*g)}}for(i=0;i<n;i++)for(j=0;j<n;j++)V.set(i,j,i===j?1:0);for(m=high-1;m>=low+1;m--)if(H.get(m,m-1)!==0){for(i=m+1;i<=high;i++)ort[i]=H.get(i,m-1);for(j=m;j<=high;j++){for(g=0,i=m;i<=high;i++)g+=ort[i]*V.get(i,j);for(g=g/ort[m]/H.get(m,m-1),i=m;i<=high;i++)V.set(i,j,V.get(i,j)+g*ort[i])}}}function hqr2(nn,e,d,V,H){let n=nn-1,low=0,high=nn-1,eps=Number.EPSILON,exshift=0,norm=0,p=0,q=0,r=0,s=0,z=0,iter=0,i,j,k,l,m,t,w,x,y,ra,sa,vr,vi,notlast,cdivres;for(i=0;i<nn;i++)for((i<low||i>high)&&(d[i]=H.get(i,i),e[i]=0),j=Math.max(i-1,0);j<nn;j++)norm=norm+Math.abs(H.get(i,j));for(;n>=low;){for(l=n;l>low&&(s=Math.abs(H.get(l-1,l-1))+Math.abs(H.get(l,l)),s===0&&(s=norm),!(Math.abs(H.get(l,l-1))<eps*s));)l--;if(l===n)H.set(n,n,H.get(n,n)+exshift),d[n]=H.get(n,n),e[n]=0,n--,iter=0;else if(l===n-1){if(w=H.get(n,n-1)*H.get(n-1,n),p=(H.get(n-1,n-1)-H.get(n,n))/2,q=p*p+w,z=Math.sqrt(Math.abs(q)),H.set(n,n,H.get(n,n)+exshift),H.set(n-1,n-1,H.get(n-1,n-1)+exshift),x=H.get(n,n),q>=0){for(z=p>=0?p+z:p-z,d[n-1]=x+z,d[n]=d[n-1],z!==0&&(d[n]=x-w/z),e[n-1]=0,e[n]=0,x=H.get(n,n-1),s=Math.abs(x)+Math.abs(z),p=x/s,q=z/s,r=Math.sqrt(p*p+q*q),p=p/r,q=q/r,j=n-1;j<nn;j++)z=H.get(n-1,j),H.set(n-1,j,q*z+p*H.get(n,j)),H.set(n,j,q*H.get(n,j)-p*z);for(i=0;i<=n;i++)z=H.get(i,n-1),H.set(i,n-1,q*z+p*H.get(i,n)),H.set(i,n,q*H.get(i,n)-p*z);for(i=low;i<=high;i++)z=V.get(i,n-1),V.set(i,n-1,q*z+p*V.get(i,n)),V.set(i,n,q*V.get(i,n)-p*z)}else d[n-1]=x+p,d[n]=x+p,e[n-1]=z,e[n]=-z;n=n-2,iter=0}else{if(x=H.get(n,n),y=0,w=0,l<n&&(y=H.get(n-1,n-1),w=H.get(n,n-1)*H.get(n-1,n)),iter===10){for(exshift+=x,i=low;i<=n;i++)H.set(i,i,H.get(i,i)-x);s=Math.abs(H.get(n,n-1))+Math.abs(H.get(n-1,n-2)),x=y=.75*s,w=-.4375*s*s}if(iter===30&&(s=(y-x)/2,s=s*s+w,s>0)){for(s=Math.sqrt(s),y<x&&(s=-s),s=x-w/((y-x)/2+s),i=low;i<=n;i++)H.set(i,i,H.get(i,i)-s);exshift+=s,x=y=w=.964}for(iter=iter+1,m=n-2;m>=l&&(z=H.get(m,m),r=x-z,s=y-z,p=(r*s-w)/H.get(m+1,m)+H.get(m,m+1),q=H.get(m+1,m+1)-z-r-s,r=H.get(m+2,m+1),s=Math.abs(p)+Math.abs(q)+Math.abs(r),p=p/s,q=q/s,r=r/s,!(m===l||Math.abs(H.get(m,m-1))*(Math.abs(q)+Math.abs(r))<eps*(Math.abs(p)*(Math.abs(H.get(m-1,m-1))+Math.abs(z)+Math.abs(H.get(m+1,m+1))))));)m--;for(i=m+2;i<=n;i++)H.set(i,i-2,0),i>m+2&&H.set(i,i-3,0);for(k=m;k<=n-1&&(notlast=k!==n-1,k!==m&&(p=H.get(k,k-1),q=H.get(k+1,k-1),r=notlast?H.get(k+2,k-1):0,x=Math.abs(p)+Math.abs(q)+Math.abs(r),x!==0&&(p=p/x,q=q/x,r=r/x)),x!==0);k++)if(s=Math.sqrt(p*p+q*q+r*r),p<0&&(s=-s),s!==0){for(k!==m?H.set(k,k-1,-s*x):l!==m&&H.set(k,k-1,-H.get(k,k-1)),p=p+s,x=p/s,y=q/s,z=r/s,q=q/p,r=r/p,j=k;j<nn;j++)p=H.get(k,j)+q*H.get(k+1,j),notlast&&(p=p+r*H.get(k+2,j),H.set(k+2,j,H.get(k+2,j)-p*z)),H.set(k,j,H.get(k,j)-p*x),H.set(k+1,j,H.get(k+1,j)-p*y);for(i=0;i<=Math.min(n,k+3);i++)p=x*H.get(i,k)+y*H.get(i,k+1),notlast&&(p=p+z*H.get(i,k+2),H.set(i,k+2,H.get(i,k+2)-p*r)),H.set(i,k,H.get(i,k)-p),H.set(i,k+1,H.get(i,k+1)-p*q);for(i=low;i<=high;i++)p=x*V.get(i,k)+y*V.get(i,k+1),notlast&&(p=p+z*V.get(i,k+2),V.set(i,k+2,V.get(i,k+2)-p*r)),V.set(i,k,V.get(i,k)-p),V.set(i,k+1,V.get(i,k+1)-p*q)}}}if(norm!==0){for(n=nn-1;n>=0;n--)if(p=d[n],q=e[n],q===0)for(l=n,H.set(n,n,1),i=n-1;i>=0;i--){for(w=H.get(i,i)-p,r=0,j=l;j<=n;j++)r=r+H.get(i,j)*H.get(j,n);if(e[i]<0)z=w,s=r;else if(l=i,e[i]===0?H.set(i,n,w!==0?-r/w:-r/(eps*norm)):(x=H.get(i,i+1),y=H.get(i+1,i),q=(d[i]-p)*(d[i]-p)+e[i]*e[i],t=(x*s-z*r)/q,H.set(i,n,t),H.set(i+1,n,Math.abs(x)>Math.abs(z)?(-r-w*t)/x:(-s-y*t)/z)),t=Math.abs(H.get(i,n)),eps*t*t>1)for(j=i;j<=n;j++)H.set(j,n,H.get(j,n)/t)}else if(q<0)for(l=n-1,Math.abs(H.get(n,n-1))>Math.abs(H.get(n-1,n))?(H.set(n-1,n-1,q/H.get(n,n-1)),H.set(n-1,n,-(H.get(n,n)-p)/H.get(n,n-1))):(cdivres=cdiv(0,-H.get(n-1,n),H.get(n-1,n-1)-p,q),H.set(n-1,n-1,cdivres[0]),H.set(n-1,n,cdivres[1])),H.set(n,n-1,0),H.set(n,n,1),i=n-2;i>=0;i--){for(ra=0,sa=0,j=l;j<=n;j++)ra=ra+H.get(i,j)*H.get(j,n-1),sa=sa+H.get(i,j)*H.get(j,n);if(w=H.get(i,i)-p,e[i]<0)z=w,r=ra,s=sa;else if(l=i,e[i]===0?(cdivres=cdiv(-ra,-sa,w,q),H.set(i,n-1,cdivres[0]),H.set(i,n,cdivres[1])):(x=H.get(i,i+1),y=H.get(i+1,i),vr=(d[i]-p)*(d[i]-p)+e[i]*e[i]-q*q,vi=(d[i]-p)*2*q,vr===0&&vi===0&&(vr=eps*norm*(Math.abs(w)+Math.abs(q)+Math.abs(x)+Math.abs(y)+Math.abs(z))),cdivres=cdiv(x*r-z*ra+q*sa,x*s-z*sa-q*ra,vr,vi),H.set(i,n-1,cdivres[0]),H.set(i,n,cdivres[1]),Math.abs(x)>Math.abs(z)+Math.abs(q)?(H.set(i+1,n-1,(-ra-w*H.get(i,n-1)+q*H.get(i,n))/x),H.set(i+1,n,(-sa-w*H.get(i,n)-q*H.get(i,n-1))/x)):(cdivres=cdiv(-r-y*H.get(i,n-1),-s-y*H.get(i,n),z,q),H.set(i+1,n-1,cdivres[0]),H.set(i+1,n,cdivres[1]))),t=Math.max(Math.abs(H.get(i,n-1)),Math.abs(H.get(i,n))),eps*t*t>1)for(j=i;j<=n;j++)H.set(j,n-1,H.get(j,n-1)/t),H.set(j,n,H.get(j,n)/t)}for(i=0;i<nn;i++)if(i<low||i>high)for(j=i;j<nn;j++)V.set(i,j,H.get(i,j));for(j=nn-1;j>=low;j--)for(i=low;i<=high;i++){for(z=0,k=low;k<=Math.min(j,high);k++)z=z+V.get(i,k)*H.get(k,j);V.set(i,j,z)}}}function cdiv(xr,xi,yr,yi){let r,d;return Math.abs(yr)>Math.abs(yi)?(r=yi/yr,d=yr+r*yi,[(xr+r*xi)/d,(xi-r*xr)/d]):(r=yr/yi,d=yi+r*yr,[(r*xr+xi)/d,(r*xi-xr)/d])}class CholeskyDecomposition{constructor(value){if(value=WrapperMatrix2D.checkMatrix(value),!value.isSymmetric())throw new Error("Matrix is not symmetric");let a=value,dimension=a.rows,l=new Matrix(dimension,dimension),positiveDefinite=!0,i,j,k;for(j=0;j<dimension;j++){let d=0;for(k=0;k<j;k++){let s=0;for(i=0;i<k;i++)s+=l.get(k,i)*l.get(j,i);s=(a.get(j,k)-s)/l.get(k,k),l.set(j,k,s),d=d+s*s}for(d=a.get(j,j)-d,positiveDefinite&=d>0,l.set(j,j,Math.sqrt(Math.max(d,0))),k=j+1;k<dimension;k++)l.set(j,k,0)}this.L=l,this.positiveDefinite=Boolean(positiveDefinite)}isPositiveDefinite(){return this.positiveDefinite}solve(value){value=WrapperMatrix2D.checkMatrix(value);let l=this.L,dimension=l.rows;if(value.rows!==dimension)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let count=value.columns,B=value.clone(),i,j,k;for(k=0;k<dimension;k++)for(j=0;j<count;j++){for(i=0;i<k;i++)B.set(k,j,B.get(k,j)-B.get(i,j)*l.get(k,i));B.set(k,j,B.get(k,j)/l.get(k,k))}for(k=dimension-1;k>=0;k--)for(j=0;j<count;j++){for(i=k+1;i<dimension;i++)B.set(k,j,B.get(k,j)-B.get(i,j)*l.get(i,k));B.set(k,j,B.get(k,j)/l.get(k,k))}return B}get lowerTriangularMatrix(){return this.L}}class nipals{constructor(X,options={}){X=WrapperMatrix2D.checkMatrix(X);let{Y}=options;const{scaleScores=!1,maxIterations=1e3,terminationCriteria=1e-10}=options;let u;if(Y){if(Array.isArray(Y)&&typeof Y[0]=="number"?Y=Matrix.columnVector(Y):Y=WrapperMatrix2D.checkMatrix(Y),Y.rows!==X.rows)throw new Error("Y should have the same number of rows as X");u=Y.getColumnVector(0)}else u=X.getColumnVector(0);let diff=1,t,q,w,tOld;for(let counter=0;counter<maxIterations&&diff>terminationCriteria;counter++)w=X.transpose().mmul(u).div(u.transpose().mmul(u).get(0,0)),w=w.div(w.norm()),t=X.mmul(w).div(w.transpose().mmul(w).get(0,0)),counter>0&&(diff=t.clone().sub(tOld).pow(2).sum()),tOld=t.clone(),Y?(q=Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0,0)),q=q.div(q.norm()),u=Y.mmul(q).div(q.transpose().mmul(q).get(0,0))):u=t;if(Y){let p=X.transpose().mmul(t).div(t.transpose().mmul(t).get(0,0));p=p.div(p.norm());let xResidual=X.clone().sub(t.clone().mmul(p.transpose())),residual=u.transpose().mmul(t).div(t.transpose().mmul(t).get(0,0)),yResidual=Y.clone().sub(t.clone().mulS(residual.get(0,0)).mmul(q.transpose()));this.t=t,this.p=p.transpose(),this.w=w.transpose(),this.q=q,this.u=u,this.s=t.transpose().mmul(t),this.xResidual=xResidual,this.yResidual=yResidual,this.betas=residual}else this.w=w.transpose(),this.s=t.transpose().mmul(t).sqrt(),scaleScores?this.t=t.clone().div(this.s.get(0,0)):this.t=t,this.xResidual=X.sub(t.mmul(w.transpose()))}}exports.AbstractMatrix=AbstractMatrix,exports.CHO=CholeskyDecomposition,exports.CholeskyDecomposition=CholeskyDecomposition,exports.EVD=EigenvalueDecomposition,exports.EigenvalueDecomposition=EigenvalueDecomposition,exports.LU=LuDecomposition,exports.LuDecomposition=LuDecomposition,exports.Matrix=Matrix,exports.MatrixColumnSelectionView=MatrixColumnSelectionView,exports.MatrixColumnView=MatrixColumnView,exports.MatrixFlipColumnView=MatrixFlipColumnView,exports.MatrixFlipRowView=MatrixFlipRowView,exports.MatrixRowSelectionView=MatrixRowSelectionView,exports.MatrixRowView=MatrixRowView,exports.MatrixSelectionView=MatrixSelectionView,exports.MatrixSubView=MatrixSubView,exports.MatrixTransposeView=MatrixTransposeView,exports.NIPALS=nipals,exports.Nipals=nipals,exports.QR=QrDecomposition,exports.QrDecomposition=QrDecomposition,exports.SVD=SingularValueDecomposition,exports.SingularValueDecomposition=SingularValueDecomposition,exports.WrapperMatrix1D=WrapperMatrix1D,exports.WrapperMatrix2D=WrapperMatrix2D,exports.correlation=correlation,exports.covariance=covariance,exports.default=Matrix,exports.determinant=determinant,exports.inverse=inverse,exports.linearDependencies=linearDependencies,exports.pseudoInverse=pseudoInverse,exports.solve=solve,exports.wrap=wrap}}]);

//# sourceMappingURL=8406.a96974de.chunk.js.map
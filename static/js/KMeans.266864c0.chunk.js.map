{"version":3,"file":"static/js/KMeans.266864c0.chunk.js","mappings":"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","sources":["../node_modules/ml-distance-euclidean/lib-es6/euclidean.js","../node_modules/ml-nearest-vector/lib-es6/index.js","../node_modules/ml-kmeans/src/utils.js","../node_modules/ml-xsadd/lib-es6/xsadd.js","../node_modules/ml-random/lib-es6/choice.js","../node_modules/ml-random/lib-es6/index.js","../node_modules/ml-kmeans/src/initialization.js","../node_modules/ml-kmeans/src/KMeansResult.js","../node_modules/ml-kmeans/src/kmeans.js","../node_modules/@isle-project/components/models/kmeans/main.js"],"sourcesContent":["export function squaredEuclidean(p, q) {\n  var d = 0;\n\n  for (var i = 0; i < p.length; i++) {\n    d += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n\n  return d;\n}\nexport function euclidean(p, q) {\n  return Math.sqrt(squaredEuclidean(p, q));\n}","'use strict';\n\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nvar defaultOptions = {\n  distanceFunction: squaredEuclidean\n};\nexport default function nearestVector(listVectors, vector) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  var distanceFunction = options.distanceFunction || defaultOptions.distanceFunction;\n  var similarityFunction = options.similarityFunction || defaultOptions.similarityFunction;\n  var vectorIndex = -1;\n\n  if (typeof similarityFunction === 'function') {\n    // maximum similarity\n    var maxSim = Number.MIN_VALUE;\n\n    for (var j = 0; j < listVectors.length; j++) {\n      var sim = similarityFunction(vector, listVectors[j]);\n\n      if (sim > maxSim) {\n        maxSim = sim;\n        vectorIndex = j;\n      }\n    }\n  } else if (typeof distanceFunction === 'function') {\n    // minimum distance\n    var minDist = Number.MAX_VALUE;\n\n    for (var i = 0; i < listVectors.length; i++) {\n      var dist = distanceFunction(vector, listVectors[i]);\n\n      if (dist < minDist) {\n        minDist = dist;\n        vectorIndex = i;\n      }\n    }\n  } else {\n    throw new Error(\"A similarity or distance function it's required\");\n  }\n\n  return vectorIndex;\n}\nexport function findNearestVector(vectorList, vector) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  var index = nearestVector(vectorList, vector, options);\n  return vectorList[index];\n}","import nearestVector from 'ml-nearest-vector';\n/**\n * Calculates the distance matrix for a given array of points\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {function} distance - Distance function to use between the points\n * @return {Array<Array<number>>} - matrix with the distance values\n */\n\nexport function calculateDistanceMatrix(data, distance) {\n  var distanceMatrix = new Array(data.length);\n\n  for (var i = 0; i < data.length; ++i) {\n    for (var j = i; j < data.length; ++j) {\n      if (!distanceMatrix[i]) {\n        distanceMatrix[i] = new Array(data.length);\n      }\n\n      if (!distanceMatrix[j]) {\n        distanceMatrix[j] = new Array(data.length);\n      }\n\n      var dist = distance(data[i], data[j]);\n      distanceMatrix[i][j] = dist;\n      distanceMatrix[j][i] = dist;\n    }\n  }\n\n  return distanceMatrix;\n}\n/**\n * Updates the cluster identifier based in the new data\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {function} distance - Distance function to use between the points\n * @return {Array} the cluster identifier for each data dot\n */\n\nexport function updateClusterID(data, centers, clusterID, distance) {\n  for (var i = 0; i < data.length; i++) {\n    clusterID[i] = nearestVector(centers, data[i], {\n      distanceFunction: distance\n    });\n  }\n\n  return clusterID;\n}\n/**\n * Update the center values based in the new configurations of the clusters\n * @ignore\n * @param {Array<Array<number>>} prevCenters - Centroids from the previous iteration\n * @param {Array <Array <number>>} data - the [x,y,z,...] points to cluster\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @return {Array} he K centers in format [x,y,z,...]\n */\n\nexport function updateCenters(prevCenters, data, clusterID, K) {\n  var nDim = data[0].length; // copy previous centers\n\n  var centers = new Array(K);\n  var centersLen = new Array(K);\n\n  for (var i = 0; i < K; i++) {\n    centers[i] = new Array(nDim);\n    centersLen[i] = 0;\n\n    for (var j = 0; j < nDim; j++) {\n      centers[i][j] = 0;\n    }\n  } // add the value for all dimensions of the point\n\n\n  for (var l = 0; l < data.length; l++) {\n    centersLen[clusterID[l]]++;\n\n    for (var dim = 0; dim < nDim; dim++) {\n      centers[clusterID[l]][dim] += data[l][dim];\n    }\n  } // divides by length\n\n\n  for (var id = 0; id < K; id++) {\n    for (var d = 0; d < nDim; d++) {\n      if (centersLen[id]) {\n        centers[id][d] /= centersLen[id];\n      } else {\n        centers[id][d] = prevCenters[id][d];\n      }\n    }\n  }\n\n  return centers;\n}\n/**\n * The centers have moved more than the tolerance value?\n * @ignore\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} oldCenters - the K old centers in format [x,y,z,...]\n * @param {function} distanceFunction - Distance function to use between the points\n * @param {number} tolerance - Allowed distance for the centroids to move\n * @return {boolean}\n */\n\nexport function hasConverged(centers, oldCenters, distanceFunction, tolerance) {\n  for (var i = 0; i < centers.length; i++) {\n    if (distanceFunction(centers[i], oldCenters[i]) > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}","import _classCallCheck from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nvar LOOP = 8;\nvar FLOAT_MUL = 1 / 16777216;\nvar sh1 = 15;\nvar sh2 = 18;\nvar sh3 = 11;\n\nfunction multiply_uint32(n, m) {\n  n >>>= 0;\n  m >>>= 0;\n  var nlo = n & 0xffff;\n  var nhi = n - nlo;\n  return (nhi * m >>> 0) + nlo * m >>> 0;\n}\n\nvar XSadd = /*#__PURE__*/function () {\n  function XSadd() {\n    var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n\n    _classCallCheck(this, XSadd);\n\n    this.state = new Uint32Array(4);\n    this.init(seed);\n    this.random = this.getFloat.bind(this);\n  }\n  /**\n   * Returns a 32-bit integer r (0 <= r < 2^32)\n   */\n\n\n  _createClass(XSadd, [{\n    key: \"getUint32\",\n    value: function getUint32() {\n      this.nextState();\n      return this.state[3] + this.state[2] >>> 0;\n    }\n    /**\n     * Returns a floating point number r (0.0 <= r < 1.0)\n     */\n\n  }, {\n    key: \"getFloat\",\n    value: function getFloat() {\n      return (this.getUint32() >>> 8) * FLOAT_MUL;\n    }\n  }, {\n    key: \"init\",\n    value: function init(seed) {\n      if (!Number.isInteger(seed)) {\n        throw new TypeError('seed must be an integer');\n      }\n\n      this.state[0] = seed;\n      this.state[1] = 0;\n      this.state[2] = 0;\n      this.state[3] = 0;\n\n      for (var i = 1; i < LOOP; i++) {\n        this.state[i & 3] ^= i + multiply_uint32(1812433253, this.state[i - 1 & 3] ^ this.state[i - 1 & 3] >>> 30 >>> 0) >>> 0;\n      }\n\n      this.periodCertification();\n\n      for (var _i = 0; _i < LOOP; _i++) {\n        this.nextState();\n      }\n    }\n  }, {\n    key: \"periodCertification\",\n    value: function periodCertification() {\n      if (this.state[0] === 0 && this.state[1] === 0 && this.state[2] === 0 && this.state[3] === 0) {\n        this.state[0] = 88; // X\n\n        this.state[1] = 83; // S\n\n        this.state[2] = 65; // A\n\n        this.state[3] = 68; // D\n      }\n    }\n  }, {\n    key: \"nextState\",\n    value: function nextState() {\n      var t = this.state[0];\n      t ^= t << sh1;\n      t ^= t >>> sh2;\n      t ^= this.state[3] << sh3;\n      this.state[0] = this.state[1];\n      this.state[1] = this.state[2];\n      this.state[2] = this.state[3];\n      this.state[3] = t;\n    }\n  }]);\n\n  return XSadd;\n}();\n\nexport { XSadd as default };","var PROB_TOLERANCE = 0.00000001;\n\nfunction randomChoice(values) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var random = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.random;\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 1 : _options$size,\n      _options$replace = options.replace,\n      replace = _options$replace === void 0 ? false : _options$replace,\n      probabilities = options.probabilities;\n  var valuesArr;\n  var cumSum;\n\n  if (typeof values === 'number') {\n    valuesArr = getArray(values);\n  } else {\n    valuesArr = values.slice();\n  }\n\n  if (probabilities) {\n    if (!replace) {\n      throw new Error('choice with probabilities and no replacement is not implemented');\n    } // check input is sane\n\n\n    if (probabilities.length !== valuesArr.length) {\n      throw new Error('the length of probabilities option should be equal to the number of choices');\n    }\n\n    cumSum = [probabilities[0]];\n\n    for (var i = 1; i < probabilities.length; i++) {\n      cumSum[i] = cumSum[i - 1] + probabilities[i];\n    }\n\n    if (Math.abs(1 - cumSum[cumSum.length - 1]) > PROB_TOLERANCE) {\n      throw new Error(\"probabilities should sum to 1, but instead sums to \".concat(cumSum[cumSum.length - 1]));\n    }\n  }\n\n  if (replace === false && size > valuesArr.length) {\n    throw new Error('size option is too large');\n  }\n\n  var result = [];\n\n  for (var _i = 0; _i < size; _i++) {\n    var index = randomIndex(valuesArr.length, random, cumSum);\n    result.push(valuesArr[index]);\n\n    if (!replace) {\n      valuesArr.splice(index, 1);\n    }\n  }\n\n  return result;\n}\n\nfunction getArray(n) {\n  var arr = [];\n\n  for (var i = 0; i < n; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n}\n\nfunction randomIndex(n, random, cumSum) {\n  var rand = random();\n\n  if (!cumSum) {\n    return Math.floor(rand * n);\n  } else {\n    var idx = 0;\n\n    while (rand > cumSum[idx]) {\n      idx++;\n    }\n\n    return idx;\n  }\n}\n\nexport default randomChoice;","import _classCallCheck from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// tslint:disable-next-line\nimport XSAdd from 'ml-xsadd';\nimport _choice from './choice';\n/**\n * @classdesc Random class\n */\n\nvar Random = /*#__PURE__*/function () {\n  /**\n   * @param [seedOrRandom=Math.random] - Control the random number generator used by the Random class instance. Pass a random number generator function with a uniform distribution over the half-open interval [0, 1[. If seed will pass it to ml-xsadd to create a seeded random number generator. If undefined will use Math.random.\n   */\n  function Random() {\n    var seedOrRandom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.random;\n\n    _classCallCheck(this, Random);\n\n    if (typeof seedOrRandom === 'number') {\n      var xsadd = new XSAdd(seedOrRandom);\n      this.randomGenerator = xsadd.random;\n    } else {\n      this.randomGenerator = seedOrRandom;\n    }\n  }\n\n  _createClass(Random, [{\n    key: \"choice\",\n    value: function choice(values, options) {\n      if (typeof values === 'number') {\n        return _choice(values, options, this.randomGenerator);\n      }\n\n      return _choice(values, options, this.randomGenerator);\n    }\n    /**\n     * Draw a random number from a uniform distribution on [0,1)\n     * @return The random number\n     */\n\n  }, {\n    key: \"random\",\n    value: function random() {\n      return this.randomGenerator();\n    }\n    /**\n     * Draw a random integer from a uniform distribution on [low, high). If only low is specified, the number is drawn on [0, low)\n     * @param low - The lower bound of the uniform distribution interval.\n     * @param high - The higher bound of the uniform distribution interval.\n     */\n\n  }, {\n    key: \"randInt\",\n    value: function randInt(low, high) {\n      if (high === undefined) {\n        high = low;\n        low = 0;\n      }\n\n      return low + Math.floor(this.randomGenerator() * (high - low));\n    }\n    /**\n     * Draw several random number from a uniform distribution on [0, 1)\n     * @param size - The number of number to draw\n     * @return - The list of drawn numbers.\n     */\n\n  }, {\n    key: \"randomSample\",\n    value: function randomSample(size) {\n      var result = [];\n\n      for (var i = 0; i < size; i++) {\n        result.push(this.random());\n      }\n\n      return result;\n    }\n  }]);\n\n  return Random;\n}();\n\nexport { Random as default };","import Random from 'ml-random';\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nimport { Matrix } from 'ml-matrix';\n/**\n * Choose K different random points from the original data\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\n\nexport function random(data, K, seed) {\n  var random = new Random(seed);\n  return random.choice(data, {\n    size: K\n  });\n}\n/**\n * Chooses the most distant points to a first random pick\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {Array<Array<number>>} distanceMatrix - matrix with the distance values\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\n\nexport function mostDistant(data, K, distanceMatrix, seed) {\n  var random = new Random(seed);\n  var ans = new Array(K); // chooses a random point as initial cluster\n\n  ans[0] = Math.floor(random.random() * data.length);\n\n  if (K > 1) {\n    // chooses the more distant point\n    var maxDist = {\n      dist: -1,\n      index: -1\n    };\n\n    for (var l = 0; l < data.length; ++l) {\n      if (distanceMatrix[ans[0]][l] > maxDist.dist) {\n        maxDist.dist = distanceMatrix[ans[0]][l];\n        maxDist.index = l;\n      }\n    }\n\n    ans[1] = maxDist.index;\n\n    if (K > 2) {\n      // chooses the set of points that maximises the min distance\n      for (var k = 2; k < K; ++k) {\n        var center = {\n          dist: -1,\n          index: -1\n        };\n\n        for (var m = 0; m < data.length; ++m) {\n          // minimum distance to centers\n          var minDistCent = {\n            dist: Number.MAX_VALUE,\n            index: -1\n          };\n\n          for (var n = 0; n < k; ++n) {\n            if (distanceMatrix[n][m] < minDistCent.dist && ans.indexOf(m) === -1) {\n              minDistCent = {\n                dist: distanceMatrix[n][m],\n                index: m\n              };\n            }\n          }\n\n          if (minDistCent.dist !== Number.MAX_VALUE && minDistCent.dist > center.dist) {\n            center = Object.assign({}, minDistCent);\n          }\n        }\n\n        ans[k] = center.index;\n      }\n    }\n  }\n\n  return ans.map(function (index) {\n    return data[index];\n  });\n} // Implementation inspired from scikit\n\nexport function kmeanspp(X, K) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  X = new Matrix(X);\n  var nSamples = X.rows;\n  var random = new Random(options.seed); // Set the number of trials\n\n  var centers = [];\n  var localTrials = options.localTrials || 2 + Math.floor(Math.log(K)); // Pick the first center at random from the dataset\n\n  var firstCenterIdx = random.randInt(nSamples);\n  centers.push(X.getRow(firstCenterIdx)); // Init closest distances\n\n  var closestDistSquared = new Matrix(1, X.rows);\n\n  for (var i = 0; i < X.rows; i++) {\n    closestDistSquared.set(0, i, squaredEuclidean(X.getRow(i), centers[0]));\n  }\n\n  var cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n  var factor = 1 / cumSumClosestDistSquared[0][nSamples - 1];\n  var probabilities = Matrix.mul(closestDistSquared, factor); // Iterate over the remaining centers\n\n  for (var _i = 1; _i < K; _i++) {\n    var candidateIdx = random.choice(nSamples, {\n      replace: true,\n      size: localTrials,\n      probabilities: probabilities[0]\n    });\n    var candidates = X.selection(candidateIdx, range(X.columns));\n    var distanceToCandidates = euclideanDistances(candidates, X);\n    var bestCandidate = void 0;\n    var bestPot = void 0;\n    var bestDistSquared = void 0;\n\n    for (var j = 0; j < localTrials; j++) {\n      var newDistSquared = Matrix.min(closestDistSquared, [distanceToCandidates.getRow(j)]);\n      var newPot = newDistSquared.sum();\n\n      if (bestCandidate === undefined || newPot < bestPot) {\n        bestCandidate = candidateIdx[j];\n        bestPot = newPot;\n        bestDistSquared = newDistSquared;\n      }\n    }\n\n    centers[_i] = X.getRow(bestCandidate);\n    closestDistSquared = bestDistSquared;\n    cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n    probabilities = Matrix.mul(closestDistSquared, 1 / cumSumClosestDistSquared[0][nSamples - 1]);\n  }\n\n  return centers;\n}\n\nfunction euclideanDistances(A, B) {\n  var result = new Matrix(A.rows, B.rows);\n\n  for (var i = 0; i < A.rows; i++) {\n    for (var j = 0; j < B.rows; j++) {\n      result.set(i, j, squaredEuclidean(A.getRow(i), B.getRow(j)));\n    }\n  }\n\n  return result;\n}\n\nfunction range(l) {\n  var r = [];\n\n  for (var i = 0; i < l; i++) {\n    r.push(i);\n  }\n\n  return r;\n}\n\nfunction cumSum(arr) {\n  var cumSum = [arr[0]];\n\n  for (var i = 1; i < arr.length; i++) {\n    cumSum[i] = cumSum[i - 1] + arr[i];\n  }\n\n  return cumSum;\n}","import _classCallCheck from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { updateClusterID } from './utils';\nvar distanceSymbol = Symbol('distance');\n\nvar KMeansResult = /*#__PURE__*/function () {\n  /**\n   * Result of the kmeans algorithm\n   * @param {Array<number>} clusters - the cluster identifier for each data dot\n   * @param {Array<Array<object>>} centroids - the K centers in format [x,y,z,...], the error and size of the cluster\n   * @param {boolean} converged - Converge criteria satisfied\n   * @param {number} iterations - Current number of iterations\n   * @param {function} distance - (*Private*) Distance function to use between the points\n   * @constructor\n   */\n  function KMeansResult(clusters, centroids, converged, iterations, distance) {\n    _classCallCheck(this, KMeansResult);\n\n    this.clusters = clusters;\n    this.centroids = centroids;\n    this.converged = converged;\n    this.iterations = iterations;\n    this[distanceSymbol] = distance;\n  }\n  /**\n   * Allows to compute for a new array of points their cluster id\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {Array<number>} - cluster id for each point\n   */\n\n\n  _createClass(KMeansResult, [{\n    key: \"nearest\",\n    value: function nearest(data) {\n      var clusterID = new Array(data.length);\n      var centroids = this.centroids.map(function (centroid) {\n        return centroid.centroid;\n      });\n      return updateClusterID(data, centroids, clusterID, this[distanceSymbol]);\n    }\n    /**\n     * Returns a KMeansResult with the error and size of the cluster\n     * @ignore\n     * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n     * @return {KMeansResult}\n     */\n\n  }, {\n    key: \"computeInformation\",\n    value: function computeInformation(data) {\n      var enrichedCentroids = this.centroids.map(function (centroid) {\n        return {\n          centroid: centroid,\n          error: 0,\n          size: 0\n        };\n      });\n\n      for (var i = 0; i < data.length; i++) {\n        enrichedCentroids[this.clusters[i]].error += this[distanceSymbol](data[i], this.centroids[this.clusters[i]]);\n        enrichedCentroids[this.clusters[i]].size++;\n      }\n\n      for (var j = 0; j < this.centroids.length; j++) {\n        if (enrichedCentroids[j].size) {\n          enrichedCentroids[j].error /= enrichedCentroids[j].size;\n        } else {\n          enrichedCentroids[j].error = null;\n        }\n      }\n\n      return new KMeansResult(this.clusters, enrichedCentroids, this.converged, this.iterations, this[distanceSymbol]);\n    }\n  }]);\n\n  return KMeansResult;\n}();\n\nexport { KMeansResult as default };","import _regeneratorRuntime from \"/home/philipp/git/cmu-isle/isle-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(kmeansGenerator);\n\nimport { squaredEuclidean } from 'ml-distance-euclidean';\nimport { updateClusterID, updateCenters, hasConverged, calculateDistanceMatrix } from './utils';\nimport { mostDistant, random, kmeanspp } from './initialization';\nimport KMeansResult from './KMeansResult';\nvar defaultOptions = {\n  maxIterations: 100,\n  tolerance: 1e-6,\n  withIterations: false,\n  initialization: 'kmeans++',\n  distanceFunction: squaredEuclidean\n};\n/**\n * Each step operation for kmeans\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} iterations - Current number of iterations\n * @return {KMeansResult}\n */\n\nfunction step(centers, data, clusterID, K, options, iterations) {\n  clusterID = updateClusterID(data, centers, clusterID, options.distanceFunction);\n  var newCenters = updateCenters(centers, data, clusterID, K);\n  var converged = hasConverged(newCenters, centers, options.distanceFunction, options.tolerance);\n  return new KMeansResult(clusterID, newCenters, converged, iterations, options.distanceFunction);\n}\n/**\n * Generator version for the algorithm\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n */\n\n\nfunction kmeansGenerator(centers, data, clusterID, K, options) {\n  var converged, stepNumber, stepResult;\n  return _regeneratorRuntime.wrap(function kmeansGenerator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          converged = false;\n          stepNumber = 0;\n\n        case 2:\n          if (!(!converged && stepNumber < options.maxIterations)) {\n            _context.next = 10;\n            break;\n          }\n\n          stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n          _context.next = 6;\n          return stepResult.computeInformation(data);\n\n        case 6:\n          converged = stepResult.converged;\n          centers = stepResult.centroids;\n          _context.next = 2;\n          break;\n\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n/**\n * K-means algorithm\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} [options.maxIterations = 100] - Maximum of iterations allowed\n * @param {number} [options.tolerance = 1e-6] - Error tolerance\n * @param {boolean} [options.withIterations = false] - Store clusters and centroids for each iteration\n * @param {function} [options.distanceFunction = squaredDistance] - Distance function to use between the points\n * @param {number} [options.seed] - Seed for random initialization.\n * @param {string|Array<Array<number>>} [options.initialization = 'kmeans++'] - K centers in format [x,y,z,...] or a method for initialize the data:\n *  * You can either specify your custom start centroids, or select one of the following initialization method:\n *  * `'kmeans++'` will use the kmeans++ method as described by http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf\n *  * `'random'` will choose K random different values.\n *  * `'mostDistant'` will choose the more distant points to a first random pick\n * @return {KMeansResult} - Cluster identifier for each data dot and centroids with the following fields:\n *  * `'clusters'`: Array of indexes for the clusters.\n *  * `'centroids'`: Array with the resulting centroids.\n *  * `'iterations'`: Number of iterations that took to converge\n */\n\n\nexport default function kmeans(data, K, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  if (K <= 0 || K > data.length || !Number.isInteger(K)) {\n    throw new Error('K should be a positive integer smaller than the number of points');\n  }\n\n  var centers;\n\n  if (Array.isArray(options.initialization)) {\n    if (options.initialization.length !== K) {\n      throw new Error('The initial centers should have the same length as K');\n    } else {\n      centers = options.initialization;\n    }\n  } else {\n    switch (options.initialization) {\n      case 'kmeans++':\n        centers = kmeanspp(data, K, options);\n        break;\n\n      case 'random':\n        centers = random(data, K, options.seed);\n        break;\n\n      case 'mostDistant':\n        centers = mostDistant(data, K, calculateDistanceMatrix(data, options.distanceFunction), options.seed);\n        break;\n\n      default:\n        throw new Error(\"Unknown initialization method: \\\"\".concat(options.initialization, \"\\\"\"));\n    }\n  } // infinite loop until convergence\n\n\n  if (options.maxIterations === 0) {\n    options.maxIterations = Number.MAX_VALUE;\n  }\n\n  var clusterID = new Array(data.length);\n\n  if (options.withIterations) {\n    return kmeansGenerator(centers, data, clusterID, K, options);\n  } else {\n    var converged = false;\n    var stepNumber = 0;\n    var stepResult;\n\n    while (!converged && stepNumber < options.maxIterations) {\n      stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n      converged = stepResult.converged;\n      centers = stepResult.centroids;\n    }\n\n    return stepResult.computeInformation(data);\n  }\n}","// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport kmeans from 'ml-kmeans';\nimport Alert from 'react-bootstrap/Alert';\nimport hasOwnProp from '@stdlib/assert/has-own-property';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport isnan from '@stdlib/assert/is-nan';\nimport Table from '@isle-project/components/table';\nimport { withPropCheck } from '@isle-project/utils/prop-check';\n\n\n// FUNCTIONS //\n\nfunction isNonMissingNumber( x ) {\n\treturn isNumber( x ) && !isnan( x );\n}\n\nconst summaryTable = ( variables, centroids, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('cluster')}</th>\n\t\t\t\t\t{centroids.map( ( _, i ) => <th key={i} >{i+1}</th>)}\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{variables.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t{centroids.map( ( x, i ) => <td key={i} >{x.centroid[ idx ].toFixed( 4 )}</td>)}\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('size')}</th>\n\t\t\t\t\t{centroids.map( ( x, i ) => <th key={i} >{x.size}</th>)}\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nconst fitModel = ({ K, variables, data, initialization }) => {\n\tif ( !data || !variables || !K || !initialization ) {\n\t\treturn null;\n\t}\n\tconst matrix = [];\n\tif ( !hasOwnProp( data, variables[ 0 ] ) ) {\n\t\treturn null;\n\t}\n\tconst n = data[ variables[ 0 ] ].length;\n\tconst missingIds = [];\n\tfor ( let i = 0; i < n; i++ ) {\n\t\tconst row = [];\n\t\tlet missing = false;\n\t\tfor ( let j = 0; j < variables.length; j++ ) {\n\t\t\tif ( !hasOwnProp( data, variables[ j ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst val = data[ variables[ j ] ][ i ];\n\t\t\tif ( isNonMissingNumber( val ) ) {\n\t\t\t\trow.push( val );\n\t\t\t} else {\n\t\t\t\tmissing = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( !missing ) {\n\t\t\tmatrix.push( row );\n\t\t} else {\n\t\t\tmissingIds.push( i );\n\t\t}\n\t}\n\ttry {\n\t\tconst result = kmeans( matrix, K, {\n\t\t\tinitialization\n\t\t});\n\t\tfor ( let i = 0; i < missingIds.length; i++ ) {\n\t\t\tresult.clusters.splice( missingIds[ i ], 0, null );\n\t\t}\n\t\tresult.clusters = result.clusters.map( x => {\n\t\t\tif ( x === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn `Cluster ${x+1}`; // eslint-disable-line i18next/no-literal-string\n\t\t});\n\t\treturn result;\n\t} catch ( _ ) {\n\t\treturn null;\n\t}\n};\n\n\n// MAIN //\n\n/**\n* K-means clustering.\n*\n* @property {Object} data - object of value arrays\n* @property {Array<string>} variables - names of variables used for clustering\n* @property {string} initialization - initialization method (`kmeans++`, `random`, or `mostDistant`)\n* @property {number} K - number of clusters\n* @property {Function} onResult - callback invoked with model object\n*/\nclass KMeans extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\t\tconst { K, variables, data, initialization } = props;\n\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\tthis.state = {\n\t\t\tresult,\n\t\t\t...props\n\t\t};\n\t\tif ( result ) {\n\t\t\tprops.onResult( result );\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.variables !== prevState.variables ||\n\t\t\tnextProps.K !== prevState.K ||\n\t\t\tnextProps.initialization !== prevState.initialization\n\t\t) {\n\t\t\tconst { K, variables, data, initialization } = nextProps;\n\t\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\t\tnextProps.onResult( result );\n\t\t\tconst newState = {\n\t\t\t\tresult,\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t\treturn newState;\n\t\t}\n\t\treturn null;\n\t}\n\n\trender() {\n\t\tconst { result } = this.state;\n\t\tconst { t, variables } = this.props;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('kmeans-summary')}</span>\n\t\t\t\t<p>{result.converged ? t('algorithm-converged', { n: result.iterations }) : t('algorithm-not-converged', { n: result.iterations })}</p>\n\t\t\t\t{summaryTable( variables, result.centroids, t )}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nKMeans.defaultProps = {\n\tK: 3,\n\tinitialization: 'kmeans++',\n\tonResult() {}\n};\n\nKMeans.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\tvariables: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tK: PropTypes.number,\n\tinitialization: PropTypes.oneOf([ 'kmeans++', 'random', 'mostDistant' ]),\n\tonResult: PropTypes.func\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'models' )( withPropCheck( KMeans ) );\n"],"names":["squaredEuclidean","p","q","d","i","length","defaultOptions","distanceFunction","nearestVector","listVectors","vector","options","arguments","undefined","similarityFunction","vectorIndex","maxSim","Number","MIN_VALUE","j","sim","Error","minDist","MAX_VALUE","dist","updateClusterID","data","centers","clusterID","distance","XSadd","seed","Date","now","this","state","Uint32Array","init","random","getFloat","bind","key","value","nextState","getUint32","isInteger","TypeError","n","m","nlo","periodCertification","_i","t","getArray","arr","push","randomIndex","cumSum","rand","idx","Math","floor","values","valuesArr","_options$size","size","_options$replace","replace","probabilities","slice","abs","concat","result","index","splice","Random","seedOrRandom","xsadd","randomGenerator","low","high","euclideanDistances","A","B","rows","set","getRow","range","l","r","distanceSymbol","Symbol","KMeansResult","clusters","centroids","converged","iterations","Array","map","centroid","enrichedCentroids","error","_marked","kmeansGenerator","maxIterations","tolerance","withIterations","initialization","step","K","newCenters","prevCenters","nDim","centersLen","dim","id","updateCenters","oldCenters","hasConverged","stepNumber","stepResult","_context","prev","next","computeInformation","stop","kmeans","Object","assign","isArray","X","nSamples","localTrials","log","firstCenterIdx","randInt","closestDistSquared","cumSumClosestDistSquared","factor","candidateIdx","choice","distanceToCandidates","selection","columns","bestCandidate","bestPot","bestDistSquared","newDistSquared","newPot","sum","kmeanspp","distanceMatrix","ans","maxDist","k","center","minDistCent","indexOf","mostDistant","calculateDistanceMatrix","fitModel","variables","matrix","hasOwnProp","x","missingIds","row","missing","val","isNumber","isnan","_","KMeans","props","onResult","style","overflowX","width","className","bordered","name","toFixed","summaryTable","Alert","variant","nextProps","prevState","Component","defaultProps","withTranslation","withPropCheck"],"sourceRoot":""}
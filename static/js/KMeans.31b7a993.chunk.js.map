{"version":3,"sources":["../node_modules/@isle-project/components/models/kmeans/main.js","../node_modules/ml-distance-euclidean/lib/euclidean.js","../node_modules/ml-kmeans/kmeans.js","../node_modules/ml-nearest-vector/lib/index.js","../node_modules/ml-random/lib/choice.js","../node_modules/ml-random/lib/index.js","../node_modules/ml-xsadd/lib/xsadd.js"],"names":[],"mappings":"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","file":"static/js/KMeans.31b7a993.chunk.js","sourcesContent":["// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport kmeans from 'ml-kmeans';\nimport Alert from 'react-bootstrap/Alert';\nimport hasOwnProp from '@stdlib/assert/has-own-property';\nimport Table from '@isle-project/components/table';\nimport { withPropCheck } from '@isle-project/utils/prop-check';\nimport isNonMissingNumber from '@isle-project/utils/is-non-missing-number';\n\n\n// FUNCTIONS //\n\n/**\n * Returns a summary table of the cluster centers.\n *\n * @private\n * @param {Array} variables - array of variable names\n * @param {Array} centroids - array of centroid objects\n * @param {Function} t - translation function\n * @returns {Node} summary table\n */\nconst summaryTable = ( variables, centroids, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('cluster')}</th>\n\t\t\t\t\t{centroids.map( ( _, i ) => <th key={i} >{i+1}</th>)}\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{variables.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t{centroids.map( ( x, i ) => <td key={i} >{x.centroid[ idx ].toFixed( 4 )}</td>)}\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('size')}</th>\n\t\t\t\t\t{centroids.map( ( x, i ) => <th key={i} >{x.size}</th>)}\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nconst fitModel = ({ K, variables, data, initialization }) => {\n\tif ( !data || !variables || !K || !initialization ) {\n\t\treturn null;\n\t}\n\tconst matrix = [];\n\tif ( !hasOwnProp( data, variables[ 0 ] ) ) {\n\t\treturn null;\n\t}\n\tconst n = data[ variables[ 0 ] ].length;\n\tconst missingIds = [];\n\tfor ( let i = 0; i < n; i++ ) {\n\t\tconst row = [];\n\t\tlet missing = false;\n\t\tfor ( let j = 0; j < variables.length; j++ ) {\n\t\t\tif ( !hasOwnProp( data, variables[ j ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst val = data[ variables[ j ] ][ i ];\n\t\t\tif ( isNonMissingNumber( val ) ) {\n\t\t\t\trow.push( val );\n\t\t\t} else {\n\t\t\t\tmissing = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( !missing ) {\n\t\t\tmatrix.push( row );\n\t\t} else {\n\t\t\tmissingIds.push( i );\n\t\t}\n\t}\n\ttry {\n\t\tconst result = kmeans( matrix, K, {\n\t\t\tinitialization\n\t\t});\n\t\tfor ( let i = 0; i < missingIds.length; i++ ) {\n\t\t\tresult.clusters.splice( missingIds[ i ], 0, null );\n\t\t}\n\t\tresult.clusters = result.clusters.map( x => {\n\t\t\tif ( x === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn `Cluster ${x+1}`; // eslint-disable-line i18next/no-literal-string\n\t\t});\n\t\treturn result;\n\t} catch ( _ ) {\n\t\treturn null;\n\t}\n};\n\n\n// MAIN //\n\n/**\n* K-means clustering.\n*\n* @property {Object} data - object of value arrays\n* @property {Array<string>} variables - names of variables used for clustering\n* @property {string} initialization - initialization method (`kmeans++`, `random`, or `mostDistant`)\n* @property {number} K - number of clusters\n* @property {Function} onResult - callback invoked with model object\n*/\nclass KMeans extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\t\tconst { K, variables, data, initialization } = props;\n\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\tthis.state = {\n\t\t\tresult,\n\t\t\t...props\n\t\t};\n\t\tif ( result ) {\n\t\t\tprops.onResult( result );\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.variables !== prevState.variables ||\n\t\t\tnextProps.K !== prevState.K ||\n\t\t\tnextProps.initialization !== prevState.initialization\n\t\t) {\n\t\t\tconst { K, variables, data, initialization } = nextProps;\n\t\t\tconst result = fitModel({ K, variables, data, initialization });\n\t\t\tnextProps.onResult( result );\n\t\t\tconst newState = {\n\t\t\t\tresult,\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t\treturn newState;\n\t\t}\n\t\treturn null;\n\t}\n\n\trender() {\n\t\tconst { result } = this.state;\n\t\tconst { t, variables } = this.props;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('kmeans-summary')}</span>\n\t\t\t\t<p>{result.converged ? t('algorithm-converged', { n: result.iterations }) : t('algorithm-not-converged', { n: result.iterations })}</p>\n\t\t\t\t{summaryTable( variables, result.centroids, t )}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nKMeans.defaultProps = {\n\tK: 3,\n\tinitialization: 'kmeans++',\n\tonResult() {}\n};\n\nKMeans.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\tvariables: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tK: PropTypes.number,\n\tinitialization: PropTypes.oneOf([ 'kmeans++', 'random', 'mostDistant' ]),\n\tonResult: PropTypes.func\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'models' )( withPropCheck( KMeans ) );\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction squaredEuclidean(p, q) {\r\n    let d = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        d += (p[i] - q[i]) * (p[i] - q[i]);\r\n    }\r\n    return d;\r\n}\r\nexports.squaredEuclidean = squaredEuclidean;\r\nfunction euclidean(p, q) {\r\n    return Math.sqrt(squaredEuclidean(p, q));\r\n}\r\nexports.euclidean = euclidean;\r\n","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar mlDistanceEuclidean = require('ml-distance-euclidean');\nvar nearestVector = _interopDefault(require('ml-nearest-vector'));\nvar Random = _interopDefault(require('ml-random'));\nvar mlMatrix = require('ml-matrix');\n\n/**\n * Calculates the distance matrix for a given array of points\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {function} distance - Distance function to use between the points\n * @return {Array<Array<number>>} - matrix with the distance values\n */\nfunction calculateDistanceMatrix(data, distance) {\n  var distanceMatrix = new Array(data.length);\n  for (var i = 0; i < data.length; ++i) {\n    for (var j = i; j < data.length; ++j) {\n      if (!distanceMatrix[i]) {\n        distanceMatrix[i] = new Array(data.length);\n      }\n      if (!distanceMatrix[j]) {\n        distanceMatrix[j] = new Array(data.length);\n      }\n      const dist = distance(data[i], data[j]);\n      distanceMatrix[i][j] = dist;\n      distanceMatrix[j][i] = dist;\n    }\n  }\n  return distanceMatrix;\n}\n\n/**\n * Updates the cluster identifier based in the new data\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {function} distance - Distance function to use between the points\n * @return {Array} the cluster identifier for each data dot\n */\nfunction updateClusterID(data, centers, clusterID, distance) {\n  for (var i = 0; i < data.length; i++) {\n    clusterID[i] = nearestVector(centers, data[i], {\n      distanceFunction: distance\n    });\n  }\n  return clusterID;\n}\n\n/**\n * Update the center values based in the new configurations of the clusters\n * @ignore\n * @param {Array<Array<number>>} prevCenters - Centroids from the previous iteration\n * @param {Array <Array <number>>} data - the [x,y,z,...] points to cluster\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @return {Array} he K centers in format [x,y,z,...]\n */\nfunction updateCenters(prevCenters, data, clusterID, K) {\n  const nDim = data[0].length;\n\n  // copy previous centers\n  var centers = new Array(K);\n  var centersLen = new Array(K);\n  for (var i = 0; i < K; i++) {\n    centers[i] = new Array(nDim);\n    centersLen[i] = 0;\n    for (var j = 0; j < nDim; j++) {\n      centers[i][j] = 0;\n    }\n  }\n\n  // add the value for all dimensions of the point\n  for (var l = 0; l < data.length; l++) {\n    centersLen[clusterID[l]]++;\n    for (var dim = 0; dim < nDim; dim++) {\n      centers[clusterID[l]][dim] += data[l][dim];\n    }\n  }\n\n  // divides by length\n  for (var id = 0; id < K; id++) {\n    for (var d = 0; d < nDim; d++) {\n      if (centersLen[id]) {\n        centers[id][d] /= centersLen[id];\n      } else {\n        centers[id][d] = prevCenters[id][d];\n      }\n    }\n  }\n  return centers;\n}\n\n/**\n * The centers have moved more than the tolerance value?\n * @ignore\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} oldCenters - the K old centers in format [x,y,z,...]\n * @param {function} distanceFunction - Distance function to use between the points\n * @param {number} tolerance - Allowed distance for the centroids to move\n * @return {boolean}\n */\nfunction hasConverged(centers, oldCenters, distanceFunction, tolerance) {\n  for (var i = 0; i < centers.length; i++) {\n    if (distanceFunction(centers[i], oldCenters[i]) > tolerance) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Choose K different random points from the original data\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\nfunction random(data, K, seed) {\n  const random = new Random(seed);\n  return random.choice(data, { size: K });\n}\n\n/**\n * Chooses the most distant points to a first random pick\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {Array<Array<number>>} distanceMatrix - matrix with the distance values\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\nfunction mostDistant(data, K, distanceMatrix, seed) {\n  const random = new Random(seed);\n  var ans = new Array(K);\n  // chooses a random point as initial cluster\n  ans[0] = Math.floor(random.random() * data.length);\n\n  if (K > 1) {\n    // chooses the more distant point\n    var maxDist = { dist: -1, index: -1 };\n    for (var l = 0; l < data.length; ++l) {\n      if (distanceMatrix[ans[0]][l] > maxDist.dist) {\n        maxDist.dist = distanceMatrix[ans[0]][l];\n        maxDist.index = l;\n      }\n    }\n    ans[1] = maxDist.index;\n\n    if (K > 2) {\n      // chooses the set of points that maximises the min distance\n      for (var k = 2; k < K; ++k) {\n        var center = { dist: -1, index: -1 };\n        for (var m = 0; m < data.length; ++m) {\n          // minimum distance to centers\n          var minDistCent = { dist: Number.MAX_VALUE, index: -1 };\n          for (var n = 0; n < k; ++n) {\n            if (\n              distanceMatrix[n][m] < minDistCent.dist &&\n              ans.indexOf(m) === -1\n            ) {\n              minDistCent = {\n                dist: distanceMatrix[n][m],\n                index: m\n              };\n            }\n          }\n\n          if (\n            minDistCent.dist !== Number.MAX_VALUE &&\n            minDistCent.dist > center.dist\n          ) {\n            center = Object.assign({}, minDistCent);\n          }\n        }\n\n        ans[k] = center.index;\n      }\n    }\n  }\n\n  return ans.map((index) => data[index]);\n}\n\n// Implementation inspired from scikit\nfunction kmeanspp(X, K, options = {}) {\n  X = new mlMatrix.Matrix(X);\n  const nSamples = X.rows;\n  const random = new Random(options.seed);\n  // Set the number of trials\n  const centers = [];\n  const localTrials = options.localTrials || 2 + Math.floor(Math.log(K));\n\n  // Pick the first center at random from the dataset\n  const firstCenterIdx = random.randInt(nSamples);\n  centers.push(X.getRow(firstCenterIdx));\n\n  // Init closest distances\n  let closestDistSquared = new mlMatrix.Matrix(1, X.rows);\n  for (let i = 0; i < X.rows; i++) {\n    closestDistSquared.set(0, i, mlDistanceEuclidean.squaredEuclidean(X.getRow(i), centers[0]));\n  }\n  let cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n  const factor = 1 / cumSumClosestDistSquared[0][nSamples - 1];\n  let probabilities = mlMatrix.Matrix.mul(closestDistSquared, factor);\n\n  // Iterate over the remaining centers\n  for (let i = 1; i < K; i++) {\n    const candidateIdx = random.choice(nSamples, {\n      replace: true,\n      size: localTrials,\n      probabilities: probabilities[0]\n    });\n\n    const candidates = X.selection(candidateIdx, range(X.columns));\n    const distanceToCandidates = euclideanDistances(candidates, X);\n\n    let bestCandidate;\n    let bestPot;\n    let bestDistSquared;\n\n    for (let j = 0; j < localTrials; j++) {\n      const newDistSquared = mlMatrix.Matrix.min(closestDistSquared, [distanceToCandidates.getRow(j)]);\n      const newPot = newDistSquared.sum();\n      if (bestCandidate === undefined || newPot < bestPot) {\n        bestCandidate = candidateIdx[j];\n        bestPot = newPot;\n        bestDistSquared = newDistSquared;\n      }\n    }\n    centers[i] = X.getRow(bestCandidate);\n    closestDistSquared = bestDistSquared;\n    cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n    probabilities = mlMatrix.Matrix.mul(\n      closestDistSquared,\n      1 / cumSumClosestDistSquared[0][nSamples - 1]\n    );\n  }\n  return centers;\n}\n\nfunction euclideanDistances(A, B) {\n  const result = new mlMatrix.Matrix(A.rows, B.rows);\n  for (let i = 0; i < A.rows; i++) {\n    for (let j = 0; j < B.rows; j++) {\n      result.set(i, j, mlDistanceEuclidean.squaredEuclidean(A.getRow(i), B.getRow(j)));\n    }\n  }\n  return result;\n}\n\nfunction range(l) {\n  let r = [];\n  for (let i = 0; i < l; i++) {\n    r.push(i);\n  }\n  return r;\n}\n\nfunction cumSum(arr) {\n  let cumSum = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    cumSum[i] = cumSum[i - 1] + arr[i];\n  }\n  return cumSum;\n}\n\nconst distanceSymbol = Symbol('distance');\n\nclass KMeansResult {\n  /**\n   * Result of the kmeans algorithm\n   * @param {Array<number>} clusters - the cluster identifier for each data dot\n   * @param {Array<Array<object>>} centroids - the K centers in format [x,y,z,...], the error and size of the cluster\n   * @param {boolean} converged - Converge criteria satisfied\n   * @param {number} iterations - Current number of iterations\n   * @param {function} distance - (*Private*) Distance function to use between the points\n   * @constructor\n   */\n  constructor(clusters, centroids, converged, iterations, distance) {\n    this.clusters = clusters;\n    this.centroids = centroids;\n    this.converged = converged;\n    this.iterations = iterations;\n    this[distanceSymbol] = distance;\n  }\n\n  /**\n   * Allows to compute for a new array of points their cluster id\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {Array<number>} - cluster id for each point\n   */\n  nearest(data) {\n    const clusterID = new Array(data.length);\n    const centroids = this.centroids.map(function (centroid) {\n      return centroid.centroid;\n    });\n    return updateClusterID(data, centroids, clusterID, this[distanceSymbol]);\n  }\n\n  /**\n   * Returns a KMeansResult with the error and size of the cluster\n   * @ignore\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {KMeansResult}\n   */\n  computeInformation(data) {\n    var enrichedCentroids = this.centroids.map(function (centroid) {\n      return {\n        centroid: centroid,\n        error: 0,\n        size: 0\n      };\n    });\n\n    for (var i = 0; i < data.length; i++) {\n      enrichedCentroids[this.clusters[i]].error += this[distanceSymbol](\n        data[i],\n        this.centroids[this.clusters[i]]\n      );\n      enrichedCentroids[this.clusters[i]].size++;\n    }\n\n    for (var j = 0; j < this.centroids.length; j++) {\n      if (enrichedCentroids[j].size) {\n        enrichedCentroids[j].error /= enrichedCentroids[j].size;\n      } else {\n        enrichedCentroids[j].error = null;\n      }\n    }\n\n    return new KMeansResult(\n      this.clusters,\n      enrichedCentroids,\n      this.converged,\n      this.iterations,\n      this[distanceSymbol]\n    );\n  }\n}\n\nconst defaultOptions = {\n  maxIterations: 100,\n  tolerance: 1e-6,\n  withIterations: false,\n  initialization: 'kmeans++',\n  distanceFunction: mlDistanceEuclidean.squaredEuclidean\n};\n\n/**\n * Each step operation for kmeans\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} iterations - Current number of iterations\n * @return {KMeansResult}\n */\nfunction step(centers, data, clusterID, K, options, iterations) {\n  clusterID = updateClusterID(\n    data,\n    centers,\n    clusterID,\n    options.distanceFunction\n  );\n  var newCenters = updateCenters(centers, data, clusterID, K);\n  var converged = hasConverged(\n    newCenters,\n    centers,\n    options.distanceFunction,\n    options.tolerance\n  );\n  return new KMeansResult(\n    clusterID,\n    newCenters,\n    converged,\n    iterations,\n    options.distanceFunction\n  );\n}\n\n/**\n * Generator version for the algorithm\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n */\nfunction* kmeansGenerator(centers, data, clusterID, K, options) {\n  var converged = false;\n  var stepNumber = 0;\n  var stepResult;\n  while (!converged && stepNumber < options.maxIterations) {\n    stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n    yield stepResult.computeInformation(data);\n    converged = stepResult.converged;\n    centers = stepResult.centroids;\n  }\n}\n\n/**\n * K-means algorithm\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} [options.maxIterations = 100] - Maximum of iterations allowed\n * @param {number} [options.tolerance = 1e-6] - Error tolerance\n * @param {boolean} [options.withIterations = false] - Store clusters and centroids for each iteration\n * @param {function} [options.distanceFunction = squaredDistance] - Distance function to use between the points\n * @param {number} [options.seed] - Seed for random initialization.\n * @param {string|Array<Array<number>>} [options.initialization = 'kmeans++'] - K centers in format [x,y,z,...] or a method for initialize the data:\n *  * You can either specify your custom start centroids, or select one of the following initialization method:\n *  * `'kmeans++'` will use the kmeans++ method as described by http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf\n *  * `'random'` will choose K random different values.\n *  * `'mostDistant'` will choose the more distant points to a first random pick\n * @return {KMeansResult} - Cluster identifier for each data dot and centroids with the following fields:\n *  * `'clusters'`: Array of indexes for the clusters.\n *  * `'centroids'`: Array with the resulting centroids.\n *  * `'iterations'`: Number of iterations that took to converge\n */\nfunction kmeans(data, K, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  if (K <= 0 || K > data.length || !Number.isInteger(K)) {\n    throw new Error(\n      'K should be a positive integer smaller than the number of points'\n    );\n  }\n\n  var centers;\n  if (Array.isArray(options.initialization)) {\n    if (options.initialization.length !== K) {\n      throw new Error('The initial centers should have the same length as K');\n    } else {\n      centers = options.initialization;\n    }\n  } else {\n    switch (options.initialization) {\n      case 'kmeans++':\n        centers = kmeanspp(data, K, options);\n        break;\n      case 'random':\n        centers = random(data, K, options.seed);\n        break;\n      case 'mostDistant':\n        centers = mostDistant(\n          data,\n          K,\n          calculateDistanceMatrix(data, options.distanceFunction),\n          options.seed\n        );\n        break;\n      default:\n        throw new Error(\n          `Unknown initialization method: \"${options.initialization}\"`\n        );\n    }\n  }\n\n  // infinite loop until convergence\n  if (options.maxIterations === 0) {\n    options.maxIterations = Number.MAX_VALUE;\n  }\n\n  var clusterID = new Array(data.length);\n  if (options.withIterations) {\n    return kmeansGenerator(centers, data, clusterID, K, options);\n  } else {\n    var converged = false;\n    var stepNumber = 0;\n    var stepResult;\n    while (!converged && stepNumber < options.maxIterations) {\n      stepResult = step(centers, data, clusterID, K, options, ++stepNumber);\n      converged = stepResult.converged;\n      centers = stepResult.centroids;\n    }\n    return stepResult.computeInformation(data);\n  }\n}\n\nmodule.exports = kmeans;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ml_distance_euclidean_1 = require(\"ml-distance-euclidean\");\nconst defaultOptions = {\n    distanceFunction: ml_distance_euclidean_1.squaredEuclidean\n};\nfunction nearestVector(listVectors, vector, options = defaultOptions) {\n    const distanceFunction = options.distanceFunction || defaultOptions.distanceFunction;\n    const similarityFunction = options.similarityFunction || defaultOptions.similarityFunction;\n    let vectorIndex = -1;\n    if (typeof similarityFunction === 'function') {\n        // maximum similarity\n        let maxSim = Number.MIN_VALUE;\n        for (let j = 0; j < listVectors.length; j++) {\n            const sim = similarityFunction(vector, listVectors[j]);\n            if (sim > maxSim) {\n                maxSim = sim;\n                vectorIndex = j;\n            }\n        }\n    }\n    else if (typeof distanceFunction === 'function') {\n        // minimum distance\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < listVectors.length; i++) {\n            const dist = distanceFunction(vector, listVectors[i]);\n            if (dist < minDist) {\n                minDist = dist;\n                vectorIndex = i;\n            }\n        }\n    }\n    else {\n        throw new Error(\"A similarity or distance function it's required\");\n    }\n    return vectorIndex;\n}\nexports.default = nearestVector;\nfunction findNearestVector(vectorList, vector, options = defaultOptions) {\n    const index = nearestVector(vectorList, vector, options);\n    return vectorList[index];\n}\nexports.findNearestVector = findNearestVector;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PROB_TOLERANCE = 0.00000001;\nfunction randomChoice(values, options = {}, random = Math.random) {\n    const { size = 1, replace = false, probabilities } = options;\n    let valuesArr;\n    let cumSum;\n    if (typeof values === 'number') {\n        valuesArr = getArray(values);\n    }\n    else {\n        valuesArr = values.slice();\n    }\n    if (probabilities) {\n        if (!replace) {\n            throw new Error('choice with probabilities and no replacement is not implemented');\n        }\n        // check input is sane\n        if (probabilities.length !== valuesArr.length) {\n            throw new Error('the length of probabilities option should be equal to the number of choices');\n        }\n        cumSum = [probabilities[0]];\n        for (let i = 1; i < probabilities.length; i++) {\n            cumSum[i] = cumSum[i - 1] + probabilities[i];\n        }\n        if (Math.abs(1 - cumSum[cumSum.length - 1]) > PROB_TOLERANCE) {\n            throw new Error(`probabilities should sum to 1, but instead sums to ${cumSum[cumSum.length - 1]}`);\n        }\n    }\n    if (replace === false && size > valuesArr.length) {\n        throw new Error('size option is too large');\n    }\n    const result = [];\n    for (let i = 0; i < size; i++) {\n        const index = randomIndex(valuesArr.length, random, cumSum);\n        result.push(valuesArr[index]);\n        if (!replace) {\n            valuesArr.splice(index, 1);\n        }\n    }\n    return result;\n}\nfunction getArray(n) {\n    const arr = [];\n    for (let i = 0; i < n; i++) {\n        arr.push(i);\n    }\n    return arr;\n}\nfunction randomIndex(n, random, cumSum) {\n    const rand = random();\n    if (!cumSum) {\n        return Math.floor(rand * n);\n    }\n    else {\n        let idx = 0;\n        while (rand > cumSum[idx]) {\n            idx++;\n        }\n        return idx;\n    }\n}\nexports.default = randomChoice;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// tslint:disable-next-line\nconst ml_xsadd_1 = require(\"ml-xsadd\");\nconst choice_1 = require(\"./choice\");\n/**\n * @classdesc Random class\n */\nclass Random {\n    /**\n     * @param [seedOrRandom=Math.random] - Control the random number generator used by the Random class instance. Pass a random number generator function with a uniform distribution over the half-open interval [0, 1[. If seed will pass it to ml-xsadd to create a seeded random number generator. If undefined will use Math.random.\n     */\n    constructor(seedOrRandom = Math.random) {\n        if (typeof seedOrRandom === 'number') {\n            const xsadd = new ml_xsadd_1.default(seedOrRandom);\n            this.randomGenerator = xsadd.random;\n        }\n        else {\n            this.randomGenerator = seedOrRandom;\n        }\n    }\n    choice(values, options) {\n        if (typeof values === 'number') {\n            return choice_1.default(values, options, this.randomGenerator);\n        }\n        return choice_1.default(values, options, this.randomGenerator);\n    }\n    /**\n     * Draw a random number from a uniform distribution on [0,1)\n     * @return The random number\n     */\n    random() {\n        return this.randomGenerator();\n    }\n    /**\n     * Draw a random integer from a uniform distribution on [low, high). If only low is specified, the number is drawn on [0, low)\n     * @param low - The lower bound of the uniform distribution interval.\n     * @param high - The higher bound of the uniform distribution interval.\n     */\n    randInt(low, high) {\n        if (high === undefined) {\n            high = low;\n            low = 0;\n        }\n        return low + Math.floor(this.randomGenerator() * (high - low));\n    }\n    /**\n     * Draw several random number from a uniform distribution on [0, 1)\n     * @param size - The number of number to draw\n     * @return - The list of drawn numbers.\n     */\n    randomSample(size) {\n        const result = [];\n        for (let i = 0; i < size; i++) {\n            result.push(this.random());\n        }\n        return result;\n    }\n}\nexports.default = Random;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LOOP = 8;\nconst FLOAT_MUL = 1 / 16777216;\nconst sh1 = 15;\nconst sh2 = 18;\nconst sh3 = 11;\nfunction multiply_uint32(n, m) {\n    n >>>= 0;\n    m >>>= 0;\n    const nlo = n & 0xffff;\n    const nhi = n - nlo;\n    return (((nhi * m) >>> 0) + nlo * m) >>> 0;\n}\nclass XSadd {\n    constructor(seed = Date.now()) {\n        this.state = new Uint32Array(4);\n        this.init(seed);\n        this.random = this.getFloat.bind(this);\n    }\n    /**\n     * Returns a 32-bit integer r (0 <= r < 2^32)\n     */\n    getUint32() {\n        this.nextState();\n        return (this.state[3] + this.state[2]) >>> 0;\n    }\n    /**\n     * Returns a floating point number r (0.0 <= r < 1.0)\n     */\n    getFloat() {\n        return (this.getUint32() >>> 8) * FLOAT_MUL;\n    }\n    init(seed) {\n        if (!Number.isInteger(seed)) {\n            throw new TypeError('seed must be an integer');\n        }\n        this.state[0] = seed;\n        this.state[1] = 0;\n        this.state[2] = 0;\n        this.state[3] = 0;\n        for (let i = 1; i < LOOP; i++) {\n            this.state[i & 3] ^=\n                (i +\n                    multiply_uint32(1812433253, this.state[(i - 1) & 3] ^ ((this.state[(i - 1) & 3] >>> 30) >>> 0))) >>>\n                    0;\n        }\n        this.periodCertification();\n        for (let i = 0; i < LOOP; i++) {\n            this.nextState();\n        }\n    }\n    periodCertification() {\n        if (this.state[0] === 0 &&\n            this.state[1] === 0 &&\n            this.state[2] === 0 &&\n            this.state[3] === 0) {\n            this.state[0] = 88; // X\n            this.state[1] = 83; // S\n            this.state[2] = 65; // A\n            this.state[3] = 68; // D\n        }\n    }\n    nextState() {\n        let t = this.state[0];\n        t ^= t << sh1;\n        t ^= t >>> sh2;\n        t ^= this.state[3] << sh3;\n        this.state[0] = this.state[1];\n        this.state[1] = this.state[2];\n        this.state[2] = this.state[3];\n        this.state[3] = t;\n    }\n}\nexports.default = XSadd;\n"],"sourceRoot":""}
{"version":3,"sources":["../node_modules/@stdlib/assert/is-array-array/lib/index.js","../node_modules/@stdlib/assert/is-array-array/lib/main.js","../node_modules/@stdlib/utils/define-nonenumerable-property/lib/index.js","../node_modules/@stdlib/utils/define-nonenumerable-property/lib/main.js","../node_modules/@isle-project/utils/multiply/index.js","../node_modules/@isle-project/utils/zscore/index.js","../node_modules/@isle-project/components/models/lasso-regression/design_matrix.js","../node_modules/@isle-project/utils/divide/index.js","../node_modules/@isle-project/components/models/lasso-regression/dotm.js","../node_modules/@isle-project/components/models/lasso-regression/dotv.js","../node_modules/@isle-project/components/models/lasso-regression/soft_thresholding.js","../node_modules/@isle-project/components/models/lasso-regression/lasso.js","../node_modules/@isle-project/components/models/lasso-regression/main.js","../node_modules/@isle-project/utils/mmult/index.js","../node_modules/@isle-project/utils/transpose/index.js"],"names":["data"],"mappings":"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","file":"static/js/LassoRegression.d8fffde9.chunk.js","sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Test if a value is an array of arrays.\n*\n* @module @stdlib/assert/is-array-array\n*\n* @example\n* var isArrayArray = require( '@stdlib/assert/is-array-array' );\n*\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\n\n// MODULES //\n\nvar isArrayArray = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = isArrayArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar arrayfun = require( './../../tools/array-function' );\nvar isArray = require( './../../is-array' );\n\n\n// MAIN //\n\n/**\n* Tests if a value is an array of arrays.\n*\n* @name isArrayArray\n* @type {Function}\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating whether a value is an array of arrays\n*\n* @example\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\nvar isArrayArray = arrayfun( isArray );\n\n\n// EXPORTS //\n\nmodule.exports = isArrayArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Define a non-enumerable property.\n*\n* @module @stdlib/utils/define-nonenumerable-property\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n* var setNonEnumerableProperty = require( '@stdlib/utils/define-nonenumerable-property' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\n\n// MODULES //\n\nvar setNonEnumerableProperty = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = setNonEnumerableProperty;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar defineProperty = require( './../../define-property' );\n\n\n// MAIN //\n\n/**\n* Defines a non-enumerable property.\n*\n* @param {Object} obj - object on which to define the property\n* @param {(string|symbol)} prop - property name\n* @param {*} value - value to set\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\nfunction setNonEnumerableProperty( obj, prop, value ) {\n\tdefineProperty( obj, prop, {\n\t\t'configurable': true,\n\t\t'enumerable': false,\n\t\t'writable': true,\n\t\t'value': value\n\t});\n}\n\n\n// EXPORTS //\n\nmodule.exports = setNonEnumerableProperty;\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise multiplication.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction multiply( arr, x ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be multiplied must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default multiply;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport mean from '@isle-project/utils/statistic/mean';\nimport stdev from '@isle-project/utils/statistic/stdev';\nimport setNonEnumerableProperty from '@stdlib/utils/define-nonenumerable-property';\n\n\n// MAIN //\n\n/**\n* Standardizes elements in input array.\n*\n* @param {Array} x - input array\n* @param {boolean} demean - controls whether the mean should be subtracted from the values\n* @param {boolean} scale - controls whether values should be divided by the standard deviation\n* @returns {Array} output array with added `mu` and `sigma` properties\n*/\nfunction zScore( x, demean = true, scale = true ) {\n\tconst avg = mean( x );\n\tconst sd = stdev( x );\n\tconst len = x.length;\n\n\tconst out = new Array( len );\n\tif ( demean ) {\n\t\tif ( scale ) {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg ) / sd;\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg );\n\t\t\t}\n\t\t}\n\t}\n\telse if ( scale ) {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = x[ i ] / sd;\n\t\t}\n\t}\n\telse {\n\t\tout = x.slice();\n\t}\n\tsetNonEnumerableProperty( out, 'mu', avg );\n\tsetNonEnumerableProperty( out, 'sigma', sd );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default zScore;\n","// MODULES //\n\nimport isArray from '@stdlib/assert/is-array';\nimport countBy from '@stdlib/utils/count-by';\nimport identity from '@stdlib/utils/identity-function';\nimport objectKeys from '@stdlib/utils/keys';\nimport sqrt from '@stdlib/math/base/special/sqrt';\nimport contains from '@stdlib/assert/contains';\nimport zScore from '@isle-project/utils/zscore';\n\n\n// MAIN //\n\n/**\n * Returns the design matrix for a lasso regression model.\n *\n * @param {Array} x - predictor variables\n * @param {Object} data - data object\n * @param {Array} quantitative - array of quantitative predictors\n * @param {boolean} intercept - boolean indicating whether to include an intercept\n * @returns {Object} object with design `matrix`, list of `predictors`, `categoricalStats`, and `standardized` values\n */\nfunction designMatrix( x, data, quantitative, intercept ) {\n\tif ( !isArray( x ) ) {\n\t\tx = [ x ];\n\t}\n\tconst matrix = [];\n\tconst predictors = [];\n\tconst hash = {};\n\tconst standardized = {};\n\tconst categoricalStats = {};\n\tconst nobs = data[ x[ 0 ] ].length;\n\tfor ( let j = 0; j < x.length; j++ ) {\n\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\tconst values = zScore( data[ x[ j ] ] );\n\t\t\tstandardized[ x[ j ] ] = values;\n\t\t\tpredictors.push( x[ j ] );\n\t\t} else {\n\t\t\tconst values = data[ x[ j ] ];\n\t\t\tconst counts = countBy( values, identity );\n\t\t\tconst categories = x[ j ].categories || objectKeys( counts );\n\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\tconst label = `${x[ j ]}_${categories[ k ]}`;\n\t\t\t\tpredictors.push( label );\n\t\t\t\tconst p = counts[ categories[ k ] ] / nobs;\n\t\t\t\tcategoricalStats[ label ] = {\n\t\t\t\t\tmu: p,\n\t\t\t\t\tsigma: sqrt( p * (1-p) )\n\t\t\t\t};\n\t\t\t}\n\t\t\thash[ x[ j ] ] = categories;\n\t\t}\n\t}\n\tfor ( let i = 0; i < nobs; i++ ) {\n\t\tconst row = [];\n\t\tif ( intercept ) {\n\t\t\trow.push( 1 );\n\t\t}\n\t\tfor ( let j = 0; j < x.length; j++ ) {\n\t\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\t\tconst values = standardized[ x[ j ] ];\n\t\t\t\trow.push( values[ i ] );\n\t\t\t} else {\n\t\t\t\tconst values = data[ x[ j ] ];\n\t\t\t\tconst categories = hash[ x[ j ] ];\n\t\t\t\tconst val = values[ i ];\n\t\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\t\tconst { mu, sigma } = categoricalStats[ `${x[ j ]}_${categories[ k ]}` ];\n\t\t\t\t\trow.push(\n\t\t\t\t\t\t( val === categories[ k ] ) ?\n\t\t\t\t\t\t( 1 - mu ) / sigma :\n\t\t\t\t\t\t-mu / sigma\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatrix.push( row );\n\t}\n\treturn { matrix, predictors, categoricalStats, standardized };\n}\n\n\n// EXPORTS //\n\nexport default designMatrix;\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise division.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction divide( arr, x, opts ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be divided must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default divide;\n","// MAIN //\n\n/**\n* Calculates the dot product between j-th column vectors of the two input matrices skipping zero elements.\n*\n* @param {Matrix} x - first input matrix\n* @param {Matrix} y - second input matrix\n* @param {number} j - column index\n* @returns {number} dot product value\n*/\nfunction dotm( x, y, j ) {\n\tlet ret = 0.0;\n\tconst nRows = x.shape[ 0 ];\n\tfor ( let i = 0; i < nRows; i++ ) {\n\t\tconst xVal = x.get( i, j );\n\t\tconst yVal = y.get( i, j );\n\t\tif ( xVal !== 0 && yVal !== 0 ) {\n\t\t\tret += xVal * yVal;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default dotm;\n","// MAIN //\n\n/**\n* Calculates the dot product between two arrays.\n*\n* @param {NumberArray} x - first vector\n* @param {NumberArray} y - second vector\n* @returns {number} dot product\n*/\nfunction dotv( x, y ) {\n\tconst len = x.length;\n\tlet sum = 0.0;\n\tfor ( let i = 0; i < len; i++ ) {\n\t\tsum += x[ i ] * y[ i ];\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nexport default dotv;\n","// MAIN //\n\n/**\n* Soft-thresholding operator.\n*\n* @param {number} x - input value\n* @param {number} t - threshold value\n* @returns {number} return value\n*/\nfunction softThresholding( x, t ) {\n\tif ( x > t ) {\n\t\treturn x - t;\n\t} else if ( x < -t ) {\n\t\treturn x + t;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default softThresholding;\n","// MODULES //\n\nimport logger from 'debug';\nimport incrspace from '@stdlib/array/incrspace';\nimport sign from '@stdlib/math/base/special/signum';\nimport isArrayArray from '@stdlib/assert/is-array-array';\nimport isMatrixLike from '@stdlib/assert/is-matrix-like';\nimport ctor from '@stdlib/ndarray/ctor';\nimport ndarray from '@stdlib/ndarray/array';\nimport isNumber from '@stdlib/assert/is-number';\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport abs from '@stdlib/math/base/special/abs';\nimport mmult from '@isle-project/utils/mmult';\nimport transpose from '@isle-project/utils/transpose';\nimport subtract from '@isle-project/utils/subtract';\nimport divide from '@isle-project/utils/divide';\nimport dotm from './dotm.js';\nimport dotv from './dotv.js';\nimport softThresholding from './soft_thresholding.js';\n\n\n// VARIABLES //\n\nconst debug = logger( 'isle:lasso' );\nconst PRECISION = 1e-9;\n\n\n// FUNCTIONS //\n\nconst mget = ( x, j ) => {\n\tconst out = new Float64Array( x.shape[ 0 ] );\n\tfor ( let i = 0; i < out.length; i++ ) {\n\t\tout[ i ] = x.get( i, j );\n\t}\n\treturn out;\n};\n\n\n// MAIN //\n\n/**\n* Lasso object to fit regression.\n*\n* @constructor\n* @returns {LassoFit} instance\n*/\nfunction LassoFit( y, x, lambda ) {\n\tthis.y = y;\n\tthis.x = x;\n\tthis.lambda = lambda;\n\n\tthis.N = x.shape[ 0 ];\n\tthis.p = x.shape[ 1 ];\n\n\t// Initialize model parameters to zero:\n\tthis.beta = new Float64Array( this.p );\n\tthis.betast = new Float64Array( this.p );\n\n\t// Initialize active set to all predictors:\n\tthis.active = incrspace( 0, this.beta.length, 1 );\n\tthis.nonactive = [];\n\n\t// Matrix holding partial residuals:\n\tthis.presid = ctor( 'float64', new Float64Array( x._buffer.length ), x.shape, x.strides, x.offset, x.order );\n\n\tthis.init = () => {\n\t\tthis.iteration = 0;\n\t\tthis.iterate();\n\t};\n\tthis.init();\n}\n\n/**\n* Checks the Karush-Khun-Tucker (KKT) conditions for an optimal solution.\n*\n* @returns {boolean} returns true if optimal conditions are satisfied, false otherwise\n*/\nLassoFit.prototype.testKKT = function testKKT() {\n\tconst beta = this.beta;\n\tconst N = this.N;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tconst ymxb = subtract( y, mmult( x, beta ) );\n\tconst G = divide( mmult( transpose( x ), ymxb ), N );\n\tfor ( let i = 0; i < beta.length; i++ ) {\n\t\tif ( beta[ i ] === 0 ) {\n\t\t\tif ( abs( G[i] ) > this.lambda + PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( beta[ i ] > 0 ) {\n\t\t\tif ( G[i] - this.lambda * sign( beta[i] ) > PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};\n\n/**\n* Exclusion test for all predictors not in active set. If one or more predictors fail the test, they are included in the active set.\n*\n* @returns {boolean} returns true if active set was changed, false otherwise\n*/\nLassoFit.prototype.testActiveSet = function testActiveSet() {\n\tlet changed = false;\n\n\tconst { residuals } = this.predict( this.x );\n\n\t// See whether non-active variables all pass exclusion test:\n\tfor ( let j = 0; j < this.nonactive.length; j++ ) {\n\t\tconst jVal = this.nonactive[ j ];\n\t\tconst xj = mget( this.x, jVal );\n\t\tif ( abs( dotv( xj, residuals ) ) / this.N > this.lambda ) {\n\t\t\t// Test failed: include predictor in active set -> iterate again\n\t\t\tthis.active.push( jVal );\n\t\t\tthis.nonactive.splice( j, 1 );\n\t\t\tchanged = true;\n\t\t}\n\t}\n\tdebug( 'Active set changes...' );\n\treturn changed;\n};\n\n/**\n* Iterate over the active set of predictors and perform coordinate descent until convergence.\n*\n* @returns {void}\n*/\nLassoFit.prototype.iterate = function iterate() {\n\tconst N = this.N;\n\tconst p = this.p;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tthis.iteration += 1;\n\tif ( this.iteration > 10000 ) {\n\t\t// Break out after maximum number of iterations is reached...\n\t\treturn;\n\t}\n\n\tlet converged = true;\n\tfor ( let j = 0; j < this.active.length; j++ ) {\n\t\tconst jVal = this.active[ j ];\n\t\tfor ( let i = 0; i < N; i++ ) {\n\t\t\tconst rval = y[ i ];\n\t\t\tfor ( let k = 0; k < p; k++ ) {\n\t\t\t\trval -= ( jVal !== k ) ? x.get( i, k ) * this.beta[ k ] : 0;\n\t\t\t}\n\t\t\tthis.presid.set( i, jVal, rval );\n\t\t}\n\t\tthis.betast[ jVal ] = (1/N) * dotm( x, this.presid, jVal );\n\t\tconst betaOld = this.beta[ jVal ];\n\t\tconst betaNew = softThresholding( this.betast[ jVal ], this.lambda );\n\t\tif ( abs( betaNew - betaOld ) > PRECISION ) {\n\t\t\tconverged = false;\n\t\t}\n\t\tthis.beta[ jVal ] = betaNew;\n\t}\n\t// Recompute active set:\n\tfor ( let j = this.active.length - 1; j >= 0; j-- ) {\n\t\tconst jVal = this.active[ j ];\n\t\tif ( abs( this.beta[ jVal ] ) < PRECISION ) {\n\t\t\tthis.active.splice( j, 1 );\n\t\t\tthis.nonactive.push( jVal );\n\t\t}\n\t}\n\tif ( converged === false ) {\n\t\tthis.iterate();\n\t} else if ( this.testActiveSet() ) {\n\t\tthis.iterate();\n\t}\n};\n\n/**\n* Calculates the current model fitted values (yhat).\n*\n* @returns {Object} fitted values and residuals\n*/\nLassoFit.prototype.predict = function predict( x ) {\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t}\n\tconst fitted = mmult( x, this.beta );\n\treturn fitted;\n};\n\n\n// MAIN //\n\n/**\n* Fit lasso regression via coordinate descent.\n*\n* @param {Matrix|Array} x - design matrix\n* @param {NumberArray} y - response vector\n* @param {number} lambda - L1 penalty value\n* @returns {Object} regression model\n*/\nfunction lasso( x, y, lambda ) {\n\tif ( !isNumber ) {\n\t\tthrow new TypeError( 'invalid input argument. The third argument must be a number primitive. Value: `' + lambda + '`' );\n\t}\n\tif ( !isArrayLike( y ) ) {\n\t\tthrow new TypeError( 'invalid input argument. The second argument must be array-like. Value: `' + y + '`' );\n\t}\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t} else if ( !isMatrixLike( x ) ) {\n\t\tconst msg = 'invalid input argument. The first argument must be a matrix or an array-of-arrays. Value: `' + x + '`';\n\t\tthrow new TypeError( msg );\n\t}\n\treturn new LassoFit( y, x, lambda );\n}\n\n\n// EXPORTS //\n\nexport default lasso;\n","// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport Alert from 'react-bootstrap/Alert';\nimport contains from '@stdlib/assert/contains';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport Button from 'react-bootstrap/Button';\nimport Tooltip from '@isle-project/components/tooltip';\nimport Table from '@isle-project/components/table';\nimport multiply from '@isle-project/utils/multiply';\nimport zScore from '@isle-project/utils/zscore';\nimport { withPropCheck } from '@isle-project/utils/prop-check';\nimport { Factor } from '@isle-project/utils/factor-variable';\nimport designMatrix from './design_matrix.js';\nimport LASSO from './lasso.js';\n\n\n// VARIABLES //\n\nlet COUNTER = 0;\n\n\n// FUNCTIONS //\n\nconst summaryTable = ( x, intercept, result, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('predictor')}</th>\n\t\t\t\t\t<th>{t('coefficient')}</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{ intercept ? <tr>\n\t\t\t\t\t<th>{t('intercept')}</th>\n\t\t\t\t\t<td>{result.beta[ 0 ].toFixed( 6 )}</td>\n\t\t\t\t</tr> : null }\n\t\t\t\t{x.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t<td>{result.beta[ idx+Number(intercept) ].toFixed( 6 )}</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nconst fitModel = ({ x, y, lambda, data, quantitative, intercept }) => {\n\ttry {\n\t\tlet yvalues = data[ y ];\n\t\tyvalues = zScore( yvalues, false, true );\n\t\tconst { matrix, predictors, categoricalStats, standardized } = designMatrix( x, data, quantitative, intercept );\n\t\tconst result = new LASSO( matrix, yvalues, lambda );\n\n\t\t// Convert back coefficients to original scale:\n\t\tif ( intercept ) {\n\t\t\tlet coefSum = 0.0;\n\t\t\tfor ( let i = 1; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i-1 ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * standardized[ pred ].mu );\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * categoricalStats[ pred ].mu );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.beta[ 0 ] = yvalues.mu - coefSum;\n\t\t} else {\n\t\t\tfor ( let i = 0; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tpredictors,\n\t\t\tresult,\n\t\t\tyvalues\n\t\t};\n\t} catch ( _ ) {\n\t\treturn {};\n\t}\n};\n\n\n// MAIN //\n\n/**\n* LASSO regression.\n*\n* @property {Object} data - object of value arrays\n* @property {string} y - outcome variable\n* @property {Array<string>} x - one or more predictor variables\n* @property {Array<string>} quantitative - array of variables in `data` that are `quantitative`\n* @property {number} lambda - regularization parameter\n* @property {boolean} intercept - controls whether to fit a model with an intercept term\n* @property {Function} onPredict - callback invoked with a predict function to make predictions for new data\n*/\nclass LassoRegression extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\n\t\tCOUNTER += 1;\n\t\tconst { x, y, lambda, data, quantitative, intercept } = props;\n\t\tthis.state = {\n\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t...props\n\t\t};\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.quantitative !== prevState.quantitative ||\n\t\t\tnextProps.x !== prevState.x ||\n\t\t\tnextProps.y !== prevState.y ||\n\t\t\tnextProps.intercept !== prevState.intercept ||\n\t\t\tnextProps.lambda !== prevState.lambda\n\t\t) {\n\t\t\tconst { x, y, lambda, data, quantitative, intercept } = nextProps;\n\t\t\treturn {\n\t\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\n\thandlePredict = () => {\n\t\tconst predict = ( data ) => {\n\t\t\tconst { matrix } = designMatrix( this.props.x, data, this.props.quantitative, this.props.intercept );\n\t\t\tlet fitted = this.state.result.predict( matrix );\n\n\t\t\t// Convert fitted values back to original scale before standardizing:\n\t\t\tfitted = multiply( fitted, this.state.yvalues.sigma );\n\t\t\tconst residuals = new Array( fitted.length );\n\t\t\tfor ( let i = 0; i < fitted.length; i++ ) {\n\t\t\t\tresiduals[ i ] = data[ this.props.y ][ i ] - fitted[ i ];\n\t\t\t}\n\t\t\treturn { fitted, residuals };\n\t\t};\n\t\tthis.props.onPredict( predict, COUNTER );\n\t};\n\n\trender() {\n\t\tconst { y, intercept, lambda, onPredict, t } = this.props;\n\t\tconst { result, predictors } = this.state;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\tif ( !isNumber( lambda ) ) {\n\t\t\treturn <Alert variant=\"danger\">{t('lambda-not-number')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('lasso-title', { y, lambda: lambda.toFixed( 4 ), counter: COUNTER })}</span>\n\t\t\t\t{summaryTable( predictors, intercept, result, t )}\n\t\t\t\t<p>{result.testKKT() ? t('kkt-satisfied') : t('kkt-not-satisfied')}</p>\n\t\t\t\t{onPredict ? <Tooltip tooltip={t('use-model-to-predict-tooltip')} >\n\t\t\t\t\t<Button variant=\"secondary\" size=\"sm\" onClick={this.handlePredict}>{this.props.t('use-model-to-predict')}</Button>\n\t\t\t\t</Tooltip> : null}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nLassoRegression.defaultProps = {\n\tlambda: 1e-3,\n\tintercept: true,\n\tonPredict() {}\n};\n\nLassoRegression.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\ty: PropTypes.string.isRequired,\n\tx: PropTypes.oneOfType([\n\t\tPropTypes.arrayOf( PropTypes.oneOfType([ PropTypes.string, PropTypes.instanceOf( Factor ) ]) ),\n\t\tPropTypes.string,\n\t\tPropTypes.instanceOf( Factor )\n\t]).isRequired,\n\tquantitative: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tlambda: PropTypes.number,\n\tintercept: PropTypes.bool,\n\tonPredict: PropTypes.func\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'models' )( withPropCheck( LassoRegression ) );\n","/**\n* Computes a matrix product of a n x p matrix and a column vector of length p.\n*\n* @param {Matrix} A - n x p matrix\n* @param {Array} b - p x 1 column vector\n* @returns {Array} result of matrix multiplication\n*/\nfunction mmult( A, b ) {\n\tconst n = A.shape[ 0 ];\n\tconst p = A.shape[ 1 ];\n\n\tlet ret = new Float64Array( n );\n\tfor ( let i = 0; i < n; i++ ) {\n\t\t\tlet sum = 0;\n\t\t\tfor ( let j = 0; j < p; j++ ) {\n\t\t\t\tsum += A.get( i, j ) * b[ j ];\n\t\t\t}\n\t\t\tret[ i ] = sum;\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default mmult;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport ndarray from '@stdlib/ndarray/ctor';\n\n\n// MAIN //\n\n/**\n* Transposes a matrix.\n*\n* @param {Matrix} X - input matrix (2d `ndarray`)\n* @returns matrix transpose\n*/\nconst transpose = ( X ) => {\n\tconst shape = [ X.shape[ 1 ], X.shape[ 0 ] ];\n\tconst strides = [ X.strides[ 1 ], X.strides[ 0 ] ];\n\tconst offset = X.offset;\n\tconst order = X.order;\n\treturn ndarray( 'float64', X._buffer, shape, strides, offset, order );\n};\n\n\n// EXPORTS //\n\nexport default transpose;\n"],"sourceRoot":""}
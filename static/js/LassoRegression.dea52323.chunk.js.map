{"version":3,"sources":["../node_modules/@stdlib/assert/is-array-array/lib/index.js","../node_modules/@stdlib/assert/is-array-array/lib/main.js","../node_modules/@stdlib/utils/define-nonenumerable-property/lib/index.js","../node_modules/@stdlib/utils/define-nonenumerable-property/lib/main.js","../node_modules/@isle-project/utils/multiply/index.js","../node_modules/@isle-project/utils/zscore/index.js","../node_modules/@isle-project/components/models/lasso-regression/design_matrix.js","../node_modules/@isle-project/utils/divide/index.js","../node_modules/@isle-project/components/models/lasso-regression/dotm.js","../node_modules/@isle-project/components/models/lasso-regression/dotv.js","../node_modules/@isle-project/components/models/lasso-regression/soft_thresholding.js","../node_modules/@isle-project/components/models/lasso-regression/lasso.js","../node_modules/@isle-project/components/models/lasso-regression/main.js","../node_modules/@isle-project/utils/mmult/index.js","../node_modules/@isle-project/utils/transpose/index.js"],"names":[],"mappings":"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","file":"static/js/LassoRegression.dea52323.chunk.js","sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Test if a value is an array of arrays.\n*\n* @module @stdlib/assert/is-array-array\n*\n* @example\n* var isArrayArray = require( '@stdlib/assert/is-array-array' );\n*\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\n\n// MODULES //\n\nvar isArrayArray = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = isArrayArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar arrayfun = require( './../../tools/array-function' );\nvar isArray = require( './../../is-array' );\n\n\n// MAIN //\n\n/**\n* Tests if a value is an array of arrays.\n*\n* @name isArrayArray\n* @type {Function}\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating whether a value is an array of arrays\n*\n* @example\n* var bool = isArrayArray( [ [], [] ] );\n* // returns true\n*\n* bool = isArrayArray( [ {}, {} ] );\n* // returns false\n*\n* bool = isArrayArray( [] );\n* // returns false\n*/\nvar isArrayArray = arrayfun( isArray );\n\n\n// EXPORTS //\n\nmodule.exports = isArrayArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Define a non-enumerable property.\n*\n* @module @stdlib/utils/define-nonenumerable-property\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n* var setNonEnumerableProperty = require( '@stdlib/utils/define-nonenumerable-property' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\n\n// MODULES //\n\nvar setNonEnumerableProperty = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = setNonEnumerableProperty;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar defineProperty = require( './../../define-property' );\n\n\n// MAIN //\n\n/**\n* Defines a non-enumerable property.\n*\n* @param {Object} obj - object on which to define the property\n* @param {(string|symbol)} prop - property name\n* @param {*} value - value to set\n*\n* @example\n* var objectKeys = require( '@stdlib/utils/keys' );\n*\n* var obj = {};\n*\n* setNonEnumerableProperty( obj, 'foo', 'bar' );\n*\n* var v = obj.foo;\n* // returns 'bar'\n*\n* var keys = objectKeys( obj );\n* // returns []\n*/\nfunction setNonEnumerableProperty( obj, prop, value ) {\n\tdefineProperty( obj, prop, {\n\t\t'configurable': true,\n\t\t'enumerable': false,\n\t\t'writable': true,\n\t\t'value': value\n\t});\n}\n\n\n// EXPORTS //\n\nmodule.exports = setNonEnumerableProperty;\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise multiplication.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction multiply( arr, x ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be multiplied must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] * x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default multiply;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport mean from '@isle-project/utils/statistic/mean';\nimport stdev from '@isle-project/utils/statistic/stdev';\nimport setNonEnumerableProperty from '@stdlib/utils/define-nonenumerable-property';\n\n\n// MAIN //\n\n/**\n* Standardizes elements in input array.\n*\n* @param {Array} x - input array\n* @param {boolean} demean - controls whether the mean should be subtracted from the values\n* @param {boolean} scale - controls whether values should be divided by the standard deviation\n* @returns {Array} output array with added `mu` and `sigma` properties\n*/\nfunction zScore( x, demean = true, scale = true ) {\n\tconst avg = mean( x );\n\tconst sd = stdev( x );\n\tconst len = x.length;\n\n\tconst out = new Array( len );\n\tif ( demean ) {\n\t\tif ( scale ) {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg ) / sd;\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\tout[ i ] = ( x[ i ] - avg );\n\t\t\t}\n\t\t}\n\t}\n\telse if ( scale ) {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = x[ i ] / sd;\n\t\t}\n\t}\n\telse {\n\t\tout = x.slice();\n\t}\n\tsetNonEnumerableProperty( out, 'mu', avg );\n\tsetNonEnumerableProperty( out, 'sigma', sd );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default zScore;\n","// MODULES //\n\nimport isArray from '@stdlib/assert/is-array';\nimport countBy from '@stdlib/utils/count-by';\nimport identity from '@stdlib/utils/identity-function';\nimport objectKeys from '@stdlib/utils/keys';\nimport sqrt from '@stdlib/math/base/special/sqrt';\nimport contains from '@stdlib/assert/contains';\nimport zScore from '@isle-project/utils/zscore';\n\n\n// MAIN //\n\n/**\n * Returns the design matrix for a lasso regression model.\n *\n * @param {Array} x - predictor variables\n * @param {Object} data - data object\n * @param {Array} quantitative - array of quantitative predictors\n * @param {boolean} intercept - boolean indicating whether to include an intercept\n * @returns {Object} object with design `matrix`, list of `predictors`, `categoricalStats`, and `standardized` values\n */\nfunction designMatrix( x, data, quantitative, intercept ) {\n\tif ( !isArray( x ) ) {\n\t\tx = [ x ];\n\t}\n\tconst matrix = [];\n\tconst predictors = [];\n\tconst hash = {};\n\tconst standardized = {};\n\tconst categoricalStats = {};\n\tconst nobs = data[ x[ 0 ] ].length;\n\tfor ( let j = 0; j < x.length; j++ ) {\n\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\tconst values = zScore( data[ x[ j ] ] );\n\t\t\tstandardized[ x[ j ] ] = values;\n\t\t\tpredictors.push( x[ j ] );\n\t\t} else {\n\t\t\tconst values = data[ x[ j ] ];\n\t\t\tconst counts = countBy( values, identity );\n\t\t\tconst categories = x[ j ].categories || objectKeys( counts );\n\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\tconst label = `${x[ j ]}_${categories[ k ]}`;\n\t\t\t\tpredictors.push( label );\n\t\t\t\tconst p = counts[ categories[ k ] ] / nobs;\n\t\t\t\tcategoricalStats[ label ] = {\n\t\t\t\t\tmu: p,\n\t\t\t\t\tsigma: sqrt( p * (1-p) )\n\t\t\t\t};\n\t\t\t}\n\t\t\thash[ x[ j ] ] = categories;\n\t\t}\n\t}\n\tfor ( let i = 0; i < nobs; i++ ) {\n\t\tconst row = [];\n\t\tif ( intercept ) {\n\t\t\trow.push( 1 );\n\t\t}\n\t\tfor ( let j = 0; j < x.length; j++ ) {\n\t\t\tif ( contains( quantitative, x[ j ] ) ) {\n\t\t\t\tconst values = standardized[ x[ j ] ];\n\t\t\t\trow.push( values[ i ] );\n\t\t\t} else {\n\t\t\t\tconst values = data[ x[ j ] ];\n\t\t\t\tconst categories = hash[ x[ j ] ];\n\t\t\t\tconst val = values[ i ];\n\t\t\t\tfor ( let k = intercept ? 1 : 0; k < categories.length; k++ ) {\n\t\t\t\t\tconst { mu, sigma } = categoricalStats[ `${x[ j ]}_${categories[ k ]}` ];\n\t\t\t\t\trow.push(\n\t\t\t\t\t\t( val === categories[ k ] ) ?\n\t\t\t\t\t\t( 1 - mu ) / sigma :\n\t\t\t\t\t\t-mu / sigma\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatrix.push( row );\n\t}\n\treturn { matrix, predictors, categoricalStats, standardized };\n}\n\n\n// EXPORTS //\n\nexport default designMatrix;\n","// MODULES //\n\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\n\n\n// MAIN //\n\n/**\n* Computes an element-wise division.\n*\n* @param {NumberArray} arr - input array\n* @param {(NumberArray|number)} x - either an array of equal length or a scalar\n* @returns {NumberArray} output array\n*/\nfunction divide( arr, x, opts ) {\n\tconst isArr = isArrayLike( x );\n\tif ( !isArrayLike( arr ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide an array. Value: `' + arr + '`.' );\n\t}\n\tif ( !isArr && !isNumber( x ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Second argument must either be an array or number primitive. Value: `' + x + '`.' );\n\t}\n\tconst len = arr.length;\n\tconst out = new Array( len );\n\n\t// Case 1: x is an array\n\tif ( isArr ) {\n\t\tif ( len !== x.length ) {\n\t\t\tthrow new Error( 'invalid input argument. Array to be divided must have a length equal to that of the input array.' );\n\t\t}\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x[ i ];\n\t\t}\n\t}\n\t// Case 2: scalar\n\telse {\n\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr[ i ] / x;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default divide;\n","// MAIN //\n\n/**\n* Calculates the dot product between j-th column vectors of the two input matrices skipping zero elements.\n*\n* @param {Matrix} x - first input matrix\n* @param {Matrix} y - second input matrix\n* @param {number} j - column index\n* @returns {number} dot product value\n*/\nfunction dotm( x, y, j ) {\n\tlet ret = 0.0;\n\tconst nRows = x.shape[ 0 ];\n\tfor ( let i = 0; i < nRows; i++ ) {\n\t\tconst xVal = x.get( i, j );\n\t\tconst yVal = y.get( i, j );\n\t\tif ( xVal !== 0 && yVal !== 0 ) {\n\t\t\tret += xVal * yVal;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default dotm;\n","// MAIN //\n\n/**\n* Calculates the dot product between two arrays.\n*\n* @param {NumberArray} x - first vector\n* @param {NumberArray} y - second vector\n* @returns {number} dot product\n*/\nfunction dotv( x, y ) {\n\tconst len = x.length;\n\tlet sum = 0.0;\n\tfor ( let i = 0; i < len; i++ ) {\n\t\tsum += x[ i ] * y[ i ];\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nexport default dotv;\n","// MAIN //\n\n/**\n* Soft-thresholding operator.\n*\n* @param {number} x - input value\n* @param {number} t - threshold value\n* @returns {number} return value\n*/\nfunction softThresholding( x, t ) {\n\tif ( x > t ) {\n\t\treturn x - t;\n\t} else if ( x < -t ) {\n\t\treturn x + t;\n\t}\n\treturn 0;\n}\n\n\n// EXPORTS //\n\nexport default softThresholding;\n","// MODULES //\n\nimport logger from 'debug';\nimport incrspace from '@stdlib/array/incrspace';\nimport sign from '@stdlib/math/base/special/signum';\nimport isArrayArray from '@stdlib/assert/is-array-array';\nimport isMatrixLike from '@stdlib/assert/is-matrix-like';\nimport ctor from '@stdlib/ndarray/ctor';\nimport ndarray from '@stdlib/ndarray/array';\nimport isNumber from '@stdlib/assert/is-number';\nimport isArrayLike from '@stdlib/assert/is-array-like';\nimport abs from '@stdlib/math/base/special/abs';\nimport mmult from '@isle-project/utils/mmult';\nimport transpose from '@isle-project/utils/transpose';\nimport subtract from '@isle-project/utils/subtract';\nimport divide from '@isle-project/utils/divide';\nimport dotm from './dotm.js';\nimport dotv from './dotv.js';\nimport softThresholding from './soft_thresholding.js';\n\n\n// VARIABLES //\n\nconst debug = logger( 'isle:lasso' );\nconst PRECISION = 1e-9;\n\n\n// FUNCTIONS //\n\nconst mget = ( x, j ) => {\n\tconst out = new Float64Array( x.shape[ 0 ] );\n\tfor ( let i = 0; i < out.length; i++ ) {\n\t\tout[ i ] = x.get( i, j );\n\t}\n\treturn out;\n};\n\n\n// MAIN //\n\n/**\n* Lasso object to fit regression.\n*\n* @constructor\n* @returns {LassoFit} instance\n*/\nfunction LassoFit( y, x, lambda ) {\n\tthis.y = y;\n\tthis.x = x;\n\tthis.lambda = lambda;\n\n\tthis.N = x.shape[ 0 ];\n\tthis.p = x.shape[ 1 ];\n\n\t// Initialize model parameters to zero:\n\tthis.beta = new Float64Array( this.p );\n\tthis.betast = new Float64Array( this.p );\n\n\t// Initialize active set to all predictors:\n\tthis.active = incrspace( 0, this.beta.length, 1 );\n\tthis.nonactive = [];\n\n\t// Matrix holding partial residuals:\n\tthis.presid = ctor( 'float64', new Float64Array( x._buffer.length ), x.shape, x.strides, x.offset, x.order );\n\n\tthis.init = () => {\n\t\tthis.iteration = 0;\n\t\tthis.iterate();\n\t};\n\tthis.init();\n}\n\n/**\n* Checks the Karush-Khun-Tucker (KKT) conditions for an optimal solution.\n*\n* @returns {boolean} returns true if optimal conditions are satisfied, false otherwise\n*/\nLassoFit.prototype.testKKT = function testKKT() {\n\tconst beta = this.beta;\n\tconst N = this.N;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tconst ymxb = subtract( y, mmult( x, beta ) );\n\tconst G = divide( mmult( transpose( x ), ymxb ), N );\n\tfor ( let i = 0; i < beta.length; i++ ) {\n\t\tif ( beta[ i ] === 0 ) {\n\t\t\tif ( abs( G[i] ) > this.lambda + PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( beta[ i ] > 0 ) {\n\t\t\tif ( G[i] - this.lambda * sign( beta[i] ) > PRECISION ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};\n\n/**\n* Exclusion test for all predictors not in active set. If one or more predictors fail the test, they are included in the active set.\n*\n* @returns {boolean} returns true if active set was changed, false otherwise\n*/\nLassoFit.prototype.testActiveSet = function testActiveSet() {\n\tlet changed = false;\n\n\tconst { residuals } = this.predict( this.x );\n\n\t// See whether non-active variables all pass exclusion test:\n\tfor ( let j = 0; j < this.nonactive.length; j++ ) {\n\t\tconst jVal = this.nonactive[ j ];\n\t\tconst xj = mget( this.x, jVal );\n\t\tif ( abs( dotv( xj, residuals ) ) / this.N > this.lambda ) {\n\t\t\t// Test failed: include predictor in active set -> iterate again\n\t\t\tthis.active.push( jVal );\n\t\t\tthis.nonactive.splice( j, 1 );\n\t\t\tchanged = true;\n\t\t}\n\t}\n\tdebug( 'Active set changes...' );\n\treturn changed;\n};\n\n/**\n* Iterate over the active set of predictors and perform coordinate descent until convergence.\n*\n* @returns {void}\n*/\nLassoFit.prototype.iterate = function iterate() {\n\tconst N = this.N;\n\tconst p = this.p;\n\tconst x = this.x;\n\tconst y = this.y;\n\n\tthis.iteration += 1;\n\tif ( this.iteration > 10000 ) {\n\t\t// Break out after maximum number of iterations is reached...\n\t\treturn;\n\t}\n\n\tlet converged = true;\n\tfor ( let j = 0; j < this.active.length; j++ ) {\n\t\tconst jVal = this.active[ j ];\n\t\tfor ( let i = 0; i < N; i++ ) {\n\t\t\tconst rval = y[ i ];\n\t\t\tfor ( let k = 0; k < p; k++ ) {\n\t\t\t\trval -= ( jVal !== k ) ? x.get( i, k ) * this.beta[ k ] : 0;\n\t\t\t}\n\t\t\tthis.presid.set( i, jVal, rval );\n\t\t}\n\t\tthis.betast[ jVal ] = (1/N) * dotm( x, this.presid, jVal );\n\t\tconst betaOld = this.beta[ jVal ];\n\t\tconst betaNew = softThresholding( this.betast[ jVal ], this.lambda );\n\t\tif ( abs( betaNew - betaOld ) > PRECISION ) {\n\t\t\tconverged = false;\n\t\t}\n\t\tthis.beta[ jVal ] = betaNew;\n\t}\n\t// Recompute active set:\n\tfor ( let j = this.active.length - 1; j >= 0; j-- ) {\n\t\tconst jVal = this.active[ j ];\n\t\tif ( abs( this.beta[ jVal ] ) < PRECISION ) {\n\t\t\tthis.active.splice( j, 1 );\n\t\t\tthis.nonactive.push( jVal );\n\t\t}\n\t}\n\tif ( converged === false ) {\n\t\tthis.iterate();\n\t} else if ( this.testActiveSet() ) {\n\t\tthis.iterate();\n\t}\n};\n\n/**\n* Calculates the current model fitted values (yhat).\n*\n* @returns {Object} fitted values and residuals\n*/\nLassoFit.prototype.predict = function predict( x ) {\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t}\n\tconst fitted = mmult( x, this.beta );\n\treturn fitted;\n};\n\n\n// MAIN //\n\n/**\n* Fit lasso regression via coordinate descent.\n*\n* @param {Matrix|Array} x - design matrix\n* @param {NumberArray} y - response vector\n* @param {number} lambda - L1 penalty value\n* @returns {Object} regression model\n*/\nfunction lasso( x, y, lambda ) {\n\tif ( !isNumber ) {\n\t\tthrow new TypeError( 'invalid input argument. The third argument must be a number primitive. Value: `' + lambda + '`' );\n\t}\n\tif ( !isArrayLike( y ) ) {\n\t\tthrow new TypeError( 'invalid input argument. The second argument must be array-like. Value: `' + y + '`' );\n\t}\n\tif ( isArrayArray( x ) ) {\n\t\tx = ndarray( x );\n\t} else if ( !isMatrixLike( x ) ) {\n\t\tconst msg = 'invalid input argument. The first argument must be a matrix or an array-of-arrays. Value: `' + x + '`';\n\t\tthrow new TypeError( msg );\n\t}\n\treturn new LassoFit( y, x, lambda );\n}\n\n\n// EXPORTS //\n\nexport default lasso;\n","// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withTranslation } from 'react-i18next';\nimport Alert from 'react-bootstrap/Alert';\nimport contains from '@stdlib/assert/contains';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport Button from 'react-bootstrap/Button';\nimport Tooltip from '@isle-project/components/tooltip';\nimport Table from '@isle-project/components/table';\nimport multiply from '@isle-project/utils/multiply';\nimport zScore from '@isle-project/utils/zscore';\nimport { withPropCheck } from '@isle-project/utils/prop-check';\nimport { Factor } from '@isle-project/utils/factor-variable';\nimport designMatrix from './design_matrix.js';\nimport LASSO from './lasso.js';\n\n\n// VARIABLES //\n\nlet COUNTER = 0;\n\n\n// FUNCTIONS //\n\nconst summaryTable = ( x, intercept, result, t ) => {\n\treturn (\n\t\t<Table bordered size=\"sm\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>{t('predictor')}</th>\n\t\t\t\t\t<th>{t('coefficient')}</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{ intercept ? <tr>\n\t\t\t\t\t<th>{t('intercept')}</th>\n\t\t\t\t\t<td>{result.beta[ 0 ].toFixed( 6 )}</td>\n\t\t\t\t</tr> : null }\n\t\t\t\t{x.map( ( name, idx ) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<tr key={idx} >\n\t\t\t\t\t\t\t<th>{name}</th>\n\t\t\t\t\t\t\t<td>{result.beta[ idx+Number(intercept) ].toFixed( 6 )}</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t</Table>\n\t);\n};\n\nconst fitModel = ({ x, y, lambda, data, quantitative, intercept }) => {\n\ttry {\n\t\tlet yvalues = data[ y ];\n\t\tyvalues = zScore( yvalues, false, true );\n\t\tconst { matrix, predictors, categoricalStats, standardized } = designMatrix( x, data, quantitative, intercept );\n\t\tconst result = new LASSO( matrix, yvalues, lambda );\n\n\t\t// Convert back coefficients to original scale:\n\t\tif ( intercept ) {\n\t\t\tlet coefSum = 0.0;\n\t\t\tfor ( let i = 1; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i-1 ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * standardized[ pred ].mu );\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t\tcoefSum += ( result.beta[ i ] * categoricalStats[ pred ].mu );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.beta[ 0 ] = yvalues.mu - coefSum;\n\t\t} else {\n\t\t\tfor ( let i = 0; i < result.beta.length; i++ ) {\n\t\t\t\tconst pred = predictors[ i ];\n\t\t\t\tif ( contains( quantitative, pred ) ) {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / standardized[ pred ].sigma;\n\t\t\t\t} else {\n\t\t\t\t\tresult.beta[ i ] *= yvalues.sigma / categoricalStats[ pred ].sigma;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tpredictors,\n\t\t\tresult,\n\t\t\tyvalues\n\t\t};\n\t} catch ( _ ) {\n\t\treturn {};\n\t}\n};\n\n\n// MAIN //\n\n/**\n* LASSO regression.\n*\n* @property {Object} data - object of value arrays\n* @property {string} y - outcome variable\n* @property {Array<string>} x - one or more predictor variables\n* @property {Array<string>} quantitative - array of variables in `data` that are `quantitative`\n* @property {number} lambda - regularization parameter\n* @property {boolean} intercept - controls whether to fit a model with an intercept term\n* @property {Function} onPredict - callback invoked with a predict function to make predictions for new data\n*/\nclass LassoRegression extends Component {\n\tconstructor( props ) {\n\t\tsuper( props );\n\n\t\tCOUNTER += 1;\n\t\tconst { x, y, lambda, data, quantitative, intercept } = props;\n\t\tthis.state = {\n\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t...props\n\t\t};\n\t}\n\n\tstatic getDerivedStateFromProps( nextProps, prevState ) {\n\t\tif (\n\t\t\tnextProps.data !== prevState.data ||\n\t\t\tnextProps.quantitative !== prevState.quantitative ||\n\t\t\tnextProps.x !== prevState.x ||\n\t\t\tnextProps.y !== prevState.y ||\n\t\t\tnextProps.intercept !== prevState.intercept ||\n\t\t\tnextProps.lambda !== prevState.lambda\n\t\t) {\n\t\t\tconst { x, y, lambda, data, quantitative, intercept } = nextProps;\n\t\t\treturn {\n\t\t\t\t...fitModel({ x, y, lambda, data, quantitative, intercept }),\n\t\t\t\t...nextProps\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\n\thandlePredict = () => {\n\t\tconst predict = ( data ) => {\n\t\t\tconst { matrix } = designMatrix( this.props.x, data, this.props.quantitative, this.props.intercept );\n\t\t\tlet fitted = this.state.result.predict( matrix );\n\n\t\t\t// Convert fitted values back to original scale before standardizing:\n\t\t\tfitted = multiply( fitted, this.state.yvalues.sigma );\n\t\t\tconst residuals = new Array( fitted.length );\n\t\t\tfor ( let i = 0; i < fitted.length; i++ ) {\n\t\t\t\tresiduals[ i ] = data[ this.props.y ][ i ] - fitted[ i ];\n\t\t\t}\n\t\t\treturn { fitted, residuals };\n\t\t};\n\t\tthis.props.onPredict( predict, COUNTER );\n\t};\n\n\trender() {\n\t\tconst { y, intercept, lambda, onPredict, t } = this.props;\n\t\tconst { result, predictors } = this.state;\n\t\tif ( !result ) {\n\t\t\treturn <Alert variant=\"danger\">{t('missing-attributes')}</Alert>;\n\t\t}\n\t\tif ( !isNumber( lambda ) ) {\n\t\t\treturn <Alert variant=\"danger\">{t('lambda-not-number')}</Alert>;\n\t\t}\n\t\treturn (\n\t\t\t<div style={{ overflowX: 'auto', width: '100%' }}>\n\t\t\t\t<span className=\"title\" >{t('lasso-title', { y, lambda: lambda.toFixed( 4 ), counter: COUNTER })}</span>\n\t\t\t\t{summaryTable( predictors, intercept, result, t )}\n\t\t\t\t<p>{result.testKKT() ? t('kkt-satisfied') : t('kkt-not-satisfied')}</p>\n\t\t\t\t{onPredict ? <Tooltip tooltip={t('use-model-to-predict-tooltip')} >\n\t\t\t\t\t<Button variant=\"secondary\" size=\"sm\" onClick={this.handlePredict}>{this.props.t('use-model-to-predict')}</Button>\n\t\t\t\t</Tooltip> : null}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// PROPERTIES //\n\nLassoRegression.defaultProps = {\n\tlambda: 1e-3,\n\tintercept: true,\n\tonPredict() {}\n};\n\nLassoRegression.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\ty: PropTypes.string.isRequired,\n\tx: PropTypes.oneOfType([\n\t\tPropTypes.arrayOf( PropTypes.oneOfType([ PropTypes.string, PropTypes.instanceOf( Factor ) ]) ),\n\t\tPropTypes.string,\n\t\tPropTypes.instanceOf( Factor )\n\t]).isRequired,\n\tquantitative: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tlambda: PropTypes.number,\n\tintercept: PropTypes.bool,\n\tonPredict: PropTypes.func\n};\n\n\n// EXPORTS //\n\nexport default withTranslation( 'models' )( withPropCheck( LassoRegression ) );\n","/**\n* Computes a matrix product of a n x p matrix and a column vector of length p.\n*\n* @param {Matrix} A - n x p matrix\n* @param {Array} b - p x 1 column vector\n* @returns {Array} result of matrix multiplication\n*/\nfunction mmult( A, b ) {\n\tconst n = A.shape[ 0 ];\n\tconst p = A.shape[ 1 ];\n\n\tlet ret = new Float64Array( n );\n\tfor ( let i = 0; i < n; i++ ) {\n\t\t\tlet sum = 0;\n\t\t\tfor ( let j = 0; j < p; j++ ) {\n\t\t\t\tsum += A.get( i, j ) * b[ j ];\n\t\t\t}\n\t\t\tret[ i ] = sum;\n\t}\n\treturn ret;\n}\n\n\n// EXPORTS //\n\nexport default mmult;\n","/**\n* Copyright (C) 2020-present The ISLE Authors\n*\n* The isle-dashboard program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU Affero General Public License as\n* published by the Free Software Foundation, either version 3 of the\n* License, or (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU Affero General Public License for more details.\n*\n* You should have received a copy of the GNU Affero General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// MODULES //\n\nimport ndarray from '@stdlib/ndarray/ctor';\n\n\n// MAIN //\n\n/**\n* Transposes a matrix.\n*\n* @param {Matrix} X - input matrix (2d `ndarray`)\n* @returns matrix transpose\n*/\nconst transpose = ( X ) => {\n\tconst shape = [ X.shape[ 1 ], X.shape[ 0 ] ];\n\tconst strides = [ X.strides[ 1 ], X.strides[ 0 ] ];\n\tconst offset = X.offset;\n\tconst order = X.order;\n\treturn ndarray( 'float64', X._buffer, shape, strides, offset, order );\n};\n\n\n// EXPORTS //\n\nexport default transpose;\n"],"sourceRoot":""}
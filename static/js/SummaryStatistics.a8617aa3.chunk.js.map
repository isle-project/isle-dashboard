{"version":3,"sources":["../node_modules/@stdlib/utils/papply-right/lib/index.js","../node_modules/@stdlib/utils/papply-right/lib/papply_right.js","../node_modules/@isle-project/components/summary-statistics/grouped_complete_cases.js","../node_modules/@isle-project/components/summary-statistics/grouped_cases.js","../node_modules/@isle-project/components/summary-statistics/complete_cases.js","../node_modules/@isle-project/components/summary-statistics/by2_with_count.js","../node_modules/@isle-project/components/summary-statistics/by_with_count.js","../node_modules/@isle-project/components/summary-statistics/main.js"],"names":[],"mappings":"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","file":"static/js/SummaryStatistics.a8617aa3.chunk.js","sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Partially apply function arguments from the right.\n*\n* @module @stdlib/utils/papply-right\n*\n* @example\n* var papplyRight = require( '@stdlib/utils/papply-right' );\n*\n* function say( text, name ) {\n*     return text + ', ' + name + '.';\n* }\n*\n* var toGrace = papplyRight( say, 'Grace Hopper' );\n*\n* var str = toGrace( 'Hello' );\n* // returns 'Hello, Grace Hopper.'\n*\n* str = toGrace( 'Thank you' );\n* // returns 'Thank you, Grace Hopper.'\n*/\n\n// MODULES //\n\nvar papplyRight = require( './papply_right.js' );\n\n\n// EXPORTS //\n\nmodule.exports = papplyRight;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isFunction = require( '@stdlib/assert/is-function' );\n\n\n// MAIN //\n\n/**\n* Returns a function of smaller arity by partially applying arguments from the right.\n*\n* @param {Function} fcn - function to partially apply\n* @param {...*} [args] - arguments to partially apply\n* @throws {TypeError} first argument must be a function\n* @returns {Function} partially applied function\n*\n* @example\n* function say( text, name ) {\n*     return text + ', ' + name + '.';\n* }\n*\n* var toGrace = papplyRight( say, 'Grace Hopper' );\n*\n* var str = toGrace( 'Hello' );\n* // returns 'Hello, Grace Hopper.'\n*\n* str = toGrace( 'Thank you' );\n* // returns 'Thank you, Grace Hopper.'\n*/\nfunction papplyRight( fcn ) {\n\tvar pargs;\n\tvar len;\n\tvar i;\n\tif ( !isFunction( fcn ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be a function. Value: `' + fcn + '`.' );\n\t}\n\tlen = arguments.length - 1;\n\tpargs = new Array( len );\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\tpargs[ i-1 ] = arguments[ i ];\n\t}\n\treturn pappliedRight;\n\n\t/**\n\t* Partially applied function.\n\t*\n\t* @private\n\t* @param {...*} [args] - function arguments\n\t* @returns {*} partially applied function result\n\t*/\n\tfunction pappliedRight() {\n\t\tvar nargs;\n\t\tvar args;\n\t\tvar j;\n\t\tnargs = arguments.length;\n\t\targs = new Array( len+nargs );\n\t\tfor ( j = 0; j < args.length; j++ ) {\n\t\t\tif ( j >= nargs ) {\n\t\t\t\targs[ j ] = pargs[ j-nargs ];\n\t\t\t} else {\n\t\t\t\targs[ j ] = arguments[ j ];\n\t\t\t}\n\t\t}\n\t\treturn fcn.apply( null, args );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = papplyRight;\n","// MODULES //\n\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport isnan from '@stdlib/assert/is-nan';\n\n\n// MAIN //\n\n/**\n * Group complete cases of array values by group ids.\n *\n * @param {Array} arr - array of arrays\n * @param {Array} groupData - array of group ids\n * @returns {Object} grouped data\n */\nfunction groupedCompleteCases( arr, groupData ) {\n\tconst indices = [];\n\tconst len = arr[ 0 ].length;\n\tfor ( let j = 0; j < len; j++ ) {\n\t\tlet complete = true;\n\t\tfor ( let i = 0; i < arr.length; i++ ) {\n\t\t\tconst x = arr[ i ][ j ];\n\t\t\tif ( !isNumber( x ) || isnan( x ) ) {\n\t\t\t\tcomplete = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( complete ) {\n\t\t\tindices.push( j );\n\t\t}\n\t}\n\tconst out = {};\n\tfor ( let i = 0; i < arr.length; i++ ) {\n\t\tfor ( let j = 0; j < indices.length; j++ ) {\n\t\t\tconst group = groupData[ indices[ j ] ];\n\t\t\tif ( !out[ group ] ) {\n\t\t\t\tout[ group ] = new Array( arr.length );\n\t\t\t\tfor ( let k = 0; k < arr.length; k++ ) {\n\t\t\t\t\tout[ group ][ k ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst idx = indices[ j ];\n\t\t\tout[ group ][ i ].push( arr[ i ][ idx ] );\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default groupedCompleteCases;\n","// MAIN //\n\n/**\n * Group array values by group ids.\n *\n * @param {Array} arr - array of arrays\n * @param {Array} groupData - array of group ids\n * @returns {Object} grouped data\n */\nfunction groupedCases( arr, groupData ) {\n\tconst out = {};\n\tconst len = arr[ 0 ].length;\n\tfor ( let i = 0; i < arr.length; i++ ) {\n\t\tfor ( let j = 0; j < len; j++ ) {\n\t\t\tconst group = groupData[ j ];\n\t\t\tif ( !out[ group ] ) {\n\t\t\t\tout[ group ] = new Array( arr.length );\n\t\t\t\tfor ( let k = 0; k < arr.length; k++ ) {\n\t\t\t\t\tout[ group ][ k ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout[ group ][ i ].push( arr[ i ][ j ] );\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default groupedCases;\n","// MODULES //\n\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport isnan from '@stdlib/assert/is-nan';\n\n\n// MAIN //\n\n/**\n * Returns an array of arrays of complete cases.\n *\n * @param {Array} arr - array of arrays\n * @returns {Array} array of arrays of complete cases\n */\nfunction completeCases( arr ) {\n\tconst indices = [];\n\tconst len = arr[ 0 ].length;\n\tfor ( let j = 0; j < len; j++ ) {\n\t\tlet complete = true;\n\t\tfor ( let i = 0; i < arr.length; i++ ) {\n\t\t\tconst x = arr[ i ][ j ];\n\t\t\tif ( !isNumber( x ) || isnan( x ) ) {\n\t\t\t\tcomplete = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( complete ) {\n\t\t\tindices.push( j );\n\t\t}\n\t}\n\tconst out = new Array( arr.length );\n\tfor ( let i = 0; i < arr.length; i++ ) {\n\t\tconst arr = new Array( indices.length );\n\t\tfor ( let j = 0; j < indices.length; j++ ) {\n\t\t\tconst idx = indices[ j ];\n\t\t\tarr[ j ] = arr[ i ][ idx ];\n\t\t}\n\t\tout[ i ] = arr;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default completeCases;\n","// MODULES //\n\nimport isArray from '@stdlib/assert/is-array';\nimport extractUsedCategories from '@isle-project/utils/extract-used-categories';\nimport objectKeys from '@stdlib/utils/keys';\n\n\n// VARIABLES //\n\nconst SORT_OPTS = {\n\t'numeric': true // Use numeric collation such that \"1\" < \"2\" < \"10\"...\n};\n\n\n// MAIN //\n\n/**\n * Applies a function to elements of two arrays by group(s).\n *\n * @param {Array} arr1 - first array\n * @param {Array} arr2 - second array\n * @param {Array} factor - array of factors\n * @param {Function} functions - functions to apply to each array\n * @param {string} [group] - group variable\n * @returns {Object} object with `keys` holding used categories and the `result`s for each label\n */\nfunction by2WithCount( arr1, arr2, factor, functions, group ) {\n\tlet result = {};\n\tlet ret1 = {};\n\tlet ret2 = {};\n\tfor ( let i = 0; i < factor.length; i++ ) {\n\t\tif ( !isArray( ret1[ factor[ i ] ]) ) {\n\t\t\tret1[ factor[ i ] ] = [];\n\t\t\tret2[ factor[ i ] ] = [];\n\t\t}\n\t\tret1[ factor[ i ] ].push( arr1[ i ]);\n\t\tret2[ factor[ i ] ].push( arr2[ i ]);\n\t}\n\tlet keys;\n\tif ( group.length === 1 ) {\n\t\tkeys = extractUsedCategories( ret1, group[ 0 ] );\n\t} else {\n\t\tkeys = objectKeys( ret1 );\n\t\tkeys.sort( ( a, b ) => a.localeCompare( b, void 0, SORT_OPTS ) );\n\t}\n\tfor ( let i = 0; i < keys.length; i++ ) {\n\t\tconst key = keys[ i ];\n\t\tresult[ key ] = {\n\t\t\tvalue: functions.map( f => f( ret1[ key ], ret2[ key ]) ),\n\t\t\tsize: ret1[ key ].length\n\t\t};\n\t}\n\treturn { keys, result };\n}\n\n\n// EXPORTS //\n\nexport default by2WithCount;\n","// MODULES //\n\nimport isArray from '@stdlib/assert/is-array';\nimport extractUsedCategories from '@isle-project/utils/extract-used-categories';\nimport objectKeys from '@stdlib/utils/keys';\n\n\n// VARIABLES //\n\nconst SORT_OPTS = {\n\t'numeric': true // Use numeric collation such that \"1\" < \"2\" < \"10\"...\n};\n\n\n// MAIN //\n\n/**\n * Applies a function to elements of an array by group(s).\n *\n * @param {Array} arr - array of values\n * @param {Array} factor - factor variable array\n * @param {Array} functions - array of functions\n * @param {Array} [group] - group variable(s)\n * @returns {Object} object with `keys` holding used categories and the `result`s for each label\n */\nfunction byWithCount( arr, factor, functions, group ) {\n\tlet table = {};\n\tfor ( let i = 0; i < arr.length; i++ ) {\n\t\tif ( !isArray( table[ factor[ i ] ]) ) {\n\t\t\ttable[ factor[ i ] ] = [];\n\t\t}\n\t\ttable[ factor[ i ] ].push( arr[ i ]);\n\t}\n\tlet keys = objectKeys( table );\n\tif ( group.length === 2 ) {\n\t\tconst cat1 = group[ 0 ].categories;\n\t\tconst cat2 = group[ 1 ].categories;\n\t\tif ( cat1 && cat2 ) {\n\t\t\tkeys.sort( ( a, b ) => {\n\t\t\t\tconst as = a.split( ':' );\n\t\t\t\tconst bs = b.split( ':' );\n\t\t\t\tlet diff = cat1.indexOf( as[ 0 ] ) - cat1.indexOf( bs[ 0 ] );\n\t\t\t\tif ( diff !== 0 ) {\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t\tdiff = cat2.indexOf( as[ 1 ] ) - cat2.indexOf( bs[ 1 ] );\n\t\t\t\treturn diff;\n\t\t\t});\n\t\t}\n\t\telse if ( cat1 ) {\n\t\t\tkeys.sort( ( a, b ) => {\n\t\t\t\tconst as = a.split( ':' );\n\t\t\t\tconst bs = b.split( ':' );\n\t\t\t\tlet diff = cat1.indexOf( as[ 0 ] ) - cat1.indexOf( bs[ 0 ] );\n\t\t\t\tif ( diff !== 0 ) {\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t\treturn as[ 1 ].localeCompare( bs[ 1 ], void 0, SORT_OPTS );\n\t\t\t});\n\t\t}\n\t\telse if ( cat2 ) {\n\t\t\tkeys.sort( ( a, b ) => {\n\t\t\t\tconst as = a.split( ':' );\n\t\t\t\tconst bs = b.split( ':' );\n\t\t\t\tlet diff = as[ 0 ].localeCompare( bs[ 0 ], void 0, SORT_OPTS );\n\t\t\t\tif ( diff !== 0 ) {\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t\tdiff = cat2.indexOf( as[ 1 ] ) - cat2.indexOf( bs[ 1 ] );\n\t\t\t\treturn diff;\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tkeys.sort( ( a, b ) => a.localeCompare( b, void 0, SORT_OPTS ) );\n\t\t}\n\t} else if ( group.length === 1 && group[ 0 ].categories ) {\n\t\tkeys = extractUsedCategories( table, group[ 0 ] );\n\t} else {\n\t\tkeys.sort( ( a, b ) => a.localeCompare( b, void 0, SORT_OPTS ) );\n\t}\n\tconst out = {};\n\tfor ( let i = 0; i < keys.length; i++ ) {\n\t\tconst key = keys[ i ];\n\t\tout[ key ] = {\n\t\t\tvalue: functions.map( f => f( table[ key ] ) ),\n\t\t\tsize: table[ key ].length\n\t\t};\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default byWithCount;\n","// MODULES //\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { useTranslation } from 'react-i18next';\nimport papplyRight from '@stdlib/utils/papply-right';\nimport round from '@stdlib/math/base/special/round';\nimport objectKeys from '@stdlib/utils/keys';\nimport isArray from '@stdlib/assert/is-array';\nimport entries from '@stdlib/utils/entries';\nimport { isPrimitive as isNumber } from '@stdlib/assert/is-number';\nimport isnan from '@stdlib/assert/is-nan';\nimport Table from '@isle-project/components/table';\nimport statistic from '@isle-project/utils/statistic';\nimport { Factor } from '@isle-project/utils/factor-variable';\nimport { withPropCheck } from '@isle-project/utils/prop-check';\nimport groupedCompleteCases from './grouped_complete_cases.js';\nimport groupedCases from './grouped_cases.js';\nimport completeCases from './complete_cases.js';\nimport by2WithCount from './by2_with_count.js';\nimport byWithCount from './by_with_count.js';\n\n\n// VARIABLES //\n\nconst N = 'N';\nconst IQR = 'IQR';\n\n\n// FUNCTIONS //\n\nconst IQRTable = ({ e, t }) => {\n\tconst table = <Table bordered size=\"sm\">\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>{t('variable')}</th>\n\t\t\t\t<th>{IQR}</th>\n\t\t\t\t<th>{t('lower')}</th>\n\t\t\t\t<th>{t('upper')}</th>\n\t\t\t\t<th>{N}</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t{entries( e.result ).map( ( res, idx ) => {\n\t\t\t\treturn ( <tr key={idx} >\n\t\t\t\t\t<td>{res[ 0 ]}</td>\n\t\t\t\t\t{res[ 1 ].value[ 0 ].map( ( e, i ) =>\n\t\t\t\t\t\t<td key={i}>{e.toFixed( 3 )}</td>\n\t\t\t\t\t)}\n\t\t\t\t\t<td>{res[ 1 ].size}</td>\n\t\t\t\t</tr> );\n\t\t\t})}\n\t\t</tbody>\n\t</Table>;\n\treturn table;\n};\n\nconst RangeTable = ({ e, t }) => {\n\tconst table = <Table bordered size=\"sm\">\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>{t('variable')}</th>\n\t\t\t\t<th>{t('range')}</th>\n\t\t\t\t<th>{t('min')}</th>\n\t\t\t\t<th>{t('max')}</th>\n\t\t\t\t<th>{N}</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t{entries( e.result ).map( ( res, idx ) => {\n\t\t\t\treturn ( <tr key={idx} >\n\t\t\t\t\t<td>{res[ 0 ]}</td>\n\t\t\t\t\t{res[ 1 ].value[ 0 ].map( ( e, i ) =>\n\t\t\t\t\t\t<td key={i}>{e.toFixed( 3 )}</td>\n\t\t\t\t\t)}\n\t\t\t\t\t<td>{res[ 1 ].size}</td>\n\t\t\t\t</tr> );\n\t\t\t})}\n\t\t</tbody>\n\t</Table>;\n\treturn table;\n};\n\nconst CorrelationTable = ( props ) => {\n\tconst title = props.group ? props.group : 'Correlation Matrix';\n\tconst thead = <thead>\n\t\t<tr>\n\t\t\t<th>{title} (N={props.result.size})</th>\n\t\t\t{props.variables.map( ( x, i ) => <th key={i}>{x}</th> )}\n\t\t</tr>\n\t</thead>;\n\tconst tbody = <tbody>\n\t\t{props.variables.map( ( x, i ) => {\n\t\t\treturn (\n\t\t\t\t<tr key={i}>\n\t\t\t\t\t<th>{x}</th>\n\t\t\t\t\t{props.result.value[ i ].map( ( y, j ) => <td key={j}>{y.toFixed( 3 )}</td> )}\n\t\t\t\t</tr>\n\t\t\t);\n\t\t})}\n\t</tbody>;\n\treturn ( <Table bordered size=\"sm\" {...props} >\n\t\t{thead}\n\t\t{tbody}\n\t</Table> );\n};\n\nconst CorrelationMatrix = ({ e, t }) => {\n\tif ( e.group ) {\n\t\tconst tables = [];\n\t\tconst keys = objectKeys( e.result );\n\t\tfor ( let i = 0; i < keys.length; i++ ) {\n\t\t\tconst key = keys[ i ];\n\t\t\tconst table = <CorrelationTable\n\t\t\t\tkey={key}\n\t\t\t\tgroup={key}\n\t\t\t\tresult={e.result[ key ]}\n\t\t\t\tvariables={e.variables}\n\t\t\t/>;\n\t\t\ttables.push( table );\n\t\t}\n\t\treturn tables;\n\t}\n\treturn <CorrelationTable result={e.result} variables={e.variables} />;\n};\n\nfunction generateStatistics({ data, t, statistics, variables, secondVariable, group, omit, quantiles }) {\n\tconst funs = [];\n\tconst statLabels = [];\n\tfor ( let i = 0; i < statistics.length; i++ ) {\n\t\tconst stat = statistics[ i ];\n\t\tif ( stat === 'Quantile' ) {\n\t\t\tfor ( let j = 0; j < quantiles.length; j++ ) {\n\t\t\t\tconst quantile = quantiles[ j ];\n\t\t\t\tfuns.push(\n\t\t\t\t\tpapplyRight( statistic( stat ), quantile, 5 )\n\t\t\t\t);\n\t\t\t\tstatLabels.push(\n\t\t\t\t\t`${round( quantile*100 )}% ${t('quantile')}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tfuns.push( statistic( stat ) );\n\t\t\tstatLabels.push( stat );\n\t\t}\n\t}\n\tif ( statLabels[ 0 ] === 'Correlation Matrix' ) {\n\t\tlet arrs = variables.map( x => data[ x ] );\n\t\tif ( group ) {\n\t\t\tlet groupData;\n\t\t\tif ( group.length === 2 ) {\n\t\t\t\tgroupData = [];\n\t\t\t\tfor ( let i = 0; i < arrs[ 0 ].length; i++ ) {\n\t\t\t\t\tconst groupLabel = group.map( g => {\n\t\t\t\t\t\treturn data[ g ][ i ];\n\t\t\t\t\t}).join( ':' );\n\t\t\t\t\tgroupData.push( groupLabel );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgroupData = data[ group[ 0 ] ];\n\t\t\t}\n\t\t\tif ( omit ) {\n\t\t\t\tarrs = groupedCompleteCases( arrs, groupData );\n\t\t\t} else {\n\t\t\t\tarrs = groupedCases( arrs, groupData );\n\t\t\t}\n\t\t} else if ( omit ) {\n\t\t\tarrs = completeCases( arrs );\n\t\t}\n\t\tlet result;\n\t\tif ( group ) {\n\t\t\tresult = {};\n\t\t\tconst keys = objectKeys( arrs );\n\t\t\tfor ( let i = 0; i < keys.length; i++ ) {\n\t\t\t\tresult[ keys[ i ] ] = {\n\t\t\t\t\tvalue: funs.map( f => f.apply( null, arrs[ keys[ i ] ] ) )[ 0 ],\n\t\t\t\t\tsize: arrs[ keys[ i ] ][ 0 ].length\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tconst value = funs.map( f => f.apply( null, arrs ) );\n\t\t\tresult = {\n\t\t\t\tvalue: value[ 0 ],\n\t\t\t\tsize: arrs[ 0 ].length\n\t\t\t};\n\t\t}\n\t\tconst output = {\n\t\t\tvariables: variables,\n\t\t\tstatistics: statLabels,\n\t\t\ttype: 'Statistics',\n\t\t\tresult,\n\t\t\tgroup\n\t\t};\n\t\treturn output;\n\t}\n\tconst result = {};\n\tfor ( let i = 0; i < variables.length; i++ ) {\n\t\tlet groupData;\n\t\tlet res;\n\t\tlet x;\n\t\tlet y;\n\t\tlet variable = variables[ i ];\n\t\tif ( group ) {\n\t\t\tif ( omit ) {\n\t\t\t\t// Case: grouping variable selected, omit missing values\n\t\t\t\tx = [];\n\t\t\t\ty = [];\n\t\t\t\tgroupData = [];\n\t\t\t\tif ( variable && secondVariable ) {\n\t\t\t\t\tlet first = data[ variable ];\n\t\t\t\t\tlet second = data[ secondVariable ];\n\t\t\t\t\tfor ( let i = 0; i < first.length; i++ ) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t( isNumber( first[ i ] ) && !isnan( first[ i ] ) ) &&\n\t\t\t\t\t\t\t( isNumber( second[ i ] ) && !isnan( second[ i ] ) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tx.push( first[ i ] );\n\t\t\t\t\t\t\ty.push( second[ i ] );\n\t\t\t\t\t\t\tconst groupLabel = group.map( g => {\n\t\t\t\t\t\t\t\treturn data[ g ][ i ];\n\t\t\t\t\t\t\t}).join( ':' );\n\t\t\t\t\t\t\tgroupData.push( groupLabel );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet first = data[ variable ];\n\t\t\t\t\tfor ( let i = 0; i < first.length; i++ ) {\n\t\t\t\t\t\tif ( isNumber( first[ i ] ) && !isnan( first[ i ] ) ) {\n\t\t\t\t\t\t\tx.push( first[ i ] );\n\t\t\t\t\t\t\tconst groupLabel = group.map( g => {\n\t\t\t\t\t\t\t\treturn data[ g ][ i ];\n\t\t\t\t\t\t\t}).join( ':' );\n\t\t\t\t\t\t\tgroupData.push( groupLabel );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Case: grouping variable(s) selected, do not omit missing values\n\t\t\t\tx = data[ variable ];\n\t\t\t\ty = data[ secondVariable ];\n\t\t\t\tif ( group.length === 2 ) {\n\t\t\t\t\tgroupData = [];\n\t\t\t\t\tfor ( let i = 0; i < data[ variable ].length; i++ ) {\n\t\t\t\t\t\tconst groupLabel = group.map( g => {\n\t\t\t\t\t\t\treturn data[ g ][ i ];\n\t\t\t\t\t\t}).join( ':' );\n\t\t\t\t\t\tgroupData.push( groupLabel );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgroupData = data[ group[ 0 ] ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( statLabels[ 0 ] === 'Correlation' ) {\n\t\t\t\tconst out = by2WithCount( x, y, groupData, funs, group );\n\t\t\t\tres = out.result;\n\t\t\t\tconst keys = out.keys;\n\t\t\t\tfor ( let i = 0; i < keys.length; i++ ) {\n\t\t\t\t\tconst key = keys[ i ];\n\n\t\t\t\t\t// Extract correlation coefficient from correlation matrix:\n\t\t\t\t\tres[ key ].value = res[ key ].value.map( mat => mat[ 0 ][ 1 ] );\n\t\t\t\t}\n\t\t\t\tvariable = `${variable} ${t('vs')} ${secondVariable}`;\n\t\t\t} else {\n\t\t\t\tres = byWithCount( x, groupData, funs, group );\n\t\t\t}\n\t\t} else {\n\t\t\t// Case: no grouping variable selected\n\t\t\tif ( omit ) {\n\t\t\t\tx = [];\n\t\t\t\ty = [];\n\t\t\t\tif ( variable && secondVariable ) {\n\t\t\t\t\tlet first = data[ variable ];\n\t\t\t\t\tlet second = data[ secondVariable ];\n\t\t\t\t\tfor ( let i = 0; i < first.length; i++ ) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t( isNumber( first[ i ] ) && !isnan( first[ i ] ) ) &&\n\t\t\t\t\t\t\t( isNumber( second[ i ] ) && !isnan( second[ i ] ) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tx.push( first[ i ] );\n\t\t\t\t\t\t\ty.push( second[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet first = data[ variable ];\n\t\t\t\t\tfor ( let i = 0; i < first.length; i++ ) {\n\t\t\t\t\t\tif ( isNumber( first[ i ] ) && !isnan( first[ i ] ) ) {\n\t\t\t\t\t\t\tx.push( first[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = data[ variable ];\n\t\t\t\ty = data[ secondVariable ];\n\t\t\t}\n\t\t\tif ( statLabels[ 0 ] === 'Correlation' ) {\n\t\t\t\tconst value = funs.map( f => {\n\t\t\t\t\tconst r = f( x, y );\n\t\t\t\t\treturn r[ 0 ][ 1 ];\n\t\t\t\t});\n\n\t\t\t\t// Extract correlation coefficient from correlation matrix:\n\t\t\t\tres = {\n\t\t\t\t\tvalue,\n\t\t\t\t\tsize: x.length\n\t\t\t\t};\n\t\t\t\tvariable = `${variable} ${t('vs')} ${secondVariable}`;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = {\n\t\t\t\t\tvalue: funs.map( f => f( x ) ),\n\t\t\t\t\tsize: x.length\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tresult[ variable ] = res;\n\t}\n\tconst output = {\n\t\tvariables: variables,\n\t\tstatistics: statLabels,\n\t\ttype: 'Statistics',\n\t\tresult,\n\t\tgroup\n\t};\n\treturn output;\n}\n\n\n// MAIN //\n\nfunction SummaryStatistics({ variables, statistics, data, secondVariable, group, omit, quantiles }) {\n\tconst { t } = useTranslation( 'data-explorer' );\n\tconst e = useMemo( () => {\n\t\treturn generateStatistics({ data, t, statistics, variables, secondVariable, group, omit, quantiles });\n\t}, [ data, statistics, variables, group, omit, quantiles, secondVariable, t ] );\n\tif ( e.group ) {\n\t\tif ( e.statistics.length === 1 && e.statistics[0] === 'Correlation Matrix' ) {\n\t\t\treturn <CorrelationMatrix e={e} t={t} />;\n\t\t}\n\t\tconst variables = entries( e.result );\n\t\tlet header;\n\t\tif ( e.statistics.length === 1 && e.statistics[0] === 'Range' ) {\n\t\t\theader = <tr>\n\t\t\t\t<th className=\"not-sortable\" >{t('variable')}</th>\n\t\t\t\t{e.group.map( ( x, i ) => <th key={i} >{x}</th> )}\n\t\t\t\t<th>{t('range')}</th>\n\t\t\t\t<th>{t('min')}</th>\n\t\t\t\t<th>{t('max')}</th>\n\t\t\t\t<th>{N}</th>\n\t\t\t</tr>;\n\t\t} else if ( e.statistics.length === 1 && e.statistics[0] === 'Interquartile Range' ) {\n\t\t\theader = <tr>\n\t\t\t\t<th className=\"not-sortable\" >{t('variable')}</th>\n\t\t\t\t{e.group.map( ( x, i ) => <th key={i} >{x}</th> )}\n\t\t\t\t<th>{IQR}</th>\n\t\t\t\t<th>{t('lower')}</th>\n\t\t\t\t<th>{t('upper')}</th>\n\t\t\t\t<th>{N}</th>\n\t\t\t</tr>;\n\t\t} else {\n\t\t\theader = <tr>\n\t\t\t\t<th className=\"not-sortable\" >{variables.length > 1 ? 'Variable' : variables[ 0 ][ 0 ]}</th>\n\t\t\t\t{e.group.map( ( x, i ) => <th key={i} >{x}</th> )}\n\t\t\t\t{e.statistics.map( ( name, i ) => {\n\t\t\t\t\treturn <th key={i}>{name}</th>;\n\t\t\t\t})}\n\t\t\t\t<th>{N}</th>\n\t\t\t</tr>;\n\t\t}\n\t\tconst table = <Table bordered size=\"sm\" >\n\t\t\t<thead>\n\t\t\t\t{header}\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{variables.map( ( res ) => {\n\t\t\t\t\tlet grouped = entries( res[ 1 ] );\n\t\t\t\t\tgrouped = grouped.map( ( arr, groupIndex ) => {\n\t\t\t\t\t\tlet cats;\n\t\t\t\t\t\tif ( e.group.length > 1 ) {\n\t\t\t\t\t\t\tcats = arr[ 0 ].split( ':' ).map( ( x, i ) => {\n\t\t\t\t\t\t\t\treturn <td key={i} >{x}</td>;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcats = <td>{arr[ 0 ]}</td>;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<tr key={groupIndex} >\n\t\t\t\t\t\t\t\t<td>{variables.length > 1 ? res[ 0 ] : ''}</td>\n\t\t\t\t\t\t\t\t{cats}\n\t\t\t\t\t\t\t\t{arr[ 1 ].value.map( ( v, groupIndex ) => {\n\t\t\t\t\t\t\t\t\tif ( isArray( v ) ) {\n\t\t\t\t\t\t\t\t\t\tif ( e.statistics.length === 1 ) {\n\t\t\t\t\t\t\t\t\t\t\t// eslint-disable-next-line max-nested-callbacks\n\t\t\t\t\t\t\t\t\t\t\treturn v.map( ( elem, i ) => {\n\t\t\t\t\t\t\t\t\t\t\t\treturn <td key={i} >{elem.toFixed( 3 )}</td>;\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn <td key={groupIndex} >{v[ 0 ].toFixed( 3 )}</td>;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn <td key={groupIndex} >{v.toFixed( 3 )}</td>;\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t<td>{arr[ 1 ].size} </td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\treturn grouped;\n\t\t\t\t})}\n\t\t\t</tbody>\n\t\t</Table>;\n\t\treturn table;\n\t}\n\tif ( e.statistics.length === 1 ) {\n\t\tif ( e.statistics[0] === 'Range' ) {\n\t\t\treturn <RangeTable e={e} t={t} />;\n\t\t}\n\t\tif ( e.statistics[0] === 'Interquartile Range' ) {\n\t\t\treturn <IQRTable e={e} t={t} />;\n\t\t}\n\t\tif ( e.statistics[0] === 'Correlation Matrix' ) {\n\t\t\treturn <CorrelationMatrix e={e} t={t} />;\n\t\t}\n\t}\n\tconst table = <Table bordered size=\"sm\">\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th className=\"not-sortable\" >{t('variable')}</th>\n\t\t\t\t{e.statistics.map( ( name, i ) => {\n\t\t\t\t\treturn <th key={i}>{name}</th>;\n\t\t\t\t})}\n\t\t\t\t<th>{N}</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t{entries( e.result ).map( ( res ) => {\n\t\t\t\treturn (\n\t\t\t\t\t<tr key={res[ 0 ]} >\n\t\t\t\t\t\t<td>{res[ 0 ]}</td>\n\t\t\t\t\t\t{res[ 1 ].value.map( ( v, i ) => {\n\t\t\t\t\t\t\tif ( isArray( v ) ) {\n\t\t\t\t\t\t\t\t// Case: Range or IQR, use first element:\n\t\t\t\t\t\t\t\treturn <td key={i} >{v[ 0 ].toFixed( 3 )}</td>;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn <td key={i} >{v.toFixed( 3 )}</td>;\n\t\t\t\t\t\t})}\n\t\t\t\t\t\t<td>{res[ 1 ].size}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t);\n\t\t\t})}\n\t\t</tbody>\n\t</Table>;\n\treturn table;\n}\n\n\n// PROPERTIES //\n\nSummaryStatistics.propTypes = {\n\tdata: PropTypes.object.isRequired,\n\tvariables: PropTypes.arrayOf( PropTypes.string ).isRequired,\n\tstatistics: PropTypes.arrayOf( PropTypes.oneOf([\n\t\t'Mean',\n\t\t'Median',\n\t\t'Min',\n\t\t'Max',\n\t\t'Range',\n\t\t'Interquartile Range',\n\t\t'Standard Deviation',\n\t\t'Variance',\n\t\t'Correlation',\n\t\t'Correlation Matrix',\n\t\t'Skewness',\n\t\t'Excess Kurtosis',\n\t\t'First Quartile',\n\t\t'Third Quartile',\n\t\t'Quantile',\n\t\t'Five-Number Summary'\n\t]) ).isRequired,\n\tsecondVariable: PropTypes.string,\n\tomit: PropTypes.bool,\n\tgroup: PropTypes.arrayOf( PropTypes.oneOfType([\n\t\tPropTypes.string,\n\t\tPropTypes.instanceOf( Factor )\n\t]) ),\n\tquantiles: PropTypes.array\n};\n\nSummaryStatistics.defaultProps = {\n\tsecondVariable: null,\n\tomit: false,\n\tgroup: null,\n\tquantiles: null\n};\n\n\n// EXPORTS //\n\n/**\n* Summary statistics\n*\n* @property {Object} data - object of value arrays\n* @property {Array<string>} statistics - statistics(s) to calculate for the selected variables (either 'Mean', `Median`, `Min`, `Max`, `Range`, `Interquartile Range`, `Standard Deviation`, `Variance`, `Correlation`, `Correlation Matrix`, `Skewness`, `Excess Kurtosis`, `First Quartile`, `Third Quartile`, or `Quantile`)\n* @property {Array<string>} variables - variable(s) for which to calculate statistics\n* @property {Array<(string|Factor)>} group - name of grouping variable(s)\n* @property {boolean} omit - controls whether to omit missing values\n* @property {string} secondVariable - second variable for correlation statistic\n* @property {Array<number>} quantiles - array of quantiles to calculate for `Quantile` statistic\n*/\nexport default withPropCheck( SummaryStatistics );\n"],"sourceRoot":""}
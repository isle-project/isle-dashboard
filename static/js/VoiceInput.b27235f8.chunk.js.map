{"version":3,"file":"static/js/VoiceInput.b27235f8.chunk.js","mappings":"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","sources":["../node_modules/@isle-project/components/input/voice/microphone.js","../node_modules/@isle-project/components/input/voice/main.js"],"sourcesContent":["// MODULES //\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Microphone from '-!svg-react-loader!./img/microphone.svg';\n\n\n// MAIN //\n\nclass Shim extends Component {\n\trender() {\n\t\treturn <button onClick={this.props.onClick} ></button>;\n\t}\n}\n\n\nShim.propTypes = {\n\tonClick: PropTypes.func\n};\n\nShim.defaultProps = {\n\tonClick() {}\n};\n\n\n// EXPORTS //\n\nexport default Microphone || Shim;\n","// MODULES //\n\nimport React, { Fragment, useCallback, useContext, useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport logger from 'debug';\nimport { useTranslation } from 'react-i18next';\nimport Tooltip from 'react-bootstrap/Tooltip';\nimport OverlayTrigger from '@isle-project/components/overlay-trigger';\nimport SessionContext from '@isle-project/session/context.js';\nimport { i18n } from '@isle-project/locales';\nimport Microphone from './microphone.js';\nimport './voice.css';\n\n\n// VARIABLES //\n\nconst debug = logger( 'isle:voice-input' );\n\n\n// FUNCTIONS //\n\nfunction getSpeechRecognition() {\n\ttry {\n\t\tconst SpeechRecognition = SpeechRecognition || webkitSpeechRecognition; //eslint-disable-line\n\t\tif ( SpeechRecognition ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} catch ( error) {\n\t\treturn false;\n\t}\n}\n\nfunction createGrammarList( grammars ) {\n\tconst SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList; //eslint-disable-line\n\tconst grammarList = new SpeechGrammarList();\n\tfor ( let i = 0; i < grammars.length; i++ ) {\n\t\tconst { src, weight } = grammars[ i ];\n\t\tgrammarList.addFromString( src, weight );\n\t}\n\treturn grammarList;\n}\n\n\n// MAIN //\n\n/**\n* A voice input component.\n*\n* @property {boolean} autorecord - controls whether to automatically start recording\n* @property {string} defaultValue - default text value\n* @property {Array} grammars - speech grammar list (unsupported)\n* @property {string} legend - legend displayed in front of input field\n* @property {string} mode - set to `full` to display a text input field alongside the microphone, `status` to only display a statusbar with the transcribed texts, `microphone` to show just a button to toggle recording, or `none` when the voice input should be invisible and purely controlled via hotkeys / voice commands\n* @property {number} maxAlternatives - maximum number of alternatives provided per speech recognition result\n* @property {Function} onChange - callback function invoked when text input value is updated\n* @property {Function} onClick - callback function invoked when clicking on the microphone button\n* @property {Function} onFinalText - callback function invoked once final text is received\n* @property {Function} onSegment - callback function invoked with text segments\n* @property {Function} onRecordingStart - callback function invoked when recording is started\n* @property {Function} onRecordingStop - callback function invoked once recording is stopped\n* @property {Function} onSubmit - callback function when submitting text input value by hitting \"Enter\"\n* @property {string} placeholder - text input placeholder\n* @property {Object} remote - object with `start`, `stop`, and `toggle` and associated hotkeys\n* @property {Function} timeout - number of milliseconds after which to timeout the recording\n* @property {Function} stopTooltip - tooltip message displayed while recording\n* @property {Function} startTooltip - tooltip message displayed while not recording\n* @property {string} tooltipPlacement - direction of the tooltip\n* @property {number} width - voice input width (in px)\n* @property {number} height - voice input height (in px)\n* @property {string} className - class name\n* @property {Object} style - CSS inline styles\n*/\nconst VoiceInput = ( props ) => {\n\tconst { autorecord, bind, defaultValue, grammars, id,\n\t\tmaxAlternatives, remote, startTooltip, stopTooltip, speechInterface,\n\t\tonChange, onClick, onFinalText, onRecordingStart, onRecordingStop, onSegment, onSubmit, timeout } = props;\n\tconst [ isRecording, setIsRecording ] = useState( autorecord );\n\tconst session = useContext( SessionContext );\n\tconst { t } = useTranslation( 'input' );\n\tconst [ value, setValue ] = useState(\n\t\tbind && session.state ? session.state[ bind ]: defaultValue,\n\t);\n\tconst recognizerRef = useRef();\n\tconst timerRef = useRef();\n\n\tconst handleChange = useCallback( ( event ) => {\n\t\tconst newValue = event.target.value;\n\t\tsetValue( newValue );\n\t\tonChange( newValue );\n\t\tif ( bind ) {\n\t\t\tglobal.lesson.setState({\n\t\t\t\t[ bind ]: newValue\n\t\t\t});\n\t\t}\n\t}, [ bind, onChange ] );\n\n\tconst handleKeyDown = useCallback( ( event ) => {\n\t\tswitch ( event.keyCode ) {\n\t\tcase 13:\n\t\t\tonSubmit( value );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}, [ value, onSubmit ] );\n\n\tconst stop = useCallback( () => {\n\t\tdebug( 'Set `isRecording` to false...' );\n\t\tsetIsRecording( false );\n\t\tif ( recognizerRef.current ) {\n\t\t\trecognizerRef.current.stop();\n\t\t}\n\t\tonRecordingStop();\n\t}, [ onRecordingStop ] );\n\n\tconst start = useCallback( () => {\n\t\trecognizerRef.current = null;\n\t\tconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; //eslint-disable-line\n\t\tif ( SpeechRecognition ) {\n\t\t\tconst recognizer = new SpeechRecognition();\n\t\t\trecognizer.lang = i18n.language;\n\t\t\trecognizer.continuous = true;\n\t\t\trecognizer.interimResults = true;\n\t\t\trecognizer.maxAlternatives = maxAlternatives;\n\t\t\trecognizer.grammars = createGrammarList( grammars );\n\n\t\t\trecognizer.onerror = ( event ) => {\n\t\t\t\tdebug( 'Encountered an error...' );\n\t\t\t\tif (\n\t\t\t\t\tevent.error === 'not-allowed' ||\n\t\t\t\t\tevent.error === 'service-not-allowed'\n\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\tsetIsRecording( false );\n\t\t\t\t\t\treturn session.addNotification({\n\t\t\t\t\t\t\ttitle: 'Not allowed',\n\t\t\t\t\t\t\tmessage: 'No permission to use the speech recognition service',\n\t\t\t\t\t\t\tlevel: 'error',\n\t\t\t\t\t\t\tposition: 'tr'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\trecognizer.start();\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\tdebug( err );\n\t\t\t\t}\n\t\t\t};\n\t\t\trecognizer.onend = () => {\n\t\t\t\tdebug('onend: %s', id );\n\t\t\t\tif ( isRecording ) {\n\t\t\t\t\t// Restart recording after it stopped due to no voice input for a few seconds:\n\t\t\t\t\trecognizer.start();\n\t\t\t\t}\n\t\t\t};\n\t\t\trecognizer.onstart = () => {\n\t\t\t\tdebug('onstart: %s', id );\n\t\t\t\tonRecordingStart();\n\t\t\t};\n\t\t\trecognizer.onresult = ( event ) => {\n\t\t\t\tdebug( 'Processing result...' );\n\t\t\t\tif ( typeof ( event.results ) === 'undefined' ) {\n\t\t\t\t\tdebug( 'Something went wrong...' );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor ( let i = event.resultIndex; i < event.results.length; ++i ) {\n\t\t\t\t\tconst results = event.results[ i ];\n\t\t\t\t\tif ( event.results[ i ].isFinal ) {\n\t\t\t\t\t\tif ( timeout ) {\n\t\t\t\t\t\t\ttimerRef.current = setTimeout( stop, timeout );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdebug( 'Received final text' );\n\t\t\t\t\t\tlet text;\n\t\t\t\t\t\tif ( maxAlternatives > 1 ) {\n\t\t\t\t\t\t\ttext = new Array( results.length );\n\t\t\t\t\t\t\tfor ( let i = 0; i < results.length; i++ ) {\n\t\t\t\t\t\t\t\ttext[ i ] = results[ i ].transcript;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext = results[ 0 ].transcript;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetValue( text );\n\t\t\t\t\t\tonFinalText( text );\n\t\t\t\t\t\tif ( speechInterface ) {\n\t\t\t\t\t\t\tspeechInterface.check( text, {\n\t\t\t\t\t\t\t\tonStart: () => {\n\t\t\t\t\t\t\t\t\tstop();\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tonEnd: () => {\n\t\t\t\t\t\t\t\t\tstart();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ( timerRef.current ) {\n\t\t\t\t\t\t\tclearTimeout( timerRef.current );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet text;\n\t\t\t\t\t\tif ( maxAlternatives > 1 ) {\n\t\t\t\t\t\t\ttext = new Array( results.length );\n\t\t\t\t\t\t\tfor ( let i = 0; i < results.length; i++ ) {\n\t\t\t\t\t\t\t\ttext[ i ] = results[ i ].transcript;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext = results[ 0 ].transcript;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetValue( text );\n\t\t\t\t\t\tonSegment( text );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\trecognizer.start();\n\t\t\trecognizerRef.current = recognizer;\n\t\t}\n\t\tdebug( 'Set `isRecording` to true...' );\n\t\tsetIsRecording( true );\n\t}, [ grammars, id, isRecording, maxAlternatives, onRecordingStart, session, speechInterface, stop, timeout, onFinalText, onSegment ] );\n\n\tconst tooltipMessage = useCallback( ( recognizable ) => {\n\t\tlet text = '';\n\t\tif ( !recognizable ) {\n\t\t\ttext = 'Your browser does not support voice recognition. You may use the Chrome Browser instead';\n\t\t}\n\t\telse if ( isRecording === true ) {\n\t\t\ttext = stopTooltip || t('click-to-stop-recording');\n\t\t}\n\t\telse {\n\t\t\ttext = startTooltip || t('click-to-start-recording');\n\t\t}\n\t\treturn text;\n\t}, [ isRecording, startTooltip, stopTooltip, t ] );\n\n\tuseEffect( () => {\n\t\tif ( remote ) {\n\t\t\twindow.onkeydown = ( event ) => {\n\t\t\t\tswitch ( event.keyCode ) {\n\t\t\t\t\tcase remote.stop:\n\t\t\t\t\t\tstop();\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase remote.start:\n\t\t\t\t\t\tif ( !isRecording ) {\n\t\t\t\t\t\t\tstart();\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase remote.toggle:\n\t\t\t\t\t\tif ( !isRecording ) {\n\t\t\t\t\t\t\tstart();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstop();\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif ( autorecord ) {\n\t\t\tdebug( 'Should record voice...' );\n\t\t\tstart();\n\t\t}\n\t}, [ autorecord, remote, isRecording, start, stop ] );\n\n\tconst handleClick = useCallback( ( event ) => {\n\t\tonClick( event );\n\t\tif ( isRecording ){\n\t\t\tstop();\n\t\t}\n\t\telse {\n\t\t\tstart();\n\t\t}\n\t}, [ isRecording, start, stop, onClick ] );\n\n\tlet mike = 'voice-microphone';\n\tif ( isRecording === true ) {\n\t\tmike = 'voice-microphone voice-recording';\n\t}\n\tconst x = getSpeechRecognition();\n\tconst text = tooltipMessage( x );\n\tconst tooltip = <Tooltip id={`${props.id}-voice-input-tooltip`} >\n\t\t{text}\n\t</Tooltip>;\n\tswitch ( props.mode ) {\n\t\tcase 'full':\n\t\t\treturn (\n\t\t\t\t<Fragment>\n\t\t\t\t\t{ props.legend ? <label>{props.legend}</label> : null }\n\t\t\t\t\t<div className={`input voice-input ${props.className}`} style={{ height: props.height, width: props.width, ...props.style }} >\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tclassName=\"voice-input-text\"\n\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\t\t\t\tonChange={handleChange}\n\t\t\t\t\t\t\tplaceholder={props.placeholder !== null ? props.placeholder : t('enter-text')}\n\t\t\t\t\t\t\tvalue={value}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<OverlayTrigger placement={props.tooltipPlacement} overlay={tooltip}>\n\t\t\t\t\t\t\t<Microphone onClick={handleClick} className={mike} />\n\t\t\t\t\t\t</OverlayTrigger>\n\t\t\t\t\t</div>\n\t\t\t\t</Fragment>\n\t\t\t);\n\t\tcase 'status':\n\t\t\treturn (\n\t\t\t\t<Fragment>\n\t\t\t\t\t{ props.legend ? <label>{props.legend}</label> : null }\n\t\t\t\t\t<div className={`voice-input-status-text ${props.className}`} style={{ height: props.height, width: props.width, ...props.style }} >\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName=\"voice-input-status\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{value}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<OverlayTrigger placement=\"bottom\" overlay={tooltip}>\n\t\t\t\t\t\t\t<Microphone onClick={handleClick} className={mike} />\n\t\t\t\t\t\t</OverlayTrigger>\n\t\t\t\t\t</div>\n\t\t\t\t</Fragment>\n\t\t\t);\n\t\tcase 'microphone':\n\t\t\treturn (\n\t\t\t\t<Fragment>\n\t\t\t\t\t{ props.legend ? <label>{props.legend}</label> : null }\n\t\t\t\t\t<div className={`voice-solo-microphone ${props.className}`} style={{ height: props.height, width: props.width, ...props.style }}>\n\t\t\t\t\t\t<OverlayTrigger placement=\"bottom\" overlay={tooltip}>\n\t\t\t\t\t\t\t<Microphone onClick={handleClick} className={mike} />\n\t\t\t\t\t\t</OverlayTrigger>\n\t\t\t\t\t</div>\n\t\t\t\t</Fragment>\n\t\t\t);\n\t\tcase 'none':\n\t\t\treturn null;\n\t}\n};\n\n\n// PROPERTIES //\n\nVoiceInput.defaultProps = {\n\tautorecord: false,\n\tdefaultValue: '',\n\tgrammars: [],\n\tlegend: '',\n\tmode: 'full',\n\tmaxAlternatives: 1,\n\tonChange() {},\n\tonClick() {},\n\tonFinalText() {},\n\tonSegment() {},\n\tonRecordingStart() {},\n\tonRecordingStop() {},\n\tonSubmit() {},\n\tplaceholder: null,\n\tremote: null,\n\tclassName: '',\n\tstyle: {},\n\ttimeout: null,\n\tstopTooltip: null,\n\tstartTooltip: null,\n\ttooltipPlacement: 'left',\n\twidth: 500,\n\theight: 36\n};\n\nVoiceInput.propTypes = {\n\tautorecord: PropTypes.bool,\n\tdefaultValue: PropTypes.string,\n\tgrammars: PropTypes.array,\n\tlegend: PropTypes.oneOfType([\n\t\tPropTypes.string,\n\t\tPropTypes.node\n\t]),\n\tmode: PropTypes.string,\n\tmaxAlternatives: PropTypes.number,\n\tonChange: PropTypes.func,\n\tonClick: PropTypes.func,\n\tonFinalText: PropTypes.func,\n\tonRecordingStart: PropTypes.func,\n\tonRecordingStop: PropTypes.func,\n\tonSegment: PropTypes.func,\n\tonSubmit: PropTypes.func,\n\tplaceholder: PropTypes.string,\n\tremote: PropTypes.object,\n\tclassName: PropTypes.string,\n\tstyle: PropTypes.object,\n\ttimeout: PropTypes.number,\n\tstopTooltip: PropTypes.string,\n\tstartTooltip: PropTypes.string,\n\ttooltipPlacement: PropTypes.oneOf([ 'top', 'right', 'bottom', 'left' ]),\n\twidth: PropTypes.number,\n\theight: PropTypes.number\n};\n\n\n// EXPORTS //\n\nexport default VoiceInput;\n"],"names":["Shim","onClick","this","props","Component","defaultProps","Microphone","debug","logger","VoiceInput","autorecord","bind","defaultValue","grammars","id","maxAlternatives","remote","startTooltip","stopTooltip","speechInterface","onChange","onFinalText","onRecordingStart","onRecordingStop","onSegment","onSubmit","timeout","useState","isRecording","setIsRecording","session","useContext","SessionContext","t","useTranslation","state","value","setValue","recognizerRef","useRef","timerRef","handleChange","useCallback","event","newValue","target","global","lesson","setState","handleKeyDown","keyCode","stop","current","start","SpeechRecognition","window","webkitSpeechRecognition","recognizer","lang","i18n","continuous","interimResults","SpeechGrammarList","webkitSpeechGrammarList","grammarList","i","length","src","weight","addFromString","createGrammarList","onerror","error","addNotification","title","message","level","position","err","onend","onstart","onresult","results","resultIndex","isFinal","setTimeout","text","Array","transcript","check","onStart","onEnd","clearTimeout","tooltipMessage","recognizable","useEffect","onkeydown","toggle","handleClick","mike","getSpeechRecognition","tooltip","Tooltip","mode","Fragment","legend","className","style","height","width","type","onKeyDown","placeholder","placement","tooltipPlacement","overlay"],"sourceRoot":""}
/*! For license information please see NaiveBayes.de01134e.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkisle_dashboard=self.webpackChunkisle_dashboard||[]).push([[139],{53145:function(t,e,s){s.d(e,{i:function(){return g},W:function(){return E}});var n=s(89506),r=s.n(n),i=s(75891),a=s.n(i),l=s(42415),o=s(80386),c=s.n(o),h=s(34064),u=s.n(h),p=s(22949),f=s.n(p),m=s(53318);function d(t){return u()(t)||c()(t)}function y(t){return(0,l.isPrimitive)(t)&&!u()(t)}function g(t,e,s,n){let i=[];const l=[],o={};f()(t)||(t=[t]);for(let a=0;a<t.length;a++){const e=s[t[a]];if(r()(n,t[a]))l.push(t[a]);else{const s=(0,m.Z)(e,t[a]);for(let e=0;e<s.length;e++)l.push(`${t[a]}_${s[e]}`);o[t[a]]=s}}const c=s[t[0]].length;for(let a=0;a<c;a++){const e=[];for(let i=0;i<t.length;i++){const l=s[t[i]];if(r()(n,t[i]))e.push(l[a]);else{const s=o[t[i]],n=l[a];for(let t=0;t<s.length;t++)e.push(n===s[t]?1:0)}}i.push(e)}i=a()(i);return{matrix:i,predictors:l,yvalues:s[e]}}function E(t,e,s,n){let i=[];const l=[],o={};f()(t)||(t=[t]);for(let a=0;a<t.length;a++){const e=s[t[a]];if(r()(n,t[a]))l.push(t[a]);else{const s=(0,m.Z)(e,t[a]);for(let e=0;e<s.length;e++)l.push(`${t[a]}_${s[e]}`);o[t[a]]=s}}const c=s[t[0]].length,h=[];for(let a=0;a<c;a++){const l=[];let c=!1;for(let e=0;e<t.length;e++){const i=s[t[e]];if(r()(n,t[e]))y(i[a])?l.push(i[a]):c=!0;else{const s=o[t[e]],n=i[a];if(d(n))c=!0;else for(let t=0;t<s.length;t++)l.push(n===s[t]?1:0)}}d(s[e][a])&&(c=!0),c||(i.push(l),h.push(s[e][a]))}return i=a()(i),{matrix:i,predictors:l,yvalues:h}}},35623:function(t,e,s){s.r(e),s.d(e,{default:function(){return X}});var n=s(38603),r=s(91532),i=s.n(r),a=s(58651),l=s(79174),o=s(93918),c=s(5883),h=s(89506),u=s.n(h),p=s(56488),f=s.n(p),m=s(94123),d=s(75891),y=s.n(d),g=(s(74802),s(11120)),E=s.n(g),v=s(7474),b=s.n(v),w=s(22372),x=s.n(w),Z=(s(42415),s(92881)),A=s.n(Z),P=s(12083),k=s.n(P),q=s(5377),M=s.n(q),O=s(16231),T=s.n(O),$=s(84111),F=s(40094),G=s(28965),V=s(16684);function z(t,e){this.n=t.shape[0],this.p=t.shape[1],this.classes=A()(e.slice()),this.nclass=this.classes.length,this.fitGaussian(t,e)}z.prototype.score=s(90861),z.prototype.fitGaussian=function(t,e){this.prior={};const s=[this.p,this.nclass];this.mu=y()(new Float64Array(s[0]*s[1]),{shape:s}),this.sigma=y()(new Float64Array(s[0]*s[1]),{shape:s});for(let n=0;n<this.nclass;n++){const s=[],r=this.classes[n];for(let t=0;t<this.n;t++)e[t]===r&&s.push(t);const i=s.length;this.prior[r]=k()(i/this.n);for(let e=0;e<this.p;e++){const r=s.map((s=>t.get(s,e))),i=(0,$.Z)(r),a=(0,F.Z)(r);this.mu.set(e,n,i),this.sigma.set(e,n,a)}}},z.prototype.calcGaussianProb=function(t,e){const s=this.classes[e];let n=this.prior[s];for(let r=0;r<this.p;r++){const s=this.sigma.get(r,e),i=s*s,a=this.mu.get(r,e);n+=-.5*k()(2*T()*i)-M()(t[r]-a,2)/i}return n},z.prototype.predictOne=function(t){const e=this.classes.length,s=new Array(e);for(let i=0;i<e;i++)s[i]=this.calcGaussianProb(t,i);let n=s[0],r=this.classes[0];for(let i=0;i<e;i++){const t=s[i];t>n&&(n=t,r=this.classes[i])}return r},z.prototype.predict=function(t){const e=this.classes.length;if(E()(t)&&(t=y()(t)),x()(t)){const[s,n]=t.shape,r=new Array(s);for(let i=0;i<s;i++){const s=new Array(e);for(let r=0;r<e;r++){const e=new Array(n);for(let s=0;s<n;s++)e[s]=t.get(i,s);s[r]=this.calcGaussianProb(e,r)}let a=s[0],l=this.classes[0];for(let t=0;t<e;t++){const e=s[t];e>a&&(a=e,l=this.classes[t])}r[i]=l}return r}return this.predictOne(t)},z.prototype.predictProbs=function(t){if(E()(t)&&(t=y()(t)),x()(t)){const[e,s]=t.shape,n=new Array(e);for(let r=0;r<e;r++){let e=new Array(this.nclass);for(let n=0;n<this.nclass;n++){const i=new Array(s);for(let e=0;e<s;e++)i[e]=t.get(r,e);e[n]=this.calcGaussianProb(i,n)}const i=(0,G.Z)(e);let a=0;for(let t=0;t<e.length;t++)a+=f()(e[t]-i);const l=i+k()(a);e=(0,V.Z)(e,l),n[r]=e.map((t=>f()(t)))}return n}const e=new Array(this.nclass);for(let i=0;i<this.nclass;i++)e[i]=this.calcGaussianProb(t,i);const s=(0,G.Z)(e);let n=0;for(let i=0;i<e.length;i++)n+=f()(e[i]-s);const r=s+k()(n);return e=(0,V.Z)(e,r),e.map((t=>f()(t)))};var C=z;const R=t=>{let e=0;for(let s=0;s<t.length;s++)e+=t[s];return e};function _(t,e,s){this.n=t.shape[0],this.p=t.shape[1],this.classes=A()(e.slice()),this.nclass=this.classes.length,this.alpha=s,this.fitMultinomial(t,e)}_.prototype.score=s(90861),_.prototype.fitMultinomial=function(t,e){const s={},n=[this.p,this.nclass],r=y()(new Float64Array(n[0]*n[1]),{shape:n});for(let i=0;i<this.nclass;i++){const n=[],a=new Int32Array(this.p),l=this.classes[i];for(let t=0;t<this.n;t++)e[t]===l&&n.push(t);const o=n.length;s[l]=k()(o/this.n);let c=0;for(let e=0;e<this.p;e++){const s=n.map((s=>t.get(s,e)));a[e]=R(s),c+=a[e]}for(let t=0;t<this.p;t++){const e=k()(a[t]+this.alpha)-k()(c+this.p*this.alpha);r.set(t,i,e)}}this.prior=s,this.cprob=r},_.prototype.calcMultinomProb=function(t,e,s){const n=this.classes[e];let r=this.prior[n];for(s=0;s<this.p;s++){r+=t[s]?t[s]*this.cprob.get(s,e):0}return r},_.prototype.predictOne=function(t){const e=this.classes.length,s=new Array(e);for(let i=0;i<e;i++){const e=this.classes[i];s[i]=this.prior[e];for(let n=0;n<this.p;n++){const e=t[n]?t[n]*this.cprob.get(n,i):0;s[i]+=e}}let n=s[0],r=this.classes[0];for(let i=0;i<e;i++){const t=s[i];t>n&&(n=t,r=this.classes[i])}return r},_.prototype.predict=function(t){const e=this.classes.length;if(E()(t)&&(t=y()(t)),x()(t)){const s=[],n=t.shape[0];for(let r=0;r<n;r++){const n=new Array(e);for(let s=0;s<e;s++){const e=this.classes[s];n[s]=this.prior[e];for(let i=0;i<this.p;i++){const e=t.get(r,i)?t.get(r,i)*this.cprob.get(i,s):0;n[s]+=e}}let i=n[0],a=this.classes[0];for(let t=0;t<e;t++){const e=n[t];e>i&&(i=e,a=this.classes[t])}s[r]=a}return s}return this.predictOne(t)},_.prototype.predictProbs=function(t){if(E()(t)&&(t=y()(t)),x()(t)){const e=t.shape[0],s=new Array(e);for(let n=0;n<e;n++){let e=new Array(this.nclass);for(let s=0;s<this.nclass;s++){const r=this.classes[s];e[s]=this.prior[r];for(let i=0;i<this.p;i++){const r=t.get(n,i)?t.get(n,i)*this.cprob.get(i,s):0;e[s]+=r}}const r=(0,G.Z)(e);let i=0;for(let t=0;t<e.length;t++)i+=f()(e[t]-r);const a=r+k()(i);e=(0,V.Z)(e,a),s[n]=e.map((t=>f()(t)))}return s}let e=new Array(this.nclass);for(let i=0;i<this.nclass;i++){const s=this.classes[i];e[i]=this.prior[s];for(let n=0;n<this.p;n++){const s=t[n]*this.cprob.get(n,i);e[i]+=s}}const s=(0,G.Z)(e);let n=0;for(let i=0;i<e.length;i++)n+=f()(e[i]-s);const r=s+k()(n);return e=(0,V.Z)(e,r),e.map((t=>f()(t)))};var N=s(53145),S=s(76798),W=s(32921);let j=0;const D=({x:t,y:e,data:s,quantitative:n,omitMissing:r})=>{try{const i=r?N.W:N.i,{matrix:a,predictors:l,yvalues:o}=i(t,e,s,n),c=function(t,e){if(E()(t))t=y()(t);else if(!x()(t))throw new TypeError("invalid input argument. The first argument must be a matrix or an array-of-arrays. Value: `"+t+"`");if(!b()(e))throw new TypeError("invalid input argument. The second argument must be array-like. Value: `"+e+"`");return new C(t,e)}(a,o);return{result:c,predictors:l}}catch(i){return{}}};class I extends n.Component{constructor(t){var e,s,n;super(t),n=()=>{this.props.onPredict(this.state.result,j)},(s="handlePrediction")in(e=this)?Object.defineProperty(e,s,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[s]=n,j+=1;const{x:r,y:i,data:a,quantitative:l,omitMissing:o}=t;this.state={...D({x:r,y:i,data:a,quantitative:l,omitMissing:o}),...t}}static getDerivedStateFromProps(t,e){if(t.data!==e.data||t.quantitative!==e.quantitative||t.x!==e.x||t.y!==e.y||t.omitMissing!==e.omitMissing){const{x:e,y:s,data:n,quantitative:r,omitMissing:i}=t;return{...D({x:e,y:s,data:n,quantitative:r,omitMissing:i}),...t}}return null}render(){const{result:t,predictors:e}=this.state,{t:s}=this.props;return t?n.createElement("div",{style:{overflowX:"auto",width:"100%"}},n.createElement("span",{className:"title"},s("naive-bayes-for-response",{y:this.props.y,counter:j})),((t,e,s,r)=>n.createElement("div",null,n.createElement("span",{className:"title"},r("apriori-probs"),":"),n.createElement(c.Z,{bordered:!0,size:"sm"},n.createElement("thead",null,n.createElement("tr",null,e.classes.map(((t,e)=>n.createElement("th",{key:e},t))))),n.createElement("tbody",null,n.createElement("tr",null,e.classes.map(((t,s)=>n.createElement("th",{key:s},f()(e.prior[t]).toFixed(3))))))),n.createElement("span",{className:"title"},r("conditionals"),":"),t.map(((t,i)=>u()(s,t)?n.createElement(c.Z,{bordered:!0,size:"sm",key:i},n.createElement("thead",null,n.createElement("tr",null,n.createElement("th",null,t),e.classes.map(((t,e)=>n.createElement("th",{key:e},t))))),n.createElement("tbody",null,n.createElement("tr",null,n.createElement("th",null,r("mean")),e.classes.map(((t,s)=>n.createElement("td",{key:`${i}-${s}`},e.mu.get(i,s).toFixed(6))))),n.createElement("tr",null,n.createElement("th",null,r("sd")),e.classes.map(((t,s)=>n.createElement("td",{key:`${i}-${s}`},e.sigma.get(i,s).toFixed(6))))))):n.createElement(c.Z,{bordered:!0,size:"sm",key:i},n.createElement("thead",null,n.createElement("tr",null,n.createElement("th",null,t),e.classes.map(((t,e)=>n.createElement("th",{key:e},t))))),n.createElement("tbody",null,n.createElement("tr",null,n.createElement("th",null,r("yes")),e.classes.map(((t,s)=>n.createElement("td",{key:`${i}-${s}`},e.mu.get(i,s).toFixed(3))))),n.createElement("tr",null,n.createElement("th",null,r("no")),e.classes.map(((t,s)=>n.createElement("td",{key:`${i}-${s}`},(1-e.mu.get(i,s)).toFixed(3)))))))))))(e,t,this.props.quantitative,s),this.props.onPredict?n.createElement(m.Z,{tooltip:s("use-model-to-predict-tooltip")},n.createElement(o.Z,{variant:"secondary",size:"sm",onClick:this.handlePrediction},s("use-model-to-predict"))):null):n.createElement(l.Z,{variant:"danger"},s("missing-attributes"))}}I.defaultProps={omitMissing:!1,onPredict:null},I.propTypes={data:i().object.isRequired,y:i().oneOfType([i().string,i().instanceOf(W.E)]).isRequired,x:i().oneOfType([i().arrayOf(i().oneOfType([i().string,i().instanceOf(W.E)])),i().string,i().instanceOf(W.E)]).isRequired,quantitative:i().arrayOf(i().string).isRequired,omitMissing:i().bool,onPredict:i().func};var X=(0,a.Z)("models")((0,S.W)(I))},90861:function(t,e,s){s.r(e);var n=s(7474),r=s.n(n);e.default=function(t,e){if(!r()(t))throw new TypeError("invalid argument. First argument must be a matrix or array of test data. Value: `"+t+"`");if(!r()(e))throw new TypeError("invalid argument. Second argument must be an array of labels for the test data. Value: `"+e+"`");const s=this.predict(t),n=e.length;let i=0;for(let r=0;r<n;r++)s[r]===e[r]&&(i+=1);return i/=n,i}},16684:function(t,e,s){var n=s(7474),r=s.n(n),i=s(42415);e.Z=function(t,e){const s=r()(e);if(!r()(t))throw new TypeError("invalid input argument. Must provide an array. Value: `"+t+"`.");if(!s&&!(0,i.isPrimitive)(e))throw new TypeError("invalid input argument. Second argument must either be an array or number primitive. Value: `"+e+"`.");const n=t.length,a=new Array(n);if(s){if(n!==e.length)throw new Error("invalid input argument. Array to be added must have a length equal to that of the input array.");for(let s=0;s<n;s++)a[s]=t[s]-e[s]}else for(let r=0;r<n;r++)a[r]=t[r]-e;return a}},11120:function(t,e,s){var n=s(45042);t.exports=n},45042:function(t,e,s){var n=s(73830)(s(22949));t.exports=n}}]);
//# sourceMappingURL=NaiveBayes.de01134e.chunk.js.map